/* Generated By:JavaCC: Do not edit this line. TDLParser.java */
import java.io.IOException;
import java.io.File;


public class TDLParser implements TDLParserConstants {
        /* Class Constants */
  public final static String SPACE_STRING  = " ";
  public final static int    DEFAULT_STATE = TDLParserConstants.DEFAULT;
  public final static String PARENT_WARNING
                 = ":  Warning:  Use of \u005c"PARENT\u005c" keyword is deprecated."
                   + "  Assuming you meant to use \u005c"THIS\u005c".";
  public final static String SELF_WARNING
                 = ":  Warning:  Use of \u005c"SELF\u005c" keyword is deprecated."
                   + "  Assuming you meant to use \u005c"CHILD\u005c".";



        /* Class Variables */
  private   static DataSourceString    staticStringDataSource
                                         = new DataSourceString ( "" );
  private   static DataSourceFile      staticFileDataSource
                                         = new DataSourceFile ( );

  private   static TDLParser           staticTDLParser = null;

  protected static DataSource          lastDataSource = null;

  protected static DataTaskDefinition  currentDataTaskDefinition = null;


        /* Class variables for debugging... */
  protected static boolean             debugDistributedDeclarationSet = false;


        /* TDLParser routines / interface */
  public static TDLParser getParser()
  {
    if ( TDLParser . staticTDLParser == null )
      TDLParser . staticTDLParser = new TDLParser ( staticStringDataSource );
    return staticTDLParser;
  }

  public static DataSource getLastDataSource()  { return lastDataSource; }

  public static void reinitParser ( String theSourceString )
  {
    TDLParser . staticStringDataSource . setString ( theSourceString );
    TDLParser . reinitParser ( TDLParser . staticStringDataSource );
  }

  public static void reinitParser ( File  theFile )
  {
    TDLParser . staticFileDataSource . setFile ( theFile );
    TDLParser . reinitParser ( TDLParser . staticFileDataSource );
  }

  public static void reinitParser ( DataSource theSource )
  {
    TDLParser . getParser() . ReInit ( theSource );
    lastDataSource = theSource;
    clearParsingTask();
  }


      /* When printing messages, we need the [<filename>/stdin/Line]: string */
  public static String getFilenameWithoutPathPlusColon()
  {
    return TDLParser.lastDataSource . getFilenameWithoutPathPlusColon();
  }


        /* Sometimes we need to know what kind of task we are currently
	 * parsing, way down in the depths of parsing the Task body...
	 */
  public static boolean getIsParsingMonitorBody()
  {
    return (   (    currentDataTaskDefinition != null          )
            && (    currentDataTaskDefinition . getTaskType()
                 == DataTaskDefinition.MONITOR_TASK            ) );
  }

  public static boolean getIsParsingExceptionHandlerBody()
  {
    return (   (    currentDataTaskDefinition != null          )
            && (    currentDataTaskDefinition . getTaskType()
                 == DataTaskDefinition.HANDLER_TASK            ) );
  }

  public static void setParsingTask ( DataTaskDefinition theDataTaskDefinition)
  {
    currentDataTaskDefinition = theDataTaskDefinition;
  }

  public static void clearParsingTask()
  {
    currentDataTaskDefinition = null;
  }



        /* This Main() is used for testing/debugging TDLParser... */
  public static void main ( String args[] ) throws java.io.IOException
  {
    StringBuffer       inputData = new StringBuffer ( 1000 );
    int                inchar;
    DataTaskDefinition dataTaskDef;
    char               selectedTest = '-';
    char               subTest      = '-';
    int                i;

    System.err.println("Starting...");

    while ( ( inchar = System.in.read() ) != -1 )
      inputData . append ( (char) ( inchar & 0x00ff ) );

    if ( args . length > 0 )
    {
      if ( args[0] . length() > 0 )
        selectedTest = args[0].charAt(0);

      if ( args[0] . length() > 1 )
        subTest = args[0].charAt(1);
    }

    System.err.println ( "Running test (\u005c"" + selectedTest + "\u005c")  (\u005c""
                         + subTest + "\u005c")  [" + args . length + "]" );


    TDLParser . reinitParser ( inputData . toString() );

    System.err.println("Parsing...");


    try
    {
      switch ( selectedTest )
      {
        case 's':
          DataStatement  statement = parseStatement(0,0);
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn" + statement.toString() );
          break;

        case 'e':
          DataExpressionStatement Estatement = parseExpressionStatement(0);
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn" + Estatement.toString());
          break;

        case 'd':
          DataDeclarationStatement Dstatement = parseDeclarationStatement(0);
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn" + Dstatement.toString());
          break;

        case 'I':
          DataStatement  Istatement = parseForInitStatement(0);
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn" + Istatement.toString());
          break;

        case 'c':
                /* Note:  Parser should be set to correct Token-state up above.
		 *        (But it might not be...)
		 */
          DataConstraint dataConstraint = parseConstraint ( null, 0 );
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn"
                             + dataConstraint.toString() );
          break;

        case 'C':
                /* Note:  Parser should be set to correct Token-state up above.
		 *        (But it might not be...)
		 */
          DataConstraintStatement dataConstraintStatement
            = parseConstraintStatement ( 0 );
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn--------\u005cn"
                             + dataConstraintStatement.toString() );
          break;

        case 'f':
          DataFile  file = parseFile(null);
          System.err.println("Ending...");
          System.err.print("\u005cnResults:\u005cn\u005cn" + file.toString() );
          break;


        case 'x':
          Token startToken = getToken(0);
          DataComponent tmpDataComponent = new DataExpression();

          switch ( subTest )
          {
            case 'a':
              parseStringConstantAndIdsAssumingTheyAreMacros();
              break;
            case 'b':
              parseLiteral();
              break;
            case 'd':
              parseExpression();
              break;

            default:
            case 'c':
              parsePrimaryExpression();
              break;
          }

          parseMiscTokens ( tmpDataComponent, startToken, 0 );
          System.out.println ( "Parsed:  " + tmpDataComponent.toString() );
          break;


        case 'y':
          DataComponent tmp_Ytest;

                /* Enable debugging for this test. */
          TDLParser.debugDistributedDeclarationSet = true;

          switch ( subTest )
          {

            case 'd':
              tmp_Ytest = parseDistributedDeclarationSet(null);
              break;
            case 't':
              tmp_Ytest = parseDistributedTypedef();
              break;
            case 's':
              tmp_Ytest = parseDistributedStruct(null);
              break;
            default:
            case 'e':
              tmp_Ytest = parseDistributedEnum (null);
              break;
          }

          System.out.println ( "Parsed:  " + tmp_Ytest.toString() );
          break;


        case 'z':
          System.out.println("Running on:  " + inputData . toString() +"\u005cn\u005cn");
          Token  token = getToken(1);
          for ( i = 2;  true ;    token = getToken(i++) )
          {
            System.out.println (
              "Token [" + i + "]  kind=" + token.kind
              + " " + TDLParserConstants.tokenImage[token.kind]
              + "   image=\u005c"" + token.image + "\u005c"" );
            if ( token.kind == EOF )
              break;
          }
          break;


        case 't':
        default:
          dataTaskDef = parseTaskDefinitionHead ( null );
          System.err.println("Ending...");
          System.err.println("\u005cnResults:\u005cn\u005cn" + dataTaskDef . toString () );
          System.err.println("\u005cnargcount = "
                             + dataTaskDef . getTaskArgumentCount() );
          if ( dataTaskDef . getTaskArgumentCount() > 0 )
          {
            System.err.println("\u005cnarg1:"
               +   "\u005cn  Dir...: \u005c""
               + dataTaskDef.getTaskArgument(0).getArgumentDirectionString()
               + "\u005c"\u005cn  Name..: \u005c""
               + dataTaskDef.getTaskArgument(0).getArgumentName()
               + "\u005c"\u005cn  Full..: \u005c""
               + dataTaskDef.getTaskArgument(0).toString()

               + "\u005c"\u005cn  DISTRIBTED............: \u005c""
               + dataTaskDef.getTaskArgument(0).getIsDistributed()
               + "\u005c"\u005cn  DISTRIBTED_type.......: \u005c""
               + dataTaskDef.getTaskArgument(0).getDistributedTypeString()
               + "\u005c"\u005cn  DISTRIBTED_id.........: \u005c""
               + dataTaskDef.getTaskArgument(0).getDistributedId()
               + "\u005c"\u005cn  DISTRIBTED_isPointer..: \u005c""
               + dataTaskDef.getTaskArgument(0).getDistributedIsPointer()

               + "\u005c"\u005cn" );
            for ( i=0;
                  i < dataTaskDef.getTaskArgument(0).getSubcomponentsCount();
                  i++ )
            {
              System.err.println("  subComponent[" + i + "]...: \u005c""
                 + dataTaskDef.getTaskArgument(0).getStringSubcomponent ( i )
                 + "\u005c"" );
            }
          }
          break;

      } /* switch ( seletedTest ) */

    }
    catch ( ParseException  theParseException )
    {
      System.err.println ("Caught parse Exception:");
      System.err.println ( theParseException );
      if ( theParseException . currentToken != null )
      {
        System.err.println ( "\u005cn\u005cnNote:  Kind = "
                             + theParseException . currentToken.kind );
        System.err.println ( "\u005cnNote:  Token = \u005c""
                             + theParseException . currentToken + "\u005c"" );
        if ( theParseException . currentToken.next != null )
        {
          System.err.println ( "\u005cn\u005cnNote:  Kind = "
                               + theParseException . currentToken.next.kind );
          System.err.println ( "\u005cnNote:  Token = \u005c""
                               + theParseException . currentToken.next + "\u005c"");
        }
      }

        /* For debugging, it helps to know what tokens were pending. */
      System.err.println ( "\u005cn\u005cnTokens on stream were:\u005cn" );
      for ( i=0; i<10; i++ )
      {
        System.err.println ( "  Pending Token (" + i + ") was \u005c""
                             + getToken(i).image + "\u005c"   type="
                             + getToken(i).kind + "   ("
                             + TDLParserConstants.tokenImage[getToken(i).kind]
                             + ")" );
      }
    }
  }


        /* Used to manually generate a ParseException from code in this file.
	 * Must be compatible with DetailedParseException so we can get
	 * information regarding which token (and where in the file) we died.
	 */
  public static ParseException generateParseException ( Token   theToken,
                                                        String  theText  )
  { return generateParseException ( theToken, theToken, theText ); }

  public static ParseException generateParseException( Token  theToken,
                                                       Token  theLocationToken,
                                                       String theText  )
  {
    Token           hackToken      = theToken . newToken ( theToken . kind );
    ParseException  parseException
      = new ParseException ( "\u005cn"
                             + TDLParser.getFilenameWithoutPathPlusColon()
                             + ( theLocationToken.beginLine + 1 )
                             + ":  Error:\u005cn  "
                             + theText );

    hackToken . kind = theToken . kind;

    hackToken . beginLine    = theToken . beginLine;
    hackToken . beginColumn  = theToken . beginColumn;
    hackToken . endLine      = theToken . endLine;
    hackToken . endColumn    = theToken . endColumn;
    hackToken . image        = theToken . image;
    hackToken . next         = theToken;
    hackToken . specialToken = theToken . specialToken;

    parseException . currentToken = hackToken;
    return parseException;
  }


  /* Used to process fluff ( comments, whitespace, etc ) that would
   * ordinarily have been ignored or filtered out by the pre-processor.
   */
  public static void parseFluffIgnoreSpaces ( DataComponent theDataComponent,
                                              Token         theToken )
  {
    int index = theDataComponent . getSubcomponentsCount();

    for ( Token  token = theToken . specialToken;
          token != null;
          token = token . specialToken )
    {
      if ( token . kind != WHITESPACE )
        theDataComponent . addSubcomponent ( token.image, index );
    }
  }

  public static void parseFluff ( DataComponent theDataComponent,
                                  Token         theToken,
                                  int           theUnIndent )
  {
    StringBuffer  stringBuffer = null;
    String        string;
    int           i, j,
                  unindentCount,
                  column,
                  spaceToAddForTabChar,
                  componentIndex = theDataComponent . getSubcomponentsCount();

    for ( Token  token = theToken . specialToken;
          token != null;
          token = token . specialToken )
    {
      if ( token . kind != WHITESPACE )
      {
        string = token.image;
      }
      else /* Ie:  token . kind == WHITESPACE  && we are un-indenting... */
      {
                /* Find our starting column... */
        column = theToken . beginColumn;

                /* If we have whitespace that doesn't start at column 0, */
                /* something else, non-whitespace, must be there.        */
                /* We do *NOT* want to strip whitespace in this case!!!  */
        if ( column == 0 )
          unindentCount = theUnIndent;
        else
          unindentCount = 0;

                /* Create/Erase the stringBuffer is necessary */
        if ( stringBuffer == null )
          stringBuffer = new StringBuffer();
        stringBuffer . setLength( 0 );

                /* Process the characters */
        for ( i=0; i < token.image.length();  i++ )
        {
          switch ( token.image.charAt ( i )  )
          {
            case '\u005cn':
            case '\u005cf':
            case '\u005cr': /* Should we re-indent after carriage-returns? */
              unindentCount = theUnIndent;
              column = 0;
              stringBuffer . append ( token.image.charAt ( i ) );
              break;

            case '\u005ct':
              spaceToAddForTabChar = DataComponent.getTabSize()
                                     - ( column % DataComponent.getTabSize() );
              for ( j=0; j < spaceToAddForTabChar; j++ )
              {
                if ( unindentCount > 0 )
                  unindentCount--;
                else
                  stringBuffer . append ( " " );
              }
              column += spaceToAddForTabChar;
              break;

            case ' ':
              if ( unindentCount > 0 )
                unindentCount--;
              else
                stringBuffer . append ( " " );
              break;

            default:
              System.err.println ( "[TDLParser:parseFluff(... , theindent)]  "
                         + "Error:  Unexpected whitespace character \u005c'0x"
                         + Integer.toHexString ( token.image.charAt ( i ) )
                         + "\u005c'" );
              break;
          }
        }

        string = stringBuffer . toString();
      }

      theDataComponent . addSubcomponent ( string, componentIndex );

    } /* For ( token = specialToken's ) */
  }



  public static void parseMiscTokens ( DataComponent theDataComponent,
                                       Token         theStartToken,
                                       int           theUnIndent )
  {
    for ( Token  token = theStartToken . next;
          token != getToken(1);
          token = token . next )
    {
      parseFluff ( theDataComponent, token, theUnIndent );
      theDataComponent . addSubcomponent ( token.image );
    }
  }

  public static void parseMiscTokensIgnoringLast (
                                          DataComponent theDataComponent,
                                          Token         theStartToken,
                                          int           theUnIndent )
  {
    for ( Token  token = theStartToken . next;
          token != getToken(0);
          token = token . next )
    {
      parseFluff ( theDataComponent, token, theUnIndent );
      theDataComponent . addSubcomponent ( token.image );
    }
  }


        /* Note:  Can't do conditional-branch parsing inside BNF's. *
	 * So we export as much redundancy as possible over here.   */
  public static void checkForTrailingCommaOrOpenBrace ( Token theNextToken )
    throws ParseException
  {
        /* Idiocy check */
    if (   ( theNextToken.kind != COMMA      )
        && ( theNextToken.kind != OPEN_BRACE ) )
    {
      throw generateParseException (
                    theNextToken,
                    "Next token should have been a COMMA or an OPEN-BRACE.  "
                  + "Instead found \u005c"" + theNextToken.image + "\u005c"." );
    }
  }

  public static void checkForTrailingCommaOrOpenBraceOrStringOrMacroString (
                                                           Token theNextToken )
    throws ParseException
  {
        /* Idiocy check */
    if (   ( theNextToken.kind != COMMA           )
        && ( theNextToken.kind != OPEN_BRACE      )
        && ( theNextToken.kind != STRING_CONSTANT )
        && ( theNextToken.kind != ID              ) )
    {
      throw generateParseException (
                    theNextToken,
                    "Next token should have been a COMMA, an OPEN-BRACE, "
                  + "a STRING_CONSTANT, or an identifier corresponding to "
                  + "a #define'd (macro) string constant.  "
                  + "Instead found \u005c"" + theNextToken.image + "\u005c"." );
    }
  }

        /* Note:  Can't do conditional-branch parsing inside BNF's. *
	 * So we export as much redundancy as possible over here.   */
  public static void processTrailingFluffBeforeTheseTokenKindsOnly (
                                         DataComponent theDataComponent,
                                         Token         theNextToken,
                                         int           theUnIndent,
                                         int           theFirstNextTokenKind,
                                         int           theSecondNextTokenKind )
  {
    if (   ( theNextToken.kind == theFirstNextTokenKind  )
        || ( theNextToken.kind == theSecondNextTokenKind ) )
    {
            /* Process subsequent fluff off next token. */
      parseFluff ( theDataComponent, theNextToken, theUnIndent );
            /* Record that this fluff has already been processed. */
      theNextToken . specialToken = null;
    }
  }


  protected static int parseFileSnarfFluffAndMaybeNextToken (
                                            boolean      theIncludeNextToken,
                                            StringBuffer theStringBuffer,
                                            int          theCurrentLineNumber )
  {
    int    stringBufferCurrentLength = theStringBuffer . length();
    Token  fluffToken;

            /* Add all the fluff tokens to the string we are building... */
    for ( fluffToken  = getToken ( 1 ) . specialToken;
          fluffToken != null;
          fluffToken = fluffToken . specialToken )
    {
      if (   ( theStringBuffer . length() <= 0                          )
          || ( theCurrentLineNumber       <  0                          )
          || ( theCurrentLineNumber       >  (fluffToken.beginLine + 1) ) )
      {
        theCurrentLineNumber = fluffToken.beginLine + 1;
      }

        /* Use insert at stringBufferCurrentLength to reverse the order */
      theStringBuffer . insert ( stringBufferCurrentLength, fluffToken.image );
    }


    if ( theIncludeNextToken == true )
    {
      if (   ( theStringBuffer . length() <= 0                           )
          || ( theCurrentLineNumber       <  0                           )
          || ( theCurrentLineNumber       >  (getToken(1).beginLine + 1) ) )
      {
        theCurrentLineNumber = getToken ( 1 ) . beginLine + 1;
      }

        /* Append this token to the string we are building... */
      theStringBuffer . append ( getToken ( 1 ) . image );
    }

    return theCurrentLineNumber;

  } /* protected static int parseFileSnarfFluffAndMaybeNextToken */



        /* This functionality occurs an awfully lot in parseFile() */
  protected static int parseFileInternal_addInCurrentLeadingStrings (
                                       StringBuffer  theStringBuffer,
                                       DataFile      theThisFile,
                                       int           theCurrentLineNumber )
  {
            /* Add in the current leading string(s) */
    if ( theStringBuffer . length() > 0 )
    {
      theThisFile . addSubcomponent ( new DataComponentPlaceholder (
                                                  theStringBuffer . toString(),
                                                  theCurrentLineNumber ) );
      theStringBuffer . setLength ( 0 );

      return -1; /*New value for currentLineNumber; Arbitrary negative number*/
    }
    else
    {
      return theCurrentLineNumber;
    }
  }

        /* Replicated from parseIdToken() down below for use in JAVACODE. */
  protected static boolean isIdToken ( Token theToken )
  {
    switch ( theToken . kind )
    {
      case ID:
      case NAME:

      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:

      case DISTRIBUTED:
      case THREADED:

      case FIRST:
        return true;

      default:
        return false;
    }
  }

/******************/
/*** <ID> Token ***/
/******************/

/*
 * <ID> really ought to let us use various other tokens as valid ID's.
 * Note: For backward compatibility, this *MUST* ONLY PARSE A SINGLE TOKEN.
 * Note: Limit us to things that are not used elsewhere inside Tasks, or this
 *       is going to become extremely painful.
 * Note: Also replicated in isIdToken(Token) up above.
 */
  static final public Token parseIdToken() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      jj_consume_token(ID);
      break;
    case NAME:
      jj_consume_token(NAME);
      break;
    case TASK:
      jj_consume_token(TASK);
      break;
    case GOAL:
      jj_consume_token(GOAL);
      break;
    case COMMAND:
      jj_consume_token(COMMAND);
      break;
    case MONITOR:
      jj_consume_token(MONITOR);
      break;
    case EXCEPTION:
      jj_consume_token(EXCEPTION);
      break;
    case HANDLER:
      jj_consume_token(HANDLER);
      break;
    case RESUME:
      jj_consume_token(RESUME);
      break;
    case HANDLES:
      jj_consume_token(HANDLES);
      break;
    case DISTRIBUTED:
      jj_consume_token(DISTRIBUTED);
      break;
    case THREADED:
      jj_consume_token(THREADED);
      break;
    case FIRST:
      jj_consume_token(FIRST);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return getToken(0);}
    throw new Error("Missing return statement in function");
  }

/***********************/
/*** STRING_CONSTANT ***/
/***********************/

/*
 * <STRING_CONSTANT> really needs to include <ID>'s, to deal with
 * #defined macros.  However, including <ID>'s in the <STRING_CONSTANT>
 * token causes unbelievable pain and suffering.  (Amongst other things,
 * the token-type chosen is the longest token type.)
 */
  static final public void parseStringConstantAndIdsAssumingTheyAreMacros() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_CONSTANT:
        jj_consume_token(STRING_CONSTANT);
        break;
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case ID:
        parseIdToken();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case STRING_CONSTANT:
      case ID:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
  }

  static String parseStripFluff(boolean theStripStrings) throws ParseException {
  StringBuffer   stringBuffer = new StringBuffer ( 1000 );


  for ( ;   getToken ( 1 ) . kind != EOF;   getNextToken() )
  {
    if (   ( theStripStrings       == true            )
        && ( getToken ( 1 ) . kind == STRING_CONSTANT ) )
      continue;

    stringBuffer . append ( getToken ( 1 ) . image );
    stringBuffer . append ( " " );
  }

  return stringBuffer . toString();
  }

  static DataFile parseFile(DataFile  theDataFile) throws ParseException {
  int           indexToCheck, spawnIndent, currentLineNumber = -1;
  boolean       needToCheckAdditionalToken;
  StringBuffer  stringBuffer = new StringBuffer();
  DataVector    stack        = new DataVector ( 10 );
  Token         stackToken;
  DataSpawnTask dataSpawnTask;
  DataFile      thisFile = (   ( theDataFile != null )
                             ? theDataFile : new DataFile() );
  int           i, j;
  Token         labeledSpawnToken;
  boolean       stackInsideSomethingOtherThanClassStructNamespace;
  boolean       stackInsideClassStruct; /* Namespace doesn't count. */


  while ( getToken ( 1 ) . kind != EOF )
  {
        /* We used to be able to just check (getToken ( 1 ) . kind == SPAWN),
	 * but labels complicate that...
	 */
    labeledSpawnToken = null;
    for ( i = 1;   getToken ( i ) . kind != EOF;   i += 2 )
    {
      if ( getToken ( i ) . kind == SPAWN )
      {
        labeledSpawnToken = getToken ( i );
        break;
      }

      if (   ( getToken ( i   ) . kind != ID    )
          || ( getToken ( i+1 ) . kind != COLON ) )
        break;
    }


        /* Check to see if there is anything other than class/namespace "{" *
	 * on the stack (for use later on)...                               */
    stackInsideSomethingOtherThanClassStructNamespace = false;
    stackInsideClassStruct                            = false;
    for ( i = 0;  i < stack.count();  i++ )
    {
      stackToken = (Token) ( stack . elementAt ( i ) );

      if ( stackToken instanceof ClassStructNamespaceToken )
      {
        switch ( ((ClassStructNamespaceToken) stackToken) . type )
        {
          case CLASS:
          case STRUCT:
            stackInsideClassStruct = true;
            break;
        }
      }
      else
      {
        stackInsideSomethingOtherThanClassStructNamespace = true;
      }

      if (   ( stackInsideSomethingOtherThanClassStructNamespace == true )
          && ( stackInsideClassStruct                            == true ) )
        break;
    }


                /*****************************/
                /* Are we defining a Task??? */
                /*****************************/
                /* Start checking with the next token. */
    indexToCheck = 1;

    do
    {
      needToCheckAdditionalToken = false;

                        /* Is it extern? */
      if (   (   ( getToken ( indexToCheck     ) . kind  == EXTERN_CS   )
              || ( getToken ( indexToCheck     ) . kind  == EXTERN_CI   )

                        /* Is it PERSISTENT? */
              || ( getToken ( indexToCheck     ) . kind  == PERSISTENT  )

                        /* Is it distributed? */
              || ( getToken ( indexToCheck     ) . kind  == DISTRIBUTED )

                        /* Is it threaded? */
              || ( getToken ( indexToCheck     ) . kind  == THREADED    )

                        /* Is it static? */
              || ( getToken ( indexToCheck     ) . kind  == STATIC_CS   )
              || ( getToken ( indexToCheck     ) . kind  == STATIC_CI   )

                        /* Is it virtual? */
              || ( getToken ( indexToCheck     ) . kind  == VIRTUAL_CS  )
              || ( getToken ( indexToCheck     ) . kind  == VIRTUAL_CI  ) )

          && (     getToken ( indexToCheck + 1 ) . kind  != EOF           ) )
      {
          /* Need to check the next token. */
        indexToCheck ++;
        needToCheckAdditionalToken = true;
      }
    } while ( needToCheckAdditionalToken == true );

        /***************************/
        /* Are we defining a task? */
        /***************************/
    if (   (   ( getToken ( indexToCheck ) . kind == TASK      )
            || ( getToken ( indexToCheck ) . kind == GOAL      )
            || ( getToken ( indexToCheck ) . kind == COMMAND   )
            || ( getToken ( indexToCheck ) . kind == MONITOR   )
            || ( getToken ( indexToCheck ) . kind == EXCEPTION )
            || ( getToken ( indexToCheck ) . kind == HANDLER   )
            || ( getToken ( indexToCheck ) . kind == RESUME    ) )
        /* Tasks can be defined if we are outside everything (empty stack) *
	 * or if we are only inside class/struct/namespace declarations.   */
        && ( stackInsideSomethingOtherThanClassStructNamespace == false ) )
    {
            /* Add in the current leading string(s) */
      currentLineNumber
        = parseFileInternal_addInCurrentLeadingStrings( stringBuffer,
                                                        thisFile,
                                                        currentLineNumber);
            /* Snarf the task. */
      DataTaskDefinition  tmpDataTaskDefinition
        = parseFullTaskDefinition ( null, stackInsideClassStruct );

            /* If necessary, add scoping here... */
      if ( tmpDataTaskDefinition . getTaskScope() . hasScope() == false )
      {
        int scopeCount = 0;
        for ( i = 0;  i < stack.count();  i++ )
        {
          stackToken = (Token) ( stack . elementAt ( i ) );
          if ( stackToken instanceof ClassStructNamespaceToken )
          {
            tmpDataTaskDefinition . setWasImplicitlyScoped();

            tmpDataTaskDefinition . getTaskScope() . addScope (
               ((ClassStructNamespaceToken) stackToken) . idToken . image );

            tmpDataTaskDefinition . getTaskScope()
              . setIndex ( DataScope.IDENTIFIER_INDEX + scopeCount );

            tmpDataTaskDefinition . getTaskScope()
              . setIndex ( DataScope.SCOPE + scopeCount );

            scopeCount ++;
          }
        } /* for ( i = 0;  i < stack.count();  i++ ) */
      } /* if ( tmpDataTaskDefinition . hasTaskScope() ) */

            /* Now we can add it to the file. */
      thisFile . addSubcomponent ( tmpDataTaskDefinition );

            /* Go on to next parse... */
      continue;
    } /* IF ( Are we defining a task ) */


        /* Are we starting a class or namespace? */
    else if (   (   ( getToken ( 1 ) . kind == CLASS      )
                 || ( getToken ( 1 ) . kind == STRUCT     )
                 || ( getToken ( 1 ) . kind == NAMESPACE  ) )
             && (     isIdToken ( getToken ( 2 ) )          )
             && (   ( getToken ( 3 ) . kind == OPEN_BRACE )
                 || ( getToken ( 3 ) . kind == COLON      ) ) )
    {
        /* Add a munged copy of this token so we    *
	 * can detect it's a class/namespace token. */
      ClassStructNamespaceToken  tmpToken = new ClassStructNamespaceToken();
      tmpToken . kind         =  OPEN_BRACE;
      tmpToken . beginLine    =  getToken ( 2 ) . beginLine;
      tmpToken . beginColumn  =  getToken ( 2 ) . beginColumn;
      tmpToken . endLine      =  getToken ( 2 ) . endLine;
      tmpToken . endColumn    =  getToken ( 2 ) . endColumn;
      tmpToken . image        =  "class ..."; /* Reset properly down below. */
      tmpToken . specialToken = null;
      tmpToken . next         = null;
      tmpToken . type         = getToken ( 1 ) . kind;
      tmpToken . idToken      = getToken ( 2 );
      stack . addElement ( tmpToken );

            /* Add in the current leading string(s) */
      currentLineNumber
        = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                         thisFile,
                                                         currentLineNumber );

      DataClassStructNamespace tmpDataClassStructNamespace
                                 = parseStartDataClassStructNamespace ( null );

      thisFile . addSubcomponent ( tmpDataClassStructNamespace );

      tmpToken.image = tmpDataClassStructNamespace . toString();

            /* Go on to next parse... */
      continue;
    }

        /* Are we entering something? */
    else if (   ( getToken ( 1 ) . kind == OPEN_PAREN   )
             || ( getToken ( 1 ) . kind == OPEN_BRACKET )
             || ( getToken ( 1 ) . kind == OPEN_BRACE   ) )
    {
      stack . addElement ( getToken ( 1 ) );
        /* And snarf token down below... */
    }

        /* Are we inside something? */
    else if ( stack . isEmpty() == false )
    {
      stackToken = (Token) ( stack . lastElement() );

        /* Are we exiting something? */
      if (   (   ( stackToken     . kind == OPEN_PAREN    )
              && ( getToken ( 1 ) . kind == CLOSE_PAREN   ) )
          || (   ( stackToken     . kind == OPEN_BRACKET  )
              && ( getToken ( 1 ) . kind == CLOSE_BRACKET ) )
          || (   ( stackToken     . kind == OPEN_BRACE    )
              && ( getToken ( 1 ) . kind == CLOSE_BRACE   ) ) )
      {
        stack . removeLastElement();

            /* If we just ended a class/struct/namespace... */
        if ( stackToken instanceof ClassStructNamespaceToken )
        {
          if ( getToken ( 2 ) . kind != SEMICOLON )
          {
            throw generateParseException ( getToken ( 1 ),
                       "Encountered a \u005c""  +  getToken ( 1 ) . image
                     + "\u005c" WITHOUT A FOLLOWING \u005c";\u005c" at line "
                     + (getToken ( 1 ) . beginLine + 1)
                     + " while looking for a match to\u005cn-----\u005cn"
                     + stackToken.image
                     + "\u005cn-----\u005cnat line " + (stackToken . beginLine + 1)
                     + ".\u005cnParse Failed..." );
          }

            /* Add in the current leading string(s) */
          currentLineNumber
            = parseFileInternal_addInCurrentLeadingStrings( stringBuffer,
                                                            thisFile,
                                                            currentLineNumber);

          thisFile . addSubcomponent ( parseEndDataClassStructNamespace (
                                         null,
                                         stackToken.image.substring (
                                           0,
                                           stackToken.image.length() - 2 ) ) );

            /* Go on to next parse... */
          continue;
        } /* if ( stackToken instanceof ClassStructNamespaceToken ) */

        /* Otherwise, just keep going to parse the CLOSE_* token. */
      }

        /* Are we in error? */
      else if (   (   (     getToken ( 1 ) . kind == CLOSE_PAREN   )
                   || (     getToken ( 1 ) . kind == CLOSE_BRACKET )
                   || (     getToken ( 1 ) . kind == CLOSE_BRACE   ) )

               && (   (   ( stackToken     . kind == OPEN_PAREN    )
                       && ( getToken ( 1 ) . kind != CLOSE_PAREN   ) )
                   || (   ( stackToken     . kind == OPEN_BRACKET  )
                       && ( getToken ( 1 ) . kind != CLOSE_BRACKET ) )
                   || (   ( stackToken     . kind == OPEN_BRACE    )
                       && ( getToken ( 1 ) . kind != CLOSE_BRACE   ) ) ) )
      {
        throw generateParseException ( getToken ( 1 ),
                       "Encountered a \u005c""  +  getToken ( 1 ) . image
                     + "\u005c" at line " + (getToken ( 1 ) . beginLine + 1)
                     + " while looking for a match to \u005c"" + stackToken.image
                     + "\u005c" at line " + (stackToken . beginLine + 1)
                     + ".\u005cnParse Failed..." );
      }


        /* Spawn's can be embedded outside of tasks inside functions... */
      else if (   ( stackInsideSomethingOtherThanClassStructNamespace == true )
               && ( labeledSpawnToken                                 != null )
               )
      {
            /* Add in the current leading string(s) */
        currentLineNumber
          = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                           thisFile,
                                                           currentLineNumber );
            /* How far is this SPAWN indented?
	     * Note: getToken(1) may be a label, rather than the SPAWN token.
	     * (Which in turn makes for strange indentation...)
	     */
        if (   ( getToken ( 1 )   . beginColumn <= stackToken . beginColumn )
            || (labeledSpawnToken . beginColumn <= stackToken . beginColumn ) )
          spawnIndent = Math.max ( getToken ( 1 )    . beginColumn,
                                   labeledSpawnToken . beginColumn );
        else
          spawnIndent = Math.min ( getToken ( 1 )    . beginColumn,
                                   labeledSpawnToken . beginColumn );

            /* Snarf the task. */
        dataSpawnTask = parseLabeledSpawnTask ( null, spawnIndent );
                /* We are outside of the usual indenting procedures... So... */
        dataSpawnTask . setExtraIndent ( spawnIndent );
        thisFile . addSubcomponent ( dataSpawnTask );

            /* Go on to next parse... */
        continue;
      }

    } /* else if ( stack . isEmpty() == false ) */


        /* Otherwise:  General case... */
    else
    {
        /* Are we "#using" (including) another TDL file here? */
      if (   ( getToken ( 1 ) . kind == USING_FILE_STANDARD )
          || ( getToken ( 1 ) . kind == USING_FILE_QUOTE    ) )
      {
        currentLineNumber
          = parseFileSnarfFluffAndMaybeNextToken ( false, stringBuffer,
                                                   currentLineNumber   );

            /* Add in the current leading string(s) */
        currentLineNumber
          = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                           thisFile,
                                                           currentLineNumber );
            /* Add this using-file */
        thisFile . setIndex ( DataFile.USING_INDEX
                              + thisFile . getUsingFiles() . count() );
        thisFile . addUsingFileAndStripUsing ( getToken ( 1 ) . image );

            /* Go on to the next token... */
        getNextToken();

            /* Go on to next parse... */
        continue;
      }



                /*********************************************/
                /* Are we defining a extern "H" {} block ??? */
                /*********************************************/
      else if (   (   ( getToken ( 1 ) . kind == EXTERN_CS                )
                   || ( getToken ( 1 ) . kind == EXTERN_CI                ) )
               && (     getToken ( 2 ) . kind != EOF                        )
               && (     getToken ( 2 ) . image . equalsIgnoreCase ("\u005c"H\u005c"") )
               && (     getToken ( 3 ) . kind == OPEN_BRACE                 ) )
      {
            /* Add in the current leading string(s) */
        currentLineNumber
          = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                           thisFile,
                                                           currentLineNumber );

        thisFile . addSubcomponent ( parseDataExternH ( null ) );

            /* Go on to next parse... */
        continue;
      }



                /*********************************************************/
                /* Are we defining a distributed typedef/struct/enum ??? */
                /*********************************************************/
      else if (   (     getToken ( 1 ) . kind == DISTRIBUTED   )
               && (   ( getToken ( 2 ) . kind == STRUCT      )
                   || ( getToken ( 2 ) . kind == ENUM        )
                   || ( getToken ( 2 ) . kind == TYPEDEF     ) ) )
      {
            /* Add in the current leading string(s) */
        currentLineNumber
          = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                           thisFile,
                                                           currentLineNumber );
        try
        {
          if      ( getToken ( 2 ) . kind == TYPEDEF )
            thisFile . addSubcomponent ( parseDistributedTypedef() );
          else if ( getToken ( 2 ) . kind == STRUCT  )
            thisFile . addSubcomponent ( parseDistributedStruct(null) );
          else
            thisFile . addSubcomponent ( parseDistributedEnum(null) );

            /* Go on to next parse... */
          continue;
        }
        catch ( ParseException  theParseException )
        {
                /* Lets be a little bit more verbose here,        *
		 * so as not to confuse the end-users too much... */
          System.err.println ( TDLParser.getFilenameWithoutPathPlusColon()
                               + ( getToken ( 0 ) . beginLine + 1 )
                               + ":  Parse Error:  "
                               + "DISTRIBUTED struct/enum/typedef "
                               + "has unsupported declaration types." );
          throw theParseException;
        }
      } /* IF ( is a USING_FILE statement ) ....
	 * ELSE if ( are we defining a extern "H" {} block ) ...
	 * ELSE if ( are we defining a distributed typedef/struct/enum ) ...
	 */

    } /* IF ( class / namespace ) ...
       * ELSE IF ( "([{" ) ...
       * ELSE IF ( "([{" on stack -- at or before "}])" ) ...
       * ELSE ...
       */


        /* Otherwise, just snarf the tokens into the stringbuffer, */
        /* so we can have one really big string rather than lots of */
        /* little strings... */
    currentLineNumber
      = parseFileSnarfFluffAndMaybeNextToken ( true, stringBuffer,
                                               currentLineNumber  );


            /* Go on to the next token... */
    getNextToken();

  } /* while ( getToken ( 1 ) . kind  !=  EOF ) */



        /* Snarf the EOF token... */
  currentLineNumber
    = parseFileSnarfFluffAndMaybeNextToken ( false, stringBuffer,
                                             currentLineNumber   );


        /* If we are still inside something, report an error... */
  if ( stack . isEmpty() == false )
  {
    throw generateParseException ( getToken ( 1 ),
                    "File ends while still inside nested C/C++ Code.\u005cn"
                    + "File Parse Failure...\u005cnExpected a match to: \u005c""
                    + ( (Token) (stack . lastElement()) ) . image + "\u005c"" );
  }

        /* Add in the current trailing string(s) */
  currentLineNumber
    = parseFileInternal_addInCurrentLeadingStrings ( stringBuffer,
                                                     thisFile,
                                                     currentLineNumber );
  return thisFile;
  }

  static DataExternH parseDataExternH(DataExternH theDataExternH) throws ParseException {
  DataVector    stack        = new DataVector ( 10 );
  Token         stackToken;

  DataExternH   thisDataExternH = (   ( theDataExternH != null )
                                    ?   theDataExternH
                                    :   new DataExternH() );


  if (   (   ( getToken ( 1 ) . kind == EXTERN_CS                   )
          || ( getToken ( 1 ) . kind == EXTERN_CI                   ) )
      && (     getToken ( 2 ) . kind != EOF                           )
      && (     getToken ( 2 ) . image . equalsIgnoreCase ( "\u005c"H\u005c"" )  )
      && (     getToken ( 3 ) . kind == OPEN_BRACE                    ) )
  {
    thisDataExternH . setLineNumber ( getToken ( 1 ) . beginLine + 1 );

    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . setIndex ( DataExternH.EXTERN );

    parseFluff ( thisDataExternH, getToken ( 2 ), 0 );
    thisDataExternH . setIndex ( DataExternH.HEADER_STRING );

    parseFluff ( thisDataExternH, getToken ( 3 ), 0 );
    thisDataExternH . setIndex ( DataExternH.OPEN_BRACE );

        /* Snarf these 3 tokens. */
    getNextToken();
    getNextToken();
    getNextToken();
  }
  else
  {
        /* This should, in theory, never be reached. */
    throw generateParseException ( token,
                                   getToken ( 1 ),
                                     "Expected: 'EXTERN \u005c"H\u005c" {'.  "
                                   + "Found: '" + getToken(1).image + " "
                                   + getToken(2).image + " "
                                   + getToken(3).image + "\u005cn" );
  }



  while (   (     getToken ( 1 ) . kind != EOF           )
         && (   ( getToken ( 1 ) . kind != CLOSE_BRACE )
             || (  stack . isEmpty()    == false       ) ) )
  {
        /* Are we entering something? */
    if (   ( getToken ( 1 ) . kind == OPEN_PAREN   )
        || ( getToken ( 1 ) . kind == OPEN_BRACKET )
        || ( getToken ( 1 ) . kind == OPEN_BRACE   ) )
    {
      stack . addElement ( getToken ( 1 ) );
    }

        /* Are we inside something? */
    else if ( stack . isEmpty() == false )
    {
        /* Are we exiting something? */
      stackToken = (Token) ( stack . lastElement() );
      if (   (   ( stackToken     . kind == OPEN_PAREN    )
              && ( getToken ( 1 ) . kind == CLOSE_PAREN   ) )
          || (   ( stackToken     . kind == OPEN_BRACKET  )
              && ( getToken ( 1 ) . kind == CLOSE_BRACKET ) )
          || (   ( stackToken     . kind == OPEN_BRACE    )
              && ( getToken ( 1 ) . kind == CLOSE_BRACE   ) ) )
      {
        stack . removeLastElement();
      }

        /* Are we in error? */
      else if (   (   (     getToken ( 1 ) . kind == CLOSE_PAREN   )
                   || (     getToken ( 1 ) . kind == CLOSE_BRACKET )
                   || (     getToken ( 1 ) . kind == CLOSE_BRACE   ) )

               && (   (   ( stackToken     . kind == OPEN_PAREN    )
                       && ( getToken ( 1 ) . kind != CLOSE_PAREN   ) )
                   || (   ( stackToken     . kind == OPEN_BRACKET  )
                       && ( getToken ( 1 ) . kind != CLOSE_BRACKET ) )
                   || (   ( stackToken     . kind == OPEN_BRACE    )
                       && ( getToken ( 1 ) . kind != CLOSE_BRACE   ) ) ) )
      {
        throw generateParseException ( getToken ( 1 ),
                       "Encountered a \u005c""  +  getToken ( 1 ) . image
                     + "\u005c" at line " + (getToken ( 1 ) . beginLine + 1)
                     + " while looking for a match to \u005c"" + stackToken.image
                     + "\u005c" at line " + (stackToken . beginLine + 1)
                     + "\u005cnFile Parse Failed..." );
      }
    }

                /**************************************************/
                /* Special case:  Allow Distributed declars here. */
                /**************************************************/
    else if (   (     getToken ( 1 ) . kind == DISTRIBUTED   )
             && (   ( getToken ( 2 ) . kind == STRUCT      )
                 || ( getToken ( 2 ) . kind == ENUM        )
                 || ( getToken ( 2 ) . kind == TYPEDEF     ) ) )
    {
      try
      {
        if      ( getToken ( 2 ) . kind == TYPEDEF )
          thisDataExternH . addSubcomponent ( parseDistributedTypedef() );
        else if ( getToken ( 2 ) . kind == STRUCT  )
          thisDataExternH . addSubcomponent ( parseDistributedStruct(null) );
        else
          thisDataExternH . addSubcomponent ( parseDistributedEnum(null) );

            /* Go on to next parse... */
        continue;
      }
      catch ( ParseException  theParseException )
      {
                /* Lets be a little bit more verbose here,        *
		 * so as not to confuse the end-users too much... */
          System.err.println ( TDLParser.getFilenameWithoutPathPlusColon()
                               + ( getToken ( 0 ) . beginLine + 1 )
                               + ":  Parse Error:  "
                               + "DISTRIBUTED struct/enum/typedef "
                               + "has unsupported declaration types." );
          throw theParseException;
      }
    }




        /* Otherwise snarf the token. */
    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . addSubcomponent ( getToken ( 1 ) . image );

            /* Go on to the next token... */
    getNextToken();

  } /* WHILE ( getToken(1) != EOF (or CLOSE_BRACE if stack empty) ) */



  if ( getToken ( 1 ) . kind == CLOSE_BRACE )
  {
    parseFluff ( thisDataExternH, getToken ( 1 ), 0 );
    thisDataExternH . setIndex ( DataExternH.CLOSE_BRACE );

    getNextToken();
  }
  else
  {
    throw generateParseException ( token,
                                   getToken ( 1 ),
                                     "Premature end of file.  "
                                   + "Expected: '}' at end of "
                                   + "'EXTERN \u005c"H\u005c" {' clause.\u005cn" );
  }

  return thisDataExternH;
  }

/*******************************************/
/*** DISTRIBUTED typedef / struct / enum ***/
/*******************************************/
  static final public DataDistributedTypedef parseDistributedTypedef() throws ParseException {
  DataDistributedTypedef        thisTypedef = new DataDistributedTypedef();
  DataDistributedDeclarationSet thisDataDistributedDeclarationSet;
  Token                         token;
    token = jj_consume_token(DISTRIBUTED);
        parseFluff ( thisTypedef, token, 0 );
        thisTypedef . setIndex( DataDistributedTypedef.DISTRIBUTED );
    token = jj_consume_token(TYPEDEF);
        parseFluff ( thisTypedef, token, 0 );
        thisTypedef . setIndex( DataDistributedTypedef.TYPEDEF );
    /* DataTaskArguments, via DataDistributedDeclarationSet,       *
    	 * while not being designed for this purpose, are nevertheless *
    	 * ideally suited toward it.                                   */
        thisDataDistributedDeclarationSet = parseDistributedDeclarationSet(null);
        thisTypedef . setIndex ( DataDistributedTypedef.DECLARATION );
        thisTypedef
         . setDataDistributedDeclarationSet(thisDataDistributedDeclarationSet);
      {if (true) return thisTypedef;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedStruct parseDistributedStruct(DataDistributedStruct theDataDistributedStruct) throws ParseException {
  DataDistributedStruct         thisStruct
                                  = (   ( theDataDistributedStruct != null )
                                      ?   theDataDistributedStruct
                                      :  new DataDistributedStruct() );

  Token                         token;
    token = jj_consume_token(DISTRIBUTED);
        parseFluff ( thisStruct, token, 0 );
        thisStruct . setIndex( DataDistributedStruct.DISTRIBUTED );
    parseDistributedStructInternal(thisStruct);
    token = jj_consume_token(SEMICOLON);
        parseFluff ( thisStruct, token, 0 );
        thisStruct . setIndex( DataDistributedStruct.SEMICOLON );
      {if (true) return thisStruct;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedStruct parseDistributedStructInternal(DataDistributedStruct theDataDistributedStruct) throws ParseException {
  DataDistributedStruct         thisStruct
                                  = (   ( theDataDistributedStruct != null )
                                      ?   theDataDistributedStruct
                                      :  new DataDistributedStruct() );

  DataDistributedDeclarationSet dataDistributedDeclarationSet;
  int                           declarationCount = 0;
  Token                         token;
    token = jj_consume_token(STRUCT);
        parseFluff ( thisStruct, token, 0 );
        thisStruct . setIndex( DataDistributedStruct.STRUCT );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      token = parseIdToken();
          parseFluff ( thisStruct, token, 0 );
          thisStruct . setStructName ( token.image );
          thisStruct . setIndex ( DataDistributedStruct.NAME_INDEX );
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    token = jj_consume_token(OPEN_BRACE);
        parseFluff ( thisStruct, token, 0 );
        thisStruct . setIndex ( DataDistributedStruct.OPEN_BRACE );
    label_2:
    while (true) {
      /* DataTaskArguments, via DataDistributedDeclarationSet,       *
      	 * while not being designed for this purpose, are nevertheless *
      	 * ideally suited toward it.                                   */
            dataDistributedDeclarationSet = parseDistributedDeclarationSet(null);
          thisStruct . setIndex ( DataDistributedStruct.DECLARATION
                                  + (declarationCount ++) );
          thisStruct . addDataDistributedDeclarationSet (
                                  dataDistributedDeclarationSet );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case IN:
      case OUT:
      case INOUT:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
    }
    token = jj_consume_token(CLOSE_BRACE);
        parseFluff ( thisStruct, token, 0 );
        thisStruct . setIndex( DataDistributedStruct.CLOSE_BRACE );
      {if (true) return thisStruct;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedEnumEntry parseDataDistributedEnumEntry(DataDistributedEnumEntry theDataDistributedEnumEntry) throws ParseException {
  DataDistributedEnumEntry  thisEnumEntry
                              = (   ( theDataDistributedEnumEntry != null )
                                  ?   theDataDistributedEnumEntry
                                  :  new DataDistributedEnumEntry() );

  Token                     token, equalsToken;
  DataExpression            dataExpression;
    token = parseIdToken();
        parseFluff ( thisEnumEntry, token, 0 );
        thisEnumEntry . setId ( token.image );
        thisEnumEntry . setIndex ( DataDistributedEnumEntry.ID );
    if (jj_2_1(2147483647)) {
      equalsToken = jj_consume_token(EQUAL);
          parseFluff ( thisEnumEntry, equalsToken, 0 );
          thisEnumEntry . setIndex ( DataDistributedEnumEntry.EQUALS );
      parseConstantExpression();
                /* If this was a single <INTEGER_CONSTANT> */
          if (   ( equalsToken    . next == getToken ( 0 )   )
              && ( getToken ( 0 ) . kind == INTEGER_CONSTANT ) )
          {
            parseFluff ( thisEnumEntry, getToken(0), 0 );
            thisEnumEntry . setIndex ( DataDistributedEnumEntry.EQUALS_VALUE );
            thisEnumEntry . setPositiveIntegerEqualsString (getToken(0).image);
          }
          else
          {
            dataExpression = new DataExpression();
            parseMiscTokens ( dataExpression, equalsToken, 0 );

            thisEnumEntry . setIndex( DataDistributedEnumEntry.EQUALS_VALUE);
            thisEnumEntry . setGeneralEqualsExpression ( dataExpression );
          }
    } else {
      ;
    }
      {if (true) return thisEnumEntry;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedEnum parseDistributedEnum(DataDistributedEnum theDataDistributedEnum) throws ParseException {
  DataDistributedEnum  thisEnum = (   ( theDataDistributedEnum != null )
                                    ?   theDataDistributedEnum
                                    :  new DataDistributedEnum() );

  DataDistributedEnumEntry     dataDistributedEnumEntry;
  int                          enumEntryCount = 0;
  Token                        token;
    token = jj_consume_token(DISTRIBUTED);
        parseFluff ( thisEnum, token, 0 );
        thisEnum . setIndex( DataDistributedEnum.DISTRIBUTED );
    parseDistributedEnumInternal(thisEnum);
    token = jj_consume_token(SEMICOLON);
        parseFluff ( thisEnum, token, 0 );
        thisEnum . setIndex ( DataDistributedEnum.SEMICOLON );
      {if (true) return thisEnum;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedEnum parseDistributedEnumInternal(DataDistributedEnum theDataDistributedEnum) throws ParseException {
  DataDistributedEnum  thisEnum = (   ( theDataDistributedEnum != null )
                                    ?   theDataDistributedEnum
                                    :  new DataDistributedEnum() );

  DataDistributedEnumEntry     dataDistributedEnumEntry;
  int                          enumEntryCount = 0;
  Token                        token;
    token = jj_consume_token(ENUM);
        parseFluff ( thisEnum, token, 0 );
        thisEnum . setIndex( DataDistributedEnum.ENUM );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      token = parseIdToken();
          parseFluff ( thisEnum, token, 0 );
          thisEnum . setEnumName ( token.image );
          thisEnum . setIndex ( DataDistributedEnum.NAME_INDEX );
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    token = jj_consume_token(OPEN_BRACE);
        parseFluff ( thisEnum, token, 0 );
        thisEnum . setIndex ( DataDistributedEnum.OPEN_BRACE );
    dataDistributedEnumEntry = parseDataDistributedEnumEntry(null);
        thisEnum . setIndex ( DataDistributedEnum.ENUM_ENTRY
                              + (enumEntryCount ++) );
        thisEnum . addDataDistributedEnumEntry ( dataDistributedEnumEntry );
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      token = jj_consume_token(COMMA);
          parseFluff ( thisEnum, token, 0 );
          thisEnum . setIndex ( DataDistributedEnum.COMMA + enumEntryCount );
      dataDistributedEnumEntry = parseDataDistributedEnumEntry(null);
          thisEnum . setIndex ( DataDistributedEnum.ENUM_ENTRY
                                + (enumEntryCount ++) );
          thisEnum . addDataDistributedEnumEntry ( dataDistributedEnumEntry );
    }
    token = jj_consume_token(CLOSE_BRACE);
        parseFluff ( thisEnum, token, 0 );
        thisEnum . setIndex ( DataDistributedEnum.CLOSE_BRACE );
      {if (true) return thisEnum;}
    throw new Error("Missing return statement in function");
  }

/******************************/
/*** Class/Struct/Namespace ***/
/******************************/
  static final public DataClassStructNamespace parseStartDataClassStructNamespace(DataClassStructNamespace  theDataClassStructNamespace) throws ParseException {
  Token                    token = getToken(0);
  DataClassStructNamespace thisDataClassStructNamespace
                                  = (   ( theDataClassStructNamespace != null )
                                      ?   theDataClassStructNamespace
                                      :  new DataClassStructNamespace() );
  thisDataClassStructNamespace . setIsStart();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
      break;
    case STRUCT:
      jj_consume_token(STRUCT);
      break;
    case NAMESPACE:
      jj_consume_token(NAMESPACE);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    parseIdToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      parseBaseSpec();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(OPEN_BRACE);
      parseMiscTokens ( thisDataClassStructNamespace, token, 0 );
      {if (true) return thisDataClassStructNamespace;}
    throw new Error("Missing return statement in function");
  }

  static final public DataClassStructNamespace parseEndDataClassStructNamespace(DataClassStructNamespace theDataClassStructNamespace,
                       String                   theCorrespondingStart) throws ParseException {
  Token token;
  DataClassStructNamespace thisDataClassStructNamespace
                                  = (   ( theDataClassStructNamespace != null )
                                      ?   theDataClassStructNamespace
                                      :  new DataClassStructNamespace() );
  thisDataClassStructNamespace . setIsEnd();
  thisDataClassStructNamespace
    . setCorrespondingStartString ( theCorrespondingStart );
    token = jj_consume_token(CLOSE_BRACE);
         parseFluff ( thisDataClassStructNamespace, token, 0 );
         thisDataClassStructNamespace . addSubcomponent ( token.image );
    token = jj_consume_token(SEMICOLON);
         parseFluff ( thisDataClassStructNamespace, token, 0 );
         thisDataClassStructNamespace . addSubcomponent ( token.image );
      {if (true) return thisDataClassStructNamespace;}
    throw new Error("Missing return statement in function");
  }

/***********************/
/*** Task Definition ***/
/***********************/
  static final public DataTaskDefinition parseFullTaskDefinition(DataTaskDefinition theDataTaskDefinition,
                          boolean            theInsideClassStruct) throws ParseException {
  DataTaskDefinition     returnValue;
  DataCompoundStatement  dataCompoundStatement;
  DataTaskDefinition     thisTask = (   ( theDataTaskDefinition != null )
                                      ?   theDataTaskDefinition
                                      :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTERN_CS:
    case EXTERN_CI:
      returnValue = parseExternTaskDefinition(thisTask, theInsideClassStruct);
      break;
    case STATIC_CS:
    case VIRTUAL_CS:
    case STATIC_CI:
    case VIRTUAL_CI:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case PERSISTENT:
    case DISTRIBUTED:
    case THREADED:
      if (jj_2_2(6)) {
        returnValue = parseActualTaskDefinition_Rest(thisTask,
                                                             theInsideClassStruct);
                setParsingTask ( returnValue );
        dataCompoundStatement = parseCompoundStatement(0);
                clearParsingTask();
                returnValue . setTaskBody ( dataCompoundStatement );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC_CS:
        case STATIC_CI:
        case EXCEPTION:
        case DISTRIBUTED:
          returnValue = parseActualTaskDefinition_Exception(thisTask,
                                                                  theInsideClassStruct);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionHead(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  DataTaskDefinition  returnValue;
  DataTaskDefinition  thisTask = (   ( theDataTaskDefinition != null )
                                   ?   theDataTaskDefinition
                                   :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTERN_CS:
    case EXTERN_CI:
      returnValue = parseExternTaskDefinition(thisTask, false);
      break;
    case STATIC_CS:
    case VIRTUAL_CS:
    case STATIC_CI:
    case VIRTUAL_CI:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case PERSISTENT:
    case DISTRIBUTED:
    case THREADED:
      if (jj_2_3(6)) {
        /* Deal with: "<EXCEPTION> <HANDLER>"     and       *
        			 * [<distributed>] [<persistent>] [<threaded>] GOAL */
        
                  returnValue = parseActualTaskDefinition_Rest(thisTask, false);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC_CS:
        case STATIC_CI:
        case EXCEPTION:
        case DISTRIBUTED:
          returnValue = parseActualTaskDefinition_Exception(thisTask, false);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseExternTaskDefinition(DataTaskDefinition theDataTaskDefinition,
                            boolean            theInsideClassStruct) throws ParseException {
  Token               token;
  DataTaskDefinition  thisTask = (   ( theDataTaskDefinition != null )
                                   ?   theDataTaskDefinition
                                   :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTERN_CS:
      token = jj_consume_token(EXTERN_CS);
      break;
    case EXTERN_CI:
      token = jj_consume_token(EXTERN_CI);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          if ( thisTask . addExternKeywordToTaskLeadsOrder() == false )
          {
            {if (true) throw generateParseException ( token,
                                "Task may NOT have more than one "
                                + "\u005c"EXTERN\u005c" keyword." );}
          }
          parseFluff ( thisTask, token, 0 );
          thisTask . setIndex ( DataTaskDefinition.EXTERN );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
      parseTaskDefinitionInternal_Task(thisTask, theInsideClassStruct);
      break;
    case GOAL:
      parseTaskDefinitionInternal_Goal(thisTask, theInsideClassStruct);
      break;
    case COMMAND:
      parseTaskDefinitionInternal_Command(thisTask, theInsideClassStruct);
      break;
    case MONITOR:
      parseTaskDefinitionInternal_Monitor(thisTask, theInsideClassStruct);
      break;
    case RESUME:
      parseTaskDefinitionInternal_Resume(thisTask, theInsideClassStruct);
      break;
    case EXCEPTION:
    case HANDLER:
      if (jj_2_4(2)) {
        parseTaskDefinitionInternal_Handler(thisTask,
                                                            theInsideClassStruct);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXCEPTION:
          parseTaskDefinitionInternal_Exception(thisTask,
                                                              theInsideClassStruct);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    token = jj_consume_token(SEMICOLON);
        parseFluff ( thisTask, token, 0 );
        thisTask . setIndex ( DataTaskDefinition.SEMICOLON );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseActualTaskDefinition_Exception(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
  DataSpawnTask      exceptionBaseTask;
  Token              token;
  DataConstraint     formatDataConstraint;

  thisTask . setIsExtern ( false );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC_CS:
    case STATIC_CI:
      parseTaskDefinitionInternal_TaskLeads_Static(thisTask,
                                                               theInsideClassStruct);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTRIBUTED:
      parseTaskDefinitionInternal_DistributedException(thisTask,
                                                               theInsideClassStruct);
      break;
    case EXCEPTION:
      parseTaskDefinitionInternal_Exception(thisTask,
                                                       theInsideClassStruct);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_5(2147483647)) {
      token = jj_consume_token(COLON);
              parseFluff ( thisTask, token, 0 );
              thisTask . setIndex ( DataTaskDefinition.COLON );
      exceptionBaseTask = parseSpawnTask_ScopedTaskOnly(null, 0);
              thisTask . setExceptionBaseTask ( exceptionBaseTask );
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORMAT:
    case WITH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITH:
        parseTaskDefinitionWith(thisTask);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      formatDataConstraint = parseFormatConstraint(null, 0);
              thisTask . addConstraint ( formatDataConstraint );
              if ( getToken ( 1 ) . kind != SEMICOLON )
              {
                {if (true) throw generateParseException ( getToken(1),
                    "Next token should have been a SEMICOLON.  "
                  + "Instead found \u005c"" + getToken(1).image + "\u005c"." );}
              }
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    /* Exceptions must be followed by a semicolon. */
            token = jj_consume_token(SEMICOLON);
            parseFluff ( thisTask, token, 0 );
            thisTask . setIndex ( DataTaskDefinition.SEMICOLON );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseActualTaskDefinition_Rest(DataTaskDefinition theDataTaskDefinition,
                                 boolean            theInsideClassStruct) throws ParseException {
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
  DataConstraint     dataConstraint;
  DataSpawnTask      exceptionBaseTask;
  Token              token;

  thisTask . setIsExtern ( false );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
      parseTaskDefinitionInternal_Task(thisTask, theInsideClassStruct);
      break;
    case STATIC_CS:
    case VIRTUAL_CS:
    case STATIC_CI:
    case VIRTUAL_CI:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case PERSISTENT:
    case DISTRIBUTED:
    case THREADED:
      if (jj_2_6(6)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC_CS:
        case VIRTUAL_CS:
        case STATIC_CI:
        case VIRTUAL_CI:
        case PERSISTENT:
        case DISTRIBUTED:
        case THREADED:
          parseTaskDefinitionInternal_TaskLeads_All(thisTask,
                                                                   theInsideClassStruct);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GOAL:
        case COMMAND:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GOAL:
            parseTaskDefinitionInternal_Goal(thisTask,
                                                                      theInsideClassStruct);
            break;
          case COMMAND:
            parseTaskDefinitionInternal_Command(thisTask,
                                                                      theInsideClassStruct);
            break;
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EXCEPTION:
          case HANDLER:
          case EXPAND:
          case DELAY:
          case ON:
          case PERSISTENT:
          case FORMAT:
          case EXPAND_FIRST:
          case DELAY_EXPANSION:
          case ON_TERMINATE:
          case WITH:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WITH:
              parseTaskDefinitionWith(thisTask);
              break;
            default:
              jj_la1[22] = jj_gen;
              ;
            }
            parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
            label_4:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[23] = jj_gen;
                break label_4;
              }
              jj_consume_token(COMMA);
              parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
            }
            break;
          default:
            jj_la1[24] = jj_gen;
            ;
          }
          break;
        case MONITOR:
          parseTaskDefinitionInternal_Monitor(thisTask,
                                                                 theInsideClassStruct);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EXCEPTION:
          case HANDLER:
          case EXPAND:
          case DELAY:
          case SEQUENTIAL:
          case SERIAL:
          case MAXIMUM:
          case MONITOR_PERIOD:
          case ON:
          case PERSISTENT:
          case FORMAT:
          case EXPAND_FIRST:
          case DELAY_EXPANSION:
          case SEQUENTIAL_HANDLING:
          case SEQUENTIAL_EXPANSION:
          case SEQUENTIAL_EXECUTION:
          case SEQUENTIAL_PLANNING:
          case SEQUENTIAL_ACHIEVEMENT:
          case MAXIMUM_ACTIVATE:
          case MAXIMUM_TRIGGER:
          case ON_TERMINATE:
          case WITH:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WITH:
              parseTaskDefinitionWith(thisTask);
              break;
            default:
              jj_la1[25] = jj_gen;
              ;
            }
            parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
            label_5:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[26] = jj_gen;
                break label_5;
              }
              jj_consume_token(COMMA);
              parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
            }
            break;
          default:
            jj_la1[27] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC_CS:
        case VIRTUAL_CS:
        case STATIC_CI:
        case VIRTUAL_CI:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STATIC_CS:
          case VIRTUAL_CS:
          case STATIC_CI:
          case VIRTUAL_CI:
            parseTaskDefinitionInternal_TaskLeads_Static_Virtual_All(thisTask,
                                                                     theInsideClassStruct);
            break;
          default:
            jj_la1[29] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EXCEPTION:
          case HANDLER:
            parseTaskDefinitionInternal_Handler(thisTask,
                                                                 theInsideClassStruct);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WITH:
              parseTaskDefinitionWith(thisTask);
              break;
            default:
              jj_la1[30] = jj_gen;
              ;
            }
            label_6:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case MAXIMUM:
              case PERSISTENT:
              case FORMAT:
              case MAXIMUM_ACTIVATE:
                ;
                break;
              default:
                jj_la1[31] = jj_gen;
                break label_6;
              }
              parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
              jj_consume_token(COMMA);
            }
            /* Require exception handler "handles" clause */
                           token = jj_consume_token(HANDLES);
                   parseFluff ( thisTask, token, 0 );
                   thisTask . setIndex ( DataTaskDefinition.HANDLES );
            token = parseIdToken();
                   parseFluff ( thisTask, token, 0 );
                   thisTask . setIndex ( DataTaskDefinition.HANDLES_INDEX );
                   thisTask . setHandlesException ( token.image );
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              /* Allow optional constraints here */
                               token = jj_consume_token(COMMA);
                     parseFluff ( thisTask, token, 0 );
                     thisTask
                     . setIndex ( DataTaskDefinition.HANDLES_COMMA_INDEX );
              parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
              label_7:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case COMMA:
                  ;
                  break;
                default:
                  jj_la1[32] = jj_gen;
                  break label_7;
                }
                jj_consume_token(COMMA);
                parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff(thisTask);
              }
              break;
            default:
              jj_la1[33] = jj_gen;
              ;
            }
            break;
          case RESUME:
            parseTaskDefinitionInternal_Resume(thisTask,
                                                                theInsideClassStruct);
            break;
          default:
            jj_la1[34] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        /* TASK_BODY_INDEX doesn't really do much anymore.               *
	 * Its functionality has been superseded by HANDLES_COMMA_INDEX. */
      thisTask . setIndex ( DataTaskDefinition.TASK_BODY_INDEX );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionInternal_TaskLeads_Static(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC_CS:
      token = jj_consume_token(STATIC_CS);
                                taskIndex = DataTaskDefinition.STATIC;
      break;
    case STATIC_CI:
      token = jj_consume_token(STATIC_CI);
                                taskIndex = DataTaskDefinition.STATIC;
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if ( theInsideClassStruct == false )
          {if (true) throw generateParseException ( token,
                      "Task may only be STATIC inside a class or struct." );}

        if ( thisTask . getIsVirtual() )
          {if (true) throw generateParseException ( token,
                                  "Task may NOT be both VIRTUAL and STATIC." );}

        if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
          {if (true) throw generateParseException ( token,
                                         "Task may NOT have more than one "
                                         + "\u005c"" + token.image + "\u005c" keyword.");}

        parseFluff ( thisTask, token, 0 );
        thisTask . setIndex ( taskIndex );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionInternal_TaskLeads_Virtual(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VIRTUAL_CS:
      token = jj_consume_token(VIRTUAL_CS);
                                taskIndex = DataTaskDefinition.VIRTUAL;
      break;
    case VIRTUAL_CI:
      token = jj_consume_token(VIRTUAL_CI);
                                taskIndex = DataTaskDefinition.VIRTUAL;
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if ( theInsideClassStruct == false )
          {if (true) throw generateParseException ( token,
                      "Task may only be VIRTUAL inside a class or struct." );}

        if ( thisTask . getIsStatic() )
          {if (true) throw generateParseException ( token,
                                  "Task may NOT be both STATIC and VIRTUAL." );}

        if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
          {if (true) throw generateParseException ( token,
                                         "Task may NOT have more than one "
                                         + "\u005c"" + token.image + "\u005c" keyword.");}

        parseFluff ( thisTask, token, 0 );
        thisTask . setIndex ( taskIndex );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionInternal_TaskLeads_Distributed_Persistent_Threaded(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  String             taskIndex;
  Token              token;
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTRIBUTED:
      token = jj_consume_token(DISTRIBUTED);
                                taskIndex = DataTaskDefinition.DISTRIBUTED;
      break;
    case PERSISTENT:
      token = jj_consume_token(PERSISTENT);
                                taskIndex = DataTaskDefinition.PERSISTENT;
      break;
    case THREADED:
      token = jj_consume_token(THREADED);
                                taskIndex = DataTaskDefinition.THREADED;
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if ( thisTask . addToTaskLeadsKeywordOrder(taskIndex) == false )
          {if (true) throw generateParseException ( token,
                                         "Task may NOT have more than one "
                                         + "\u005c"" + token.image + "\u005c" keyword.");}

        parseFluff ( thisTask, token, 0 );
        thisTask . setIndex ( taskIndex );
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionInternal_TaskLeads_Static_Virtual_All(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC_CS:
      case STATIC_CI:
        parseTaskDefinitionInternal_TaskLeads_Static(theDataTaskDefinition,
                                                                theInsideClassStruct);
        break;
      case VIRTUAL_CS:
      case VIRTUAL_CI:
        parseTaskDefinitionInternal_TaskLeads_Virtual(theDataTaskDefinition,
                                                                theInsideClassStruct);
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC_CS:
      case VIRTUAL_CS:
      case STATIC_CI:
      case VIRTUAL_CI:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_8;
      }
    }
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskDefinition parseTaskDefinitionInternal_TaskLeads_All(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  DataTaskDefinition thisTask = (   ( theDataTaskDefinition != null )
                                  ?   theDataTaskDefinition
                                  :  new DataTaskDefinition() );
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC_CS:
      case STATIC_CI:
        parseTaskDefinitionInternal_TaskLeads_Static(theDataTaskDefinition,
                                                                theInsideClassStruct);
        break;
      case VIRTUAL_CS:
      case VIRTUAL_CI:
        parseTaskDefinitionInternal_TaskLeads_Virtual(theDataTaskDefinition,
                                                                theInsideClassStruct);
        break;
      case PERSISTENT:
      case DISTRIBUTED:
      case THREADED:
        parseTaskDefinitionInternal_TaskLeads_Distributed_Persistent_Threaded(theDataTaskDefinition);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC_CS:
      case VIRTUAL_CS:
      case STATIC_CI:
      case VIRTUAL_CI:
      case PERSISTENT:
      case DISTRIBUTED:
      case THREADED:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_9;
      }
    }
      {if (true) return thisTask;}
    throw new Error("Missing return statement in function");
  }

  static final public void parseTaskDefinitionInternal_Task(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(TASK);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.TASK_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Goal(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(GOAL);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.GOAL_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Command(DataTaskDefinition theDataTaskDefinition,
                                    boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(COMMAND);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.COMMAND_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Monitor(DataTaskDefinition theDataTaskDefinition,
                                    boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(MONITOR);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.MONITOR_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Exception(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(EXCEPTION);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.EXCEPTION_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_DistributedException(DataTaskDefinition theDataTaskDefinition,
                                   boolean            theInsideClassStruct) throws ParseException {
    token = jj_consume_token(DISTRIBUTED);
         parseFluff ( theDataTaskDefinition, token, 0 );
         if ( !theDataTaskDefinition . addToTaskLeadsKeywordOrder(
                                             DataTaskDefinition.DISTRIBUTED ) )
           {if (true) throw generateParseException ( token,
                                          "Task may NOT have more than one "
                                          + "\u005c"DISTRIBUTED\u005c" keyword.");}
         theDataTaskDefinition . setIndex( DataTaskDefinition.DISTRIBUTED );
    parseTaskDefinitionInternal_Exception(theDataTaskDefinition,
                                                theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Handler(DataTaskDefinition theDataTaskDefinition,
                                    boolean            theInsideClassStruct) throws ParseException {
  Token  token;
  Token  token2 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
      token2 = jj_consume_token(EXCEPTION);
      token = jj_consume_token(HANDLER);
      break;
    case HANDLER:
      token = jj_consume_token(HANDLER);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.HANDLER_TASK,
                                            token, token2, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternal_Resume(DataTaskDefinition theDataTaskDefinition,
                                    boolean            theInsideClassStruct) throws ParseException {
  Token  token;
    token = jj_consume_token(RESUME);
    parseTaskDefinitionInternals_Rest(theDataTaskDefinition,
                                            DataTaskDefinition.RESUME_TASK,
                                            token, null, theInsideClassStruct);

  }

  static final public void parseTaskDefinitionInternals_Rest(DataTaskDefinition theDataTaskDefinition,
                                    int                theTaskType,
                                    Token              token,
                                    Token              token2,
                                    boolean            theInsideClassStruct) throws ParseException {
  DataTaskArgument  tmpDataTaskArgument = null;

        /************************************/
        /* Handle Parsing of token / token2 */
        /************************************/

  theDataTaskDefinition . setTaskType ( theTaskType );

                /* Only parse "Task" Tasks when we are external... */
  if (    ( token.kind == TASK )
       && ( theDataTaskDefinition . getIsExtern() == false ) )
  {
    throw generateParseException ( token,
                                     "Can only use Task-Type of "
                                   + "\u005c"Task\u005c" with extern tasks." );
  }
  if ( token2 != null )
  {
    parseFluff ( theDataTaskDefinition, token2, 0 );
    theDataTaskDefinition . setIndex ( DataTaskDefinition.TASK_TYPE_INDEX
                                       + "0" );
  }
  parseFluff ( theDataTaskDefinition, token, 0 );
  theDataTaskDefinition . setIndex( DataTaskDefinition.TASK_TYPE_INDEX );
    token = parseTaskScopeAndName(theDataTaskDefinition,
                                        theInsideClassStruct);
        parseFluff ( theDataTaskDefinition, token, 0 );
        theDataTaskDefinition
          . setTaskNameWithoutParsingOrRegistration ( token.image );
        theDataTaskDefinition . setIndex( DataTaskDefinition.TASK_NAME_INDEX );
        theDataTaskDefinition . setLineNumber ( token.beginLine + 1 );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( theDataTaskDefinition, token, 0 );
        theDataTaskDefinition . setIndex ( DataTaskDefinition.OPEN_PAREN );
    if (jj_2_7(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        token = jj_consume_token(VOID);
                parseFluff ( theDataTaskDefinition, token, 0 );
                theDataTaskDefinition . addSubcomponent ( token.image );
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      token = jj_consume_token(CLOSE_PAREN);
              parseFluff ( theDataTaskDefinition, token, 0 );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case IN:
      case OUT:
      case INOUT:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        tmpDataTaskArgument = parseTaskArgument(null);
              theDataTaskDefinition . addTaskArgument ( tmpDataTaskArgument );
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[46] = jj_gen;
            break label_10;
          }
          jj_consume_token(COMMA);
          /* parseTaskArgument() dealt with this token's fluff */
          
                      tmpDataTaskArgument = parseTaskArgument(null);
                theDataTaskDefinition . addTaskArgument( tmpDataTaskArgument );
        }
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        theDataTaskDefinition . setIndex ( DataTaskDefinition.CLOSE_PAREN );

  }

        /* Parses the scoping, return the Identifier Token untouched. */
  static final public Token parseScopedIdentifier(DataScope theDataScope) throws ParseException {
  Token         identifierToken, scopeToken;
  int           scopeCount = 0;

  if ( theDataScope == null )
  {
    throw generateParseException (
       getToken(1),
       "Internal Programmer Error:  parseScopedIdentifier() invoked with NULL "
       + "value for theDataScope." );
  }

  theDataScope . clearAllScopes();
    identifierToken = parseIdToken();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_11;
      }
      scopeToken = jj_consume_token(SCOPE);
          parseFluff ( theDataScope, identifierToken, 0 );
          theDataScope . addScope  ( identifierToken.image );
          theDataScope . setIndex  ( DataScope.IDENTIFIER_INDEX + scopeCount );

          parseFluff ( theDataScope, scopeToken, 0 );
          theDataScope . setIndex  ( DataScope.SCOPE + scopeCount );

          scopeCount ++;
      identifierToken = parseIdToken();
    }
      {if (true) return identifierToken;}
    throw new Error("Missing return statement in function");
  }

  static final public Token parseTaskScopeAndName(DataTaskDefinition theDataTaskDefinition,
                        boolean            theInsideClassStruct) throws ParseException {
  Token               taskNameToken;
  DataTaskDefinition  previouslyRegisteredTask;
  DataScope           dataScope = ( ( theDataTaskDefinition != null )
                                   ?  theDataTaskDefinition . getTaskScope()
                                   :  new DataScope() );
    taskNameToken = parseScopedIdentifier(dataScope);
        /* Note:  We now permit multiple tasks to be registered under the
	 * same name.  However:  Overloading of exception tasks is prohibited.
	 * The types must match.  And the Distributed/Non-Distributed
	 * nature must match.
	 *
	 * Caveat:  This functionality occurs in two places.  Here and in
	 * DataTaskDefinition.registerTask(DataTaskDefinition).  The code
	 * here is only invoked after the tasks are registered, which currently
	 * only occurs after the entire file is read and parsed...  It is still
	 * useful in the event one is parsing multiple files, and registering
	 * tasks inbetween them.  But, by and large, this code is
	 * NEVER ACTUALLY UTILIZED.
	 */

      previouslyRegisteredTask
        = DataTaskDefinition.getFirstTaskForName (
            dataScope . getAllScopeStrings() + taskNameToken . image );

      if ( theDataTaskDefinition != null )
      {
        if ( previouslyRegisteredTask != null )
        {
                /* Check for overloaded exception tasks */
          if (   (    previouslyRegisteredTask . getTaskType()
                   == DataTaskDefinition.EXCEPTION_TASK        )
              || (    theDataTaskDefinition    . getTaskType()
                   == DataTaskDefinition.EXCEPTION_TASK        ) )
          {
            {if (true) throw generateParseException (
            taskNameToken,
              "TASK \u005c"" + taskNameToken . image + "\u005c" is both overloaded and "
            + "of type \u005c"Exception\u005c".  Overloading is not permitted for "
            + "\u005c"Exception\u005c" tasks.  "
            + "Please choose another name for this task." );}
          }

                /* Check for Task-Type disagreement */
          if (   previouslyRegisteredTask . getTaskType()
              != theDataTaskDefinition    . getTaskType() )
          {
            {if (true) throw generateParseException (
            taskNameToken,
              "TASK \u005c"" + taskNameToken . image + "\u005c" is of type \u005c""
            + theDataTaskDefinition . getTaskTypeString()
            + "\u005c".  Task \u005c"" + taskNameToken . image
            + "\u005c" is overloaded, and was previously declared (registered) "
            + "under type \u005c""
            + previouslyRegisteredTask . getTaskTypeString()
            + "\u005c".  These Task-Types are supposed to be the same, as one of "
            + "these Tasks will wind up being allocated with the other's "
            + "Task-Type, creating issues with constraint satisfaction.  "
            + "Please choose another name for this task, "
            + "or make both of them the same Task-Type." );}
          }

                /* Check for Distributed/Non-Distributed disagreement.
		 * (For now, assume theDataTaskDefinition will have already
		 *  had its DISTRIBUTED flag set/unset appropriately.)
		 */
          if (   previouslyRegisteredTask . getIsDistributed()
              != theDataTaskDefinition    . getIsDistributed() )
          {
            {if (true) throw generateParseException (
            taskNameToken,
              "TASK \u005c"" + taskNameToken . image + "\u005c" is \u005c""
            + (theDataTaskDefinition    . getIsDistributed() ? "" : "NON-")
            + "DISTRIBUTED\u005c".  Task \u005c"" + taskNameToken . image
            +"\u005c" is overloaded, and was previously declared (registered) as \u005c""
            + (previouslyRegisteredTask . getIsDistributed() ? "" : "NON-")
            + "DISTRIBUTED\u005c".  This DISTRIBUTED nature must be the "
            + "same between overloaded tasks, as one of these Tasks will wind "
            + "up being allocated with the other's DISTRIBUTED/NON-DISTRIBUTED"
            + " allocation function, with the associated problems.  "
            + "Please choose another name for this task, make both of them "
            + "\u005c"DISTRIBUTED\u005c", or make both of them \u005c"NON-DISTRIBUTED\u005c"." );}
          }
        } /* if ( previouslyRegisteredTask != null ) */



          /* Note: Place this here so the error message makes sense... */
        if ( theDataTaskDefinition . getTaskScope() . hasScope() )
        {
          if ( theInsideClassStruct )
          {
            {if (true) throw generateParseException (
              taskNameToken,
              "TASK \u005c"" + taskNameToken . image + "\u005c" is both scoped and "
              + "inside a class/struct.  This is not permitted."
              + "It may be scoped or inside a class/struct, but not both." );}
          }

          theDataTaskDefinition . setWasExplicitlyScoped();
        }

      } /* if ( theDataTaskDefinition != null ) */

      {if (true) return taskNameToken;}
    throw new Error("Missing return statement in function");
  }

  static final public void parseTaskDefinitionWith(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  Token  withToken;
    withToken = jj_consume_token(WITH);
        theDataTaskDefinition . setHasWithKeyword ( true );
        parseFluff ( theDataTaskDefinition, withToken, 0 );
        theDataTaskDefinition . setIndex ( theDataTaskDefinition.WITH );

  }

  static final public DataComponent parsePersistentTaskData(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  DataTaskArgument  dataTaskArgument = null;
  Token             token;
    token = jj_consume_token(PERSISTENT);
        dataTaskArgument = new DataTaskArgument();
        parseFluff ( dataTaskArgument, token, 0 );
        dataTaskArgument . setIndex ( DataTaskArgument.PERSISTENT );
        dataTaskArgument . setIsPersistentDeclaration ( true );
    parseTaskArgumentNoFormat(dataTaskArgument);
        theDataTaskDefinition
          . addPersistentTaskDeclaration ( dataTaskArgument );
      {if (true) return dataTaskArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseFormatConstraint(DataConstraint  theDataConstraint,
                        int             theUnIndent) throws ParseException {
  DataConstraint      thisConstraint = (   ( theDataConstraint != null )
                                         ?   theDataConstraint
                                         :   new DataConstraint() );
  Token               formatToken;
  DataExpression      formatStringDataExpression;

  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    formatToken = jj_consume_token(FORMAT);
        thisConstraint.setConstraintType ( DataConstraint.DISTRIBUTED_FORMAT );
        thisConstraint . setLineNumber ( formatToken.beginLine + 1 );
        parseFluff ( thisConstraint, formatToken, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
    /* This will handle strings with IDs in them too. */
    //da0g: Double-check #line number macros
        formatStringDataExpression = parseConstantExpressionObject(0);
        thisConstraint
         . setDistributedFormatStringExpression ( formatStringDataExpression );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
  static final public DataComponent parseSimpleConstraintOrPersistentOrFormatAndTrailingFluff(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERSISTENT:
      returnValue = parsePersistentTaskData(theDataTaskDefinition);
      break;
    case FORMAT:
      dataConstraint = parseFormatConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue           = dataConstraint;
          foundFormatConstraint = true;
      break;
    case EXCEPTION:
    case HANDLER:
    case EXPAND:
    case DELAY:
    case ON:
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
    case ON_TERMINATE:
      dataConstraint = parseSimpleConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue = dataConstraint;
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      if ( foundFormatConstraint == true )
        checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
        checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
                                   returnValue, getToken(1), 0, COMMA, COMMA );
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
  static final public DataComponent parseMonitorConstraintOrPersistentOrFormatAndTrailingFluff(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERSISTENT:
      returnValue = parsePersistentTaskData(theDataTaskDefinition);
      break;
    case FORMAT:
      dataConstraint = parseFormatConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue           = dataConstraint;
          foundFormatConstraint = true;
      break;
    case EXCEPTION:
    case HANDLER:
    case EXPAND:
    case DELAY:
    case SEQUENTIAL:
    case SERIAL:
    case MAXIMUM:
    case MONITOR_PERIOD:
    case ON:
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
    case SEQUENTIAL_HANDLING:
    case SEQUENTIAL_EXPANSION:
    case SEQUENTIAL_EXECUTION:
    case SEQUENTIAL_PLANNING:
    case SEQUENTIAL_ACHIEVEMENT:
    case MAXIMUM_ACTIVATE:
    case MAXIMUM_TRIGGER:
    case ON_TERMINATE:
      dataConstraint = parseMonitorConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue = dataConstraint;
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      if ( foundFormatConstraint == true )
        checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
        checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
                                   returnValue, getToken(1), 0, COMMA, COMMA );
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

    /* Note: Only parses trailing fluff if next subsequent token is a comma. */
  static final public DataComponent parseHandlerConstraintOrPersistentOrFormatAndTrailingFluff(DataTaskDefinition theDataTaskDefinition) throws ParseException {
  DataConstraint   dataConstraint        = null;
  DataComponent    returnValue           = null;
  boolean          foundFormatConstraint = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERSISTENT:
      returnValue = parsePersistentTaskData(theDataTaskDefinition);
      break;
    case FORMAT:
      dataConstraint = parseFormatConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue           = dataConstraint;
          foundFormatConstraint = true;
      break;
    case MAXIMUM:
    case MAXIMUM_ACTIVATE:
      dataConstraint = parseHandlerConstraint(null, 0);
          theDataTaskDefinition . addConstraint ( dataConstraint );
          returnValue = dataConstraint;
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      if ( foundFormatConstraint == true )
        checkForTrailingCommaOrOpenBraceOrStringOrMacroString ( getToken(1) );
      else
        checkForTrailingCommaOrOpenBrace ( getToken(1) );

      processTrailingFluffBeforeTheseTokenKindsOnly (
                                   returnValue, getToken(1), 0, COMMA, COMMA );
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

/**********************/
/*** Task Arguments ***/
/**********************/
  static final public DataTaskArgument parseTaskArgumentDeclarator(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token startToken = getToken(0);
  Token token;
    label_12:
    while (true) {
      if (jj_2_8(2147483647)) {
        ;
      } else {
        break label_12;
      }
      parsePtrOperator();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      token = parseArgumentNameToken();
            parseMiscTokensIgnoringLast ( thisArgument, startToken, 0 );
            parseFluff ( thisArgument, token, 0 );
            startToken = token;
            thisArgument . setArgumentNameWithoutParsingChecks ( token.image );
            thisArgument . setIndex ( DataTaskArgument.ARGUMENT_NAME_INDEX );
      break;
    case OPEN_PAREN:
      token = jj_consume_token(OPEN_PAREN);
              parseMiscTokens ( thisArgument, startToken, 0 );
              startToken = token;
      parseTaskArgumentDeclarator(thisArgument);
      token = jj_consume_token(CLOSE_PAREN);
              parseFluff ( thisArgument, token, 0 );
              thisArgument . addSubcomponent ( token.image );
              startToken = token;
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_13:
    while (true) {
      if (jj_2_9(2147483647)) {
        ;
      } else {
        break label_13;
      }
      parseDeclarator_Subpart();
    }
      parseMiscTokens ( thisArgument, startToken, 0 );
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgumentDeclaration(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token startToken;
  Token token;

        /* Erase any argument-equals-index... */
  thisArgument . removeIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX );
    parseTaskArgumentDeclarator(thisArgument);
        startToken = getToken(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      token = jj_consume_token(EQUAL);
            parseMiscTokens ( thisArgument, startToken, 0 );
            startToken = token;
                /* Set this to the subcomponent index OF the equals */
            thisArgument
              . setIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX,
                           thisArgument . getSubcomponentsCount() - 1 );
      parseAssignmentExpression();
          parseMiscTokens ( thisArgument, startToken, 0 );
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  /* Deals with parsing valid C++ code for the Task Argument. */
  static final public DataTaskArgument parseTaskArgument_WithoutArgDir_validCxxCode(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token startToken = getToken(0);
  Token token;
    parseDeclSpecifier();
        parseMiscTokens ( thisArgument, startToken, 0 );
    if (jj_2_10(2147483647)) {
      parseTaskArgumentDeclaration(thisArgument);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        parseTaskArgument_WithoutArgDir_validCxxCode(thisArgument);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgument_TrailingDistributedFormatString(DataTaskArgument theDataTaskArgument,
                                       int              theUnIndent) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token             token;
  DataExpression    constantDataExpression;
    token = jj_consume_token(FORMAT);
        parseFluff ( thisArgument, token, theUnIndent );
        thisArgument . setIndex ( DataTaskArgument.FORMAT );

          /* Attach any fluff to thisArgument, not to the constantExpression */
        processTrailingFluffBeforeTheseTokenKindsOnly( thisArgument,
                                                       getToken ( 1 ),
                                                       0,
                                                       getToken ( 1 ) . kind,
                                                       getToken ( 1 ) . kind );
        thisArgument . setIndex ( DataTaskArgument.FORMAT_EXPRESSION );
    //da0g: Double-check #line number macros
        constantDataExpression = parseConstantExpressionObject(0);
        thisArgument . setFormatExpression ( constantDataExpression );
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgument_WithoutArgDir(DataTaskArgument theDataTaskArgument,
                                  boolean          theSetLineNumber) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );

        /* Note:  Doing this here will insure that we set the line number
	 * to the first token of the task argument *AFTER* the optional
	 * IN/OUT/INOUT direction.
	 */
  if ( theSetLineNumber == true )
    thisArgument . setLineNumber ( getToken ( 1 ) . beginLine + 1 );
    if (jj_2_11(2147483647)) {
      parseDistributedTaskArgument(thisArgument);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        parseTaskArgument_WithoutArgDir_validCxxCode(thisArgument);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        /*   Task arguments that are separated by commas,
	 * or task-arguments that end in a ')', need to have
	 * their subseqent token's (the comma or close-paren)
	 * fluff attached to the task-argument.
	 *   An exception to this rule is made for PERSISTENT
	 * declarations that occur right before the task's body.
	 */
      processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisArgument, getToken(1), 0, COMMA, CLOSE_PAREN );

        /* Also snarf subsequent EOF token fluff.  (For debugging.) */
      processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisArgument, getToken(1), 0, EOF, EOF );

      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgumentNoFormat(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token             token;

  thisArgument . setArgumentDirection ( DataTaskArgument.DEFAULT_DIRECTION );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
    case OUT:
    case INOUT:
      token = parseArgumentDirection();
          parseFluff ( thisArgument, token, 0 );
          thisArgument . setArgumentDirectionString ( token.image );
          thisArgument . setIndex (
                               DataTaskArgument.ARGUMENT_DIRECTION_INDEX );
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    parseTaskArgument_WithoutArgDir(thisArgument, true);
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgument(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
    parseTaskArgumentNoFormat(thisArgument);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FORMAT:
      parseTaskArgument_TrailingDistributedFormatString(thisArgument , 0);
            /*   Task arguments that are separated by commas,
	     * or task-arguments that end in a ')', need to have
	     * their subseqent token's (the comma or close-paren)
	     * fluff attached to the task-argument.
	     *   An exception to this rule is made for PERSISTENT
	     * declarations that occur right before the task's body.
	     */
          processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisArgument, getToken(1), 0, COMMA, CLOSE_PAREN );

            /* Also snarf subsequent EOF token fluff.  (For debugging.) */
          processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisArgument, getToken(1), 0, EOF, EOF );
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgument_WithoutArgDir_AndTrailingEOF(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  dataTaskArgument;
    dataTaskArgument = parseTaskArgument_WithoutArgDir(theDataTaskArgument,
                                                             true);
    jj_consume_token(0);
      {if (true) return dataTaskArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseTaskArgument_AndTrailingEOF(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  dataTaskArgument;
    dataTaskArgument = parseTaskArgument(theDataTaskArgument);
    jj_consume_token(0);
      {if (true) return dataTaskArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public Token parseArgumentDirection() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      break;
    case OUT:
      jj_consume_token(OUT);
      break;
    case INOUT:
      jj_consume_token(INOUT);
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return getToken(0);}
    throw new Error("Missing return statement in function");
  }

  static final public Token parseArgumentNameToken() throws ParseException {
    parseIdToken();
                    {if (true) return getToken(0);}
    throw new Error("Missing return statement in function");
  }

  static final public String parseArgumentName() throws ParseException {
  Token token;
    token = parseArgumentNameToken();
      {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

/********************************/
/* Distributed Declaration Sets */
/********************************/
  static final public DataDistributedDeclarationSet parseDistributedDeclarationSet(DataDistributedDeclarationSet  theDataDistributedDeclarationSet) throws ParseException {
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
        ?   theDataDistributedDeclarationSet
        :   new DataDistributedDeclarationSet() );

  thisDeclarationSet . clear();
    if (jj_2_12(2147483647)) {
      parseDistributedDeclarationSet_Direct(thisDeclarationSet);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case IN:
      case OUT:
      case INOUT:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        parseDistributedDeclarationSet_WithFormat(thisDeclarationSet);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return thisDeclarationSet;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDistributedDeclarationSet parseDistributedDeclarationSet_WithFormat(DataDistributedDeclarationSet  theDataDistributedDeclarationSet) throws ParseException {
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
        ?   theDataDistributedDeclarationSet
        :   new DataDistributedDeclarationSet() );

  Token  token;
  int    declarationCount = 0;

  thisDeclarationSet . clear();

  if ( TDLParser.debugDistributedDeclarationSet )
    System.err.println( "parseDistributedDeclarationSet_WithFormat:  "
                        + getToken(1).image );
    parseTaskArgumentNoFormat(thisDeclarationSet . getFirstDeclarationCreatingIfNecessary());
    parseTaskArgument_TrailingDistributedFormatString(thisDeclarationSet . getLastExistingDeclaration(),
                                0);
          /* Store "fluff" as part of DataTaskArgument, *
	   * not DataDistributedDeclarationSet.         */
        processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisDeclarationSet . getLastExistingDeclaration(),
                            getToken(1), 0, COMMA, SEMICOLON );
        thisDeclarationSet
          . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
                       + (declarationCount ++) );
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_14;
      }
      token = jj_consume_token(COMMA);
      parseTaskArgumentDeclaration(thisDeclarationSet . createNextDeclaration());
      parseTaskArgument_TrailingDistributedFormatString(thisDeclarationSet . getLastExistingDeclaration(),
                                  0);
            /* Store "fluff" as part of DataTaskArgument, *
	     * not DataDistributedDeclarationSet.         */
          processTrailingFluffBeforeTheseTokenKindsOnly (
                            thisDeclarationSet . getLastExistingDeclaration(),
                            getToken(1), 0, COMMA, SEMICOLON );
          thisDeclarationSet
            . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
                         + (declarationCount ++) );
    }
    /* parseDistributedDeclarationSet()'s LOOKAHEAD only works properly
    	 * because this <SEMICOLON> token ends both of the two choices.
    	 * (Otherwise we'd get a premature partial "_Direct" match when we
    	 *  wanted a full "_WithFormat" match.)
    	 */
        token = jj_consume_token(SEMICOLON);
      {if (true) return thisDeclarationSet;}
    throw new Error("Missing return statement in function");
  }

  static final public void parseDistributedDeclarationSet_Direct_subpart(DataTaskArgument theDataTaskArgument) throws ParseException {
    if (jj_2_13(2147483647)) {
      parseDistributedDeclaration_SecondIdentifierPart(theDataTaskArgument);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FORMAT:
        parseTaskArgument_TrailingDistributedFormatString(theDataTaskArgument, 0);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case ID:
        parseTaskArgumentDeclaration(theDataTaskArgument);
        parseTaskArgument_TrailingDistributedFormatString(theDataTaskArgument, 0);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
           /* Store "fluff" as part of this DataTaskArgument */
        processTrailingFluffBeforeTheseTokenKindsOnly (
           theDataTaskArgument, getToken(1), 0, COMMA, SEMICOLON );
  }

  static final public DataDistributedDeclarationSet parseDistributedDeclarationSet_Direct(DataDistributedDeclarationSet  theDataDistributedDeclarationSet) throws ParseException {
  DataDistributedDeclarationSet  thisDeclarationSet
    = (   ( theDataDistributedDeclarationSet != null )
        ?   theDataDistributedDeclarationSet
        :   new DataDistributedDeclarationSet() );

  Token  token;
  int    declarationCount = 0;

  thisDeclarationSet . clear();

  if ( TDLParser.debugDistributedDeclarationSet )
    System.err.println( "parseDistributedDeclarationSet_Direct:  "
                        + getToken(1).image );
    parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations(thisDeclarationSet . getFirstDeclarationCreatingIfNecessary());
    parseDistributedDeclarationSet_Direct_subpart(thisDeclarationSet . getLastExistingDeclaration());
          thisDeclarationSet
            . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
                         + (declarationCount ++) );
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_15;
      }
      token = jj_consume_token(COMMA);
      parseDistributedDeclarationSet_Direct_subpart(thisDeclarationSet . createNextDeclaration());
            thisDeclarationSet
              . setIndex ( DataDistributedDeclarationSet.DECLARATION_INDEX
                           + (declarationCount ++) );
    }
    /* parseDistributedDeclarationSet()'s LOOKAHEAD only works properly
    	 * because this <SEMICOLON> token ends both of the two choices.
    	 * (Otherwise we'd get a premature partial "_Direct" match when we
    	 *  wanted a full "_WithFormat" match.)
    	 */
        token = jj_consume_token(SEMICOLON);
      {if (true) return thisDeclarationSet;}
    throw new Error("Missing return statement in function");
  }

/*********************************************************/
/* Distributed Task Arguments / Distributed Declarations */
/*********************************************************/

/*
 * Caveat:  parseDistributedTaskArgument intentionally does *NOT*
 * parse struct { ... } or enum { ... }.  These must be parsed elsewhere.
 *
 * parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations
 * does parse these.
 */
  static final public DataTaskArgument parseDistributedTaskArgument(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
    parseDistributedDeclaration_FirstTypePart(thisArgument);
    parseDistributedDeclaration_SecondIdentifierPart(thisArgument);
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseDistributedDeclaration_FirstTypePart(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
    parseDistributedDeclaration_internalLeadingConst(thisArgument);
    parseDistributedDeclaration_internalTypeItself(thisArgument);
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseDistributedDeclaration_FirstTypePart_IncludingStructEnumDeclarations(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
    parseDistributedDeclaration_internalLeadingConst(thisArgument);
    parseDistributedDeclaration_includingStructOrEnumDeclarations(thisArgument);
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseDistributedDeclaration_SecondIdentifierPart(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  Token             token;
    parseDistributedDeclaration_internalTrailingStuff(thisArgument);
    token = parseArgumentNameToken();
        parseFluff ( thisArgument, token, 0 );
        thisArgument . setArgumentNameWithoutParsingChecks ( token.image );
        thisArgument . setIndex ( DataTaskArgument.ARGUMENT_NAME_INDEX );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case OPEN_BRACKET:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        parseDistributedTaskArgument_Array(thisArgument);
        break;
      case EQUAL:
        parseDistributedTaskArgument_DefaultValue(thisArgument);
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public void parseDistributedDeclaration_internalLeadingConst(DataTaskArgument theThisArgument) throws ParseException {
  Token   startToken = getToken(0);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      jj_consume_token(CONST);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
      parseMiscTokens ( theThisArgument, startToken, 0 );
  }

  static final public void parseDistributedDeclaration_internalTypeItself(DataTaskArgument theThisArgument) throws ParseException {
  Token        token;
  Token        startToken    = getToken(0);
  boolean      intTypeSigned = true;
  StringBuffer stringBuffer = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIGNED:
      case UNSIGNED:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNSIGNED:
          jj_consume_token(UNSIGNED);
                  intTypeSigned = false;
          break;
        case SIGNED:
          jj_consume_token(SIGNED);
                  intTypeSigned = true;
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
          jj_consume_token(CONST);
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
        jj_consume_token(CHAR);
                  theThisArgument
                    . setDistributedType (   ( intTypeSigned == true )
                                           ? DataTaskArgument.INT1
                                           : DataTaskArgument.U_INT1 );
        break;
      case SHORT:
        jj_consume_token(SHORT);
        if (jj_2_14(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
            jj_consume_token(CONST);
            break;
          default:
            jj_la1[70] = jj_gen;
            ;
          }
          jj_consume_token(INT);
        } else {
          ;
        }
                  theThisArgument
                    . setDistributedType (   ( intTypeSigned == true )
                                           ? DataTaskArgument.INT2
                                           : DataTaskArgument.U_INT2 );
        break;
      case INT:
        jj_consume_token(INT);
                  theThisArgument
                    . setDistributedType (   ( intTypeSigned == true )
                                           ? DataTaskArgument.INT4
                                           : DataTaskArgument.U_INT4 );
        break;
      case LONG:
        jj_consume_token(LONG);
        if (jj_2_15(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
            jj_consume_token(CONST);
            break;
          default:
            jj_la1[71] = jj_gen;
            ;
          }
          jj_consume_token(INT);
        } else {
          ;
        }
                  theThisArgument
                    . setDistributedType (   ( intTypeSigned == true )
                                           ? DataTaskArgument.INT4
                                           : DataTaskArgument.U_INT4 );
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
          theThisArgument . setDistributedType ( DataTaskArgument.FLOAT   );
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
          theThisArgument . setDistributedType ( DataTaskArgument.DOUBLE  );
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      if (jj_2_17(2147483647)) {
        token = parseIdToken();
                  stringBuffer = new StringBuffer ( 100 /* Arbitrary */ );
                  stringBuffer . append ( token.image );
        label_16:
        while (true) {
          token = jj_consume_token(SCOPE);
                      stringBuffer . append ( token.image );
          token = parseIdToken();
                      stringBuffer . append ( token.image );
          if (jj_2_16(2147483647)) {
            ;
          } else {
            break label_16;
          }
        }
              theThisArgument
                . setDistributedType ( DataTaskArgument.IDENTIFIER );
              theThisArgument . setDistributedId   ( stringBuffer.toString() );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case ID:
          token = parseIdToken();
            if ( token.image . equals ( "BOOLEAN" ) )
              theThisArgument . setDistributedType( DataTaskArgument.BOOLEAN );

            else if ( token.image . equals ( "STRING" ) )
              theThisArgument . setDistributedType( DataTaskArgument.STRING  );


            else if ( token.image . equals ( "u_int1" ) )
              theThisArgument . setDistributedType( DataTaskArgument.U_INT1  );

            else if ( token.image . equals ( "u_int2" ) )
              theThisArgument . setDistributedType( DataTaskArgument.U_INT2  );

            else if ( token.image . equals ( "u_int4" ) )
              theThisArgument . setDistributedType( DataTaskArgument.U_INT4  );

            else if ( token.image . equals ( "u_int8" ) )
              theThisArgument . setDistributedType( DataTaskArgument.U_INT8  );


            else if ( token.image . equals ( "int1" ) )
              theThisArgument . setDistributedType ( DataTaskArgument.INT1  );

            else if ( token.image . equals ( "int2" ) )
              theThisArgument . setDistributedType ( DataTaskArgument.INT2  );

            else if ( token.image . equals ( "int4" ) )
              theThisArgument . setDistributedType ( DataTaskArgument.INT4  );

            else if ( token.image . equals ( "int8" ) )
              theThisArgument . setDistributedType ( DataTaskArgument.INT8  );


            else /* Assume typedef/struct/enum by name */
            {
              theThisArgument
                . setDistributedType ( DataTaskArgument.IDENTIFIER );
              theThisArgument . setDistributedId   ( token.image );
            }
          break;
        default:
          jj_la1[73] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case STRUCT:
      jj_consume_token(STRUCT);
      token = parseIdToken();
          theThisArgument . setDistributedType ( DataTaskArgument.STRUCT );
          theThisArgument . setDistributedId ( token.image );
      break;
    case ENUM:
      jj_consume_token(ENUM);
      token = parseIdToken();
          theThisArgument . setDistributedType ( DataTaskArgument.ENUM );
          theThisArgument . setDistributedId ( token.image );
      break;
    default:
      jj_la1[74] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     parseMiscTokens ( theThisArgument, startToken, 0 );
  }

  static final public void parseDistributedDeclaration_internalTrailingStuff(DataTaskArgument theThisArgument) throws ParseException {
  Token   startToken = getToken(0);

  theThisArgument . setDistributedPointer ( false );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      jj_consume_token(CONST);
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
           theThisArgument . setDistributedPointer ( true );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
        jj_consume_token(CONST);
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[77] = jj_gen;
      ;
    }
      parseMiscTokens ( theThisArgument, startToken, 0 );
  }

  static final public DataTaskArgument parseDistributedTaskArgument_Array(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );
  DataExpression    constantDataExpression;
  DataComponent     targetDataComponent;
  Token             token;
    label_17:
    while (true) {
      token = jj_consume_token(OPEN_BRACKET);
          parseFluff ( thisArgument, token, 0 );
          thisArgument . addSubcomponent ( token.image );
          constantDataExpression = null;
      constantDataExpression = parseConstantExpressionObject(0);
          thisArgument . addSubcomponent ( constantDataExpression );
          thisArgument
            . addDistributedArrayExpression ( constantDataExpression );
      token = jj_consume_token(CLOSE_BRACKET);
          parseFluff ( thisArgument, token, 0 );
          thisArgument . addSubcomponent ( token.image );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_17;
      }
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseDistributedTaskArgument_DefaultValue(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument = (   ( theDataTaskArgument != null )
                                     ?   theDataTaskArgument
                                     :   new DataTaskArgument() );

  Token             token, startToken = getToken(0);
    token = jj_consume_token(EQUAL);
        parseMiscTokens ( thisArgument, startToken, 0 );
        startToken = token;
                /* Set this to the subcomponent index OF the equals */
        thisArgument
          . setIndex ( DataTaskArgument.ARGUMENT_EQUALS_INDEX,
                       thisArgument . getSubcomponentsCount() - 1 );
    parseAssignmentExpression();
      parseMiscTokens ( thisArgument, startToken, 0 );
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

  static final public DataTaskArgument parseDistributedDeclaration_includingStructOrEnumDeclarations(DataTaskArgument theDataTaskArgument) throws ParseException {
  DataTaskArgument  thisArgument  = (   ( theDataTaskArgument != null )
                                      ?   theDataTaskArgument
                                      :   new DataTaskArgument() );

  DataDistributedStruct  nestedStruct;
  DataDistributedEnum    nestedEnum;
    if (jj_2_18(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRUCT:
        nestedStruct = parseDistributedStructInternal(null);
               thisArgument . setDistributedType (
                                DataTaskArgument.DATA_DISTRIBUTED_STRUCT );
               thisArgument . setDistributedStruct ( nestedStruct );
        break;
      case ENUM:
        nestedEnum = parseDistributedEnumInternal(null);
               thisArgument . setDistributedType (
                                DataTaskArgument.DATA_DISTRIBUTED_ENUM );
               thisArgument . setDistributedEnum ( nestedEnum );
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case STRUCT:
      case ENUM:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case ID:
        parseDistributedDeclaration_internalTypeItself(thisArgument);
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return thisArgument;}
    throw new Error("Missing return statement in function");
  }

/*******************/
/*** Constraints ***/
/*******************/


        /* Simple constraints have grown since their conception.
	 * They used to be just expand_first and delay_expansion.
	 * Now they contain all the constraints that can be applied
	 * as top task-level constraints to goals, commands, & monitors.
	 */
  static final public DataConstraint parseSimpleConstraint(DataConstraint  theDataConstraint,
                        int             theUnIndent) throws ParseException {
  Token               token, token_2;
  boolean             foundFirstToken      = false;
  DataSpawnTask       exceptionHandlerTask;
  DataSpawnTask       onTerminateSpawnTask = null;
  DataLabelStatement  dataLabel, oldLabel  = null;
  DataConstraint      thisConstraint = (   ( theDataConstraint != null )
                                         ?   theDataConstraint
                                         :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPAND_FIRST:
        token = jj_consume_token(EXPAND_FIRST);
                thisConstraint
                  . setConstraintType ( DataConstraint.EXPAND_FIRST );
        break;
      case DELAY_EXPANSION:
        token = jj_consume_token(DELAY_EXPANSION);
                thisConstraint
                  . setConstraintType ( DataConstraint.DELAY_EXPANSION );
        break;
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
      break;
    case EXPAND:
    case DELAY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPAND:
        token = jj_consume_token(EXPAND);
        token_2 = jj_consume_token(FIRST);
              thisConstraint
                . setConstraintType ( DataConstraint.EXPAND_FIRST );
        break;
      case DELAY:
        token = jj_consume_token(DELAY);
        token_2 = jj_consume_token(EXPANSION);
              thisConstraint
                . setConstraintType ( DataConstraint.DELAY_EXPANSION );
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

          parseFluff ( thisConstraint, token_2, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
      break;
    case EXCEPTION:
    case HANDLER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCEPTION:
        token = jj_consume_token(EXCEPTION);
              parseFluff ( thisConstraint, token, theUnIndent );
              thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
              thisConstraint . setLineNumber ( token.beginLine + 1);
              foundFirstToken = true;
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
      token = jj_consume_token(HANDLER);
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
            if ( foundFirstToken == false )
            {
              thisConstraint . setLineNumber ( token.beginLine + 1);
              foundFirstToken = true;
            }
      exceptionHandlerTask = parseSpawnTask_ExpressionAndScopedTaskOnly(null, theUnIndent);
            thisConstraint
                . setConstraintType ( DataConstraint.EXCEPTION_HANDLER );
            thisConstraint . setExceptionHandlerTask ( exceptionHandlerTask );
      break;
    case ON:
    case ON_TERMINATE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ON_TERMINATE:
        token = jj_consume_token(ON_TERMINATE);
                  thisConstraint
                      . setConstraintType ( DataConstraint.ON_TERMINATE );
                  thisConstraint . setLineNumber ( token.beginLine + 1 );
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
                  thisConstraint . setHasOnTerminateSpawnKeyword ( false );
        break;
      case ON:
        token = jj_consume_token(ON);
                  thisConstraint
                      . setConstraintType ( DataConstraint.ON_TERMINATE );
                  thisConstraint . setLineNumber ( token.beginLine + 1 );
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
                  thisConstraint . setHasOnTerminateSpawnKeyword ( false );
        token = jj_consume_token(TERMINATE);
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_18:
      while (true) {
        if (jj_2_19(2147483647)) {
          ;
        } else {
          break label_18;
        }
        dataLabel = parseLabel(theUnIndent, false);
                if ( onTerminateSpawnTask == null )
                  onTerminateSpawnTask = new DataSpawnTask();

                  /* Order is important here to preserve parent information */
                if ( oldLabel == null )
                  onTerminateSpawnTask . setLabel ( dataLabel );
                else
                  oldLabel . setLabel ( dataLabel );
                oldLabel = dataLabel;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPAWN:
        token = jj_consume_token(SPAWN);
              thisConstraint . setHasOnTerminateSpawnKeyword ( true );
              parseFluff ( thisConstraint, token, theUnIndent );
              thisConstraint . setIndex ( DataConstraint.KEYWORD + 2 );
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      onTerminateSpawnTask = parseSpawnTask_ExpressionAndScopedTaskOnly(onTerminateSpawnTask,
                                                               theUnIndent);
            thisConstraint . setOnTerminateTask ( onTerminateSpawnTask );
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseMaximumActivateConstraint(DataConstraint  theDataConstraint,
                                 int             theUnIndent) throws ParseException {
  Token           token, token_2 = null;
  DataExpression  numericExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAXIMUM_ACTIVATE:
      token = jj_consume_token(MAXIMUM_ACTIVATE);
      numericExpression = parseAssignmentExpressionObject(theUnIndent, true);
            thisConstraint
              . setConstraintType( DataConstraint.MAXIMUM_ACTIVATE );
            thisConstraint . setLineNumber ( token.beginLine + 1 );

            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

            thisConstraint . setNumericExpression ( numericExpression );
      break;
    case MAXIMUM:
      token = jj_consume_token(MAXIMUM);
      token_2 = jj_consume_token(ACTIVATE);
      numericExpression = parseAssignmentExpressionObject(theUnIndent, true);
            thisConstraint
              . setConstraintType( DataConstraint.MAXIMUM_ACTIVATE );
            thisConstraint . setLineNumber ( token.beginLine + 1 );

            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

            parseFluff ( thisConstraint, token_2, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );

            thisConstraint . setNumericExpression ( numericExpression );
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseMaximumTriggerConstraint(DataConstraint  theDataConstraint,
                                int             theUnIndent) throws ParseException {
  Token           token, token_2 = null;
  DataExpression  numericExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAXIMUM_TRIGGER:
      token = jj_consume_token(MAXIMUM_TRIGGER);
      numericExpression = parseAssignmentExpressionObject(theUnIndent, true);
            thisConstraint
              . setConstraintType ( DataConstraint.MAXIMUM_TRIGGER );
            thisConstraint . setLineNumber ( token.beginLine + 1 );

            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

            thisConstraint . setNumericExpression ( numericExpression );
      break;
    case MAXIMUM:
      token = jj_consume_token(MAXIMUM);
      token_2 = jj_consume_token(TRIGGER);
      numericExpression = parseAssignmentExpressionObject(theUnIndent, true);
            thisConstraint
              . setConstraintType ( DataConstraint.MAXIMUM_TRIGGER );
            thisConstraint . setLineNumber ( token.beginLine + 1 );

            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );

            parseFluff ( thisConstraint, token_2, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 1 );

            thisConstraint . setNumericExpression ( numericExpression );
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseMonitorConstraint(DataConstraint  theDataConstraint,
                         int             theUnIndent) throws ParseException {
  Token           token, token_2 = null, numericToken;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
    case HANDLER:
    case EXPAND:
    case DELAY:
    case ON:
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
    case ON_TERMINATE:
      parseSimpleConstraint(thisConstraint, theUnIndent);
      break;
    case SEQUENTIAL:
    case SERIAL:
    case SEQUENTIAL_HANDLING:
    case SEQUENTIAL_EXPANSION:
    case SEQUENTIAL_EXECUTION:
    case SEQUENTIAL_PLANNING:
    case SEQUENTIAL_ACHIEVEMENT:
      parseSequentialOrSerialConstraint(thisConstraint, theUnIndent, true);
      break;
    case MAXIMUM:
    case MAXIMUM_ACTIVATE:
    case MAXIMUM_TRIGGER:
      if (jj_2_20(2)) {
        parseMaximumActivateConstraint(thisConstraint, theUnIndent);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MAXIMUM:
        case MAXIMUM_TRIGGER:
          parseMaximumTriggerConstraint(thisConstraint, theUnIndent);
          break;
        default:
          jj_la1[89] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case MONITOR_PERIOD:
      token = jj_consume_token(MONITOR_PERIOD);
            thisConstraint
              . setConstraintType ( DataConstraint.MONITOR_PERIOD );
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.KEYWORD + 0 );
      parseRelativeTimeExpression(thisConstraint, theUnIndent);
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseHandlerConstraint(DataConstraint  theDataConstraint,
                         int             theUnIndent) throws ParseException {
  DataConstraint  dataConstraint = null;
    dataConstraint = parseMaximumActivateConstraint(theDataConstraint,
                                                              theUnIndent);
      {if (true) return dataConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseSequentialOrSerialConstraint(DataConstraint  theDataConstraint,
                                    int             theUnIndent,
                                    boolean         theIsMonitorConstraint) throws ParseException {
  Token           token, token_2;
  int             keywordIndex = 0;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQUENTIAL:
      token = jj_consume_token(SEQUENTIAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HANDLING:
        token_2 = jj_consume_token(HANDLING);
                      thisConstraint . setConstraintType (
                                        DataConstraint.SEQUENTIAL_HANDLING );
        break;
      case EXPANSION:
        token_2 = jj_consume_token(EXPANSION);
                      thisConstraint . setConstraintType (
                                        DataConstraint.SEQUENTIAL_EXPANSION );
        break;
      case EXECUTION:
        token_2 = jj_consume_token(EXECUTION);
                      thisConstraint . setConstraintType (
                                        DataConstraint.SEQUENTIAL_EXECUTION );
        break;
      case PLANNING:
        token_2 = jj_consume_token(PLANNING);
                      thisConstraint . setConstraintType (
                                        DataConstraint.SEQUENTIAL_EXPANSION );
        break;
      case ACHIEVEMENT:
        token_2 = jj_consume_token(ACHIEVEMENT);
                      thisConstraint . setConstraintType (
                                        DataConstraint.SEQUENTIAL_EXECUTION );
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

            parseFluff ( thisConstraint, token_2, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

            if ( theIsMonitorConstraint )
            {
              if ( token_2.kind == HANDLING )
              {
                {if (true) throw generateParseException ( token_2,
                    "Sequential Handling constraint is not yet "
                    + "available for monitors..." );}
              }

                /* Default to blank... */
              thisConstraint . setEventTagTask ( null );
            }
            else  /* Ie: Not a monitor constraint */
            {
                /* Default to previous */
              thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS );
            }
      if (jj_2_21(2147483647) && (theIsMonitorConstraint == false)) {
        parseTagTask(thisConstraint, theUnIndent);
      } else {
        ;
      }
      break;
    case SERIAL:
    case SEQUENTIAL_HANDLING:
    case SEQUENTIAL_EXPANSION:
    case SEQUENTIAL_EXECUTION:
    case SEQUENTIAL_PLANNING:
    case SEQUENTIAL_ACHIEVEMENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEQUENTIAL_HANDLING:
        token = jj_consume_token(SEQUENTIAL_HANDLING);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SEQUENTIAL_HANDLING );
        break;
      case SEQUENTIAL_EXPANSION:
        token = jj_consume_token(SEQUENTIAL_EXPANSION);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SEQUENTIAL_EXPANSION );
        break;
      case SEQUENTIAL_EXECUTION:
        token = jj_consume_token(SEQUENTIAL_EXECUTION);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SEQUENTIAL_EXECUTION );
        break;
      case SEQUENTIAL_PLANNING:
        token = jj_consume_token(SEQUENTIAL_PLANNING);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SEQUENTIAL_EXPANSION );
        break;
      case SEQUENTIAL_ACHIEVEMENT:
        token = jj_consume_token(SEQUENTIAL_ACHIEVEMENT);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SEQUENTIAL_EXECUTION );
        break;
      case SERIAL:
        token = jj_consume_token(SERIAL);
                  thisConstraint . setConstraintType (
                                       DataConstraint.SERIAL );
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

            if ( theIsMonitorConstraint )
            {
              if ( token.kind == SEQUENTIAL_HANDLING )
              {
                {if (true) throw generateParseException ( token,
                    "Sequential Handling constraint is not yet "
                    + "available for monitors..." );}
              }

                /* Default to blank... */
              thisConstraint . setEventTagTask ( null );
            }
            else  /* Ie: Not a monitor constraint */
            {
                /* Default to previous */
              thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS );
            }
      if (jj_2_22(2147483647) && (theIsMonitorConstraint == false)) {
        parseTagTask(thisConstraint, theUnIndent);
      } else {
        ;
      }
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseDistributedOnAgentConstraint(DataConstraint theDataConstraint,
                                    int            theUnIndent) throws ParseException {
  Token           token;
  int             keywordIndex = 0;
  DataExpression  agentDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    /* ON "AGENT" constraint */
        token = jj_consume_token(ON);
        thisConstraint . setConstraintType ( DataConstraint.ON_AGENT );
        thisConstraint . setLineNumber     ( token.beginLine + 1     );
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint
          . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
    /* This will handle strings with IDs in them too. */
    //da0g: Double-check #line number macros
        agentDataExpression = parseAssignmentExpressionObject(theUnIndent, true);
        thisConstraint
          . setDistributedOnAgentExpression ( agentDataExpression );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseConstraint(DataConstraint  theDataConstraint,
                  int             theUnIndent) throws ParseException {
  Token           token,
                  token_2,
                  timeBoundaryToken                = null,
                  constraintOptionToken            = null,
                  constrainerConstraintOptionToken = null;

  int             keywordIndex = 0;

  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
    case HANDLER:
    case EXPAND:
    case DELAY:
    case SEQUENTIAL:
    case SERIAL:
    case MAXIMUM:
    case MONITOR_PERIOD:
    case ON:
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
    case SEQUENTIAL_HANDLING:
    case SEQUENTIAL_EXPANSION:
    case SEQUENTIAL_EXECUTION:
    case SEQUENTIAL_PLANNING:
    case SEQUENTIAL_ACHIEVEMENT:
    case MAXIMUM_ACTIVATE:
    case MAXIMUM_TRIGGER:
    case ON_TERMINATE:
      if (jj_2_24(2147483647)) {
        parseSequentialOrSerialConstraint(thisConstraint,
                                                        theUnIndent,
                                                        false);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXCEPTION:
        case HANDLER:
        case EXPAND:
        case DELAY:
        case SEQUENTIAL:
        case SERIAL:
        case MAXIMUM:
        case MONITOR_PERIOD:
        case ON:
        case EXPAND_FIRST:
        case DELAY_EXPANSION:
        case SEQUENTIAL_HANDLING:
        case SEQUENTIAL_EXPANSION:
        case SEQUENTIAL_EXECUTION:
        case SEQUENTIAL_PLANNING:
        case SEQUENTIAL_ACHIEVEMENT:
        case MAXIMUM_ACTIVATE:
        case MAXIMUM_TRIGGER:
        case ON_TERMINATE:
          if (jj_2_23(2147483647)) {
            parseMonitorConstraint(thisConstraint, theUnIndent);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ON:
              parseDistributedOnAgentConstraint(thisConstraint,
                                                                 theUnIndent);
              break;
            default:
              jj_la1[94] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case PARALLEL:
    case WAIT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARALLEL:
        token = jj_consume_token(PARALLEL);
                thisConstraint
                  . setConstraintType ( DataConstraint.PARALLEL );
        break;
      case WAIT:
        token = jj_consume_token(WAIT);
                thisConstraint
                  . setConstraintType ( DataConstraint.WAIT );
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          thisConstraint . setLineNumber ( token.beginLine + 1 );
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint
            . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      break;
    case DISABLE_UNTIL:
      token = jj_consume_token(DISABLE_UNTIL);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            thisConstraint . setConstraintOption ( DataConstraint.INVALID );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      if (jj_2_25(2147483647)) {
        parseEvent(thisConstraint, theUnIndent);
                   thisConstraint . setConstraintType (
                                          DataConstraint.DISABLE_UNTIL_EVENT );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case NON_NEGATIVE_INTEGER_CONSTANT:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                   thisConstraint . setConstraintType (
                                           DataConstraint.DISABLE_UNTIL_TIME );
          break;
        default:
          jj_la1[97] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case DISABLE_FOR:
      token = jj_consume_token(DISABLE_FOR);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            thisConstraint . setConstraintOption ( DataConstraint.INVALID );
      parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                      token, keywordIndex,
                                                      theUnIndent);
          thisConstraint
            . setConstraintType ( DataConstraint.DISABLE_FOR_TIME );
          keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
      break;
    case DISABLE:
      token = jj_consume_token(DISABLE);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );

                /* Establish the no-event-option default */
            thisConstraint . setConstraintOption ( DataConstraint.INVALID );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HANDLING:
      case EXPANSION:
      case EXECUTION:
      case PLANNING:
      case ACHIEVEMENT:
        constraintOptionToken = parseConstraintOption();
              thisConstraint . setConstraintOptionStringWithoutParsing (
                                             constraintOptionToken . image );
              parseFluff ( thisConstraint, constraintOptionToken, theUnIndent);
              thisConstraint . setIndex ( DataConstraint.CONSTRAINT_OPTION );
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR_CS:
      case FOR_CI:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR_CS:
          token = jj_consume_token(FOR_CS);
          break;
        case FOR_CI:
          token = jj_consume_token(FOR_CI);
          break;
        default:
          jj_la1[99] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                              token, keywordIndex,
                                                              theUnIndent);
                  thisConstraint
                    . setConstraintType ( DataConstraint.DISABLE_FOR_TIME );
                  keywordIndex
                    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
        break;
      case UNTIL:
        token = jj_consume_token(UNTIL);
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
        if (jj_2_26(2147483647)) {
          parseEvent(thisConstraint, theUnIndent);
                      thisConstraint . setConstraintType (
                                          DataConstraint.DISABLE_UNTIL_EVENT );
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SIZEOF:
          case NEW:
          case DELETE:
          case CHAR:
          case SHORT:
          case INT:
          case LONG:
          case SIGNED:
          case UNSIGNED:
          case FLOAT:
          case DOUBLE:
          case VOID:
          case OPERATOR:
          case TASK:
          case GOAL:
          case COMMAND:
          case MONITOR:
          case EXCEPTION:
          case HANDLER:
          case RESUME:
          case HANDLES:
          case FIRST:
          case TRIGGER:
          case DISTRIBUTED:
          case THREADED:
          case NAME:
          case TDL_REF:
          case GET_NUMBER_OF_TRIGGERS:
          case GET_NUMBER_OF_ACTIVATES:
          case NOT:
          case PLUS:
          case MINUS:
          case INCREMENT:
          case DECREMENT:
          case SCOPE:
          case OPEN_PAREN:
          case AMPERSAND:
          case ASTERISK:
          case TILDE:
          case INTEGER_CONSTANT:
          case CHARACTER_CONSTANT:
          case STRING_CONSTANT:
          case ID:
          case NON_NEGATIVE_INTEGER_CONSTANT:
          case FLOAT_CONSTANT_BASIC:
          case FLOATING_CONSTANT:
            parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                        thisConstraint . setConstraintType (
                                           DataConstraint.DISABLE_UNTIL_TIME );
            break;
          default:
            jj_la1[100] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case TERMINATE_AT:
      token = jj_consume_token(TERMINATE_AT);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      if (jj_2_27(2147483647)) {
        parseEvent(thisConstraint, theUnIndent);
                 thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_EVENT );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case NON_NEGATIVE_INTEGER_CONSTANT:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                 thisConstraint . setConstraintType (
                                            DataConstraint.TERMINATE_AT_TIME );
          break;
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case TERMINATE_IN:
      token = jj_consume_token(TERMINATE_IN);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
      parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                      token, keywordIndex,
                                                      theUnIndent);
          thisConstraint
            . setConstraintType ( DataConstraint.TERMINATE_IN_TIME );
          keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
      break;
    case TERMINATE:
      token = jj_consume_token(TERMINATE);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
                /* Note that we have no "AFTER" event by default... */
            thisConstraint . setEventTagTask ( null );
                /* And NO time values by default. */
            thisConstraint . setHasTime ( false );
                /* Set default constraint-type (If not further qualified) */
            thisConstraint . setConstraintType ( DataConstraint.TERMINATE );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case AT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          token = jj_consume_token(IN);
          parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                                token, keywordIndex,
                                                                theUnIndent);
                  thisConstraint
                    . setConstraintType ( DataConstraint.TERMINATE_IN_TIME );
                  keywordIndex
                    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
          break;
        case AT:
          token = jj_consume_token(AT);
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
          if (jj_2_28(2147483647)) {
            parseEvent(thisConstraint, theUnIndent);
                      thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_EVENT );
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIZEOF:
            case NEW:
            case DELETE:
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case OPERATOR:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case INCREMENT:
            case DECREMENT:
            case SCOPE:
            case OPEN_PAREN:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case NON_NEGATIVE_INTEGER_CONSTANT:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                      thisConstraint . setConstraintType (
                                           DataConstraint.TERMINATE_AT_TIME );
              break;
            default:
              jj_la1[103] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[105] = jj_gen;
        ;
      }
      break;
    case ACTIVATE_AT:
      token = jj_consume_token(ACTIVATE_AT);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      if (jj_2_29(2147483647)) {
        parseEvent(thisConstraint, theUnIndent);
                 thisConstraint . setConstraintType (
                                            DataConstraint.ACTIVATE_AT_EVENT );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case NON_NEGATIVE_INTEGER_CONSTANT:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                 thisConstraint . setConstraintType (
                                             DataConstraint.ACTIVATE_AT_TIME );
          break;
        default:
          jj_la1[106] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case ACTIVATE_IN:
      token = jj_consume_token(ACTIVATE_IN);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
      parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                      token, keywordIndex,
                                                      theUnIndent);
          thisConstraint
            . setConstraintType ( DataConstraint.ACTIVATE_IN_TIME );
          keywordIndex += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
      break;
    case ACTIVATE:
      token = jj_consume_token(ACTIVATE);
            thisConstraint . setLineNumber ( token.beginLine + 1 );
            parseFluff ( thisConstraint, token, theUnIndent );
            thisConstraint
              . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
                /* Note that we have no "AFTER" event by default... */
            thisConstraint . setEventTagTask ( null );
                /* And NO time values by default. */
            thisConstraint . setHasTime ( false );
                /* Set default constraint-type (If not further qualified) */
            thisConstraint . setConstraintType ( DataConstraint.ACTIVATE );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case AT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          token = jj_consume_token(IN);
          parseTrailingChunkIncludingAfterEvent(thisConstraint,
                                                                token, keywordIndex,
                                                                theUnIndent);
                  thisConstraint
                    . setConstraintType ( DataConstraint.ACTIVATE_IN_TIME );
                  keywordIndex
                    += ( thisConstraint . getHasEventTagTask() ) ? 2 : 1;
          break;
        case AT:
          token = jj_consume_token(AT);
                  parseFluff ( thisConstraint, token, theUnIndent );
                  thisConstraint
                    . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
          if (jj_2_30(2147483647)) {
            parseEvent(thisConstraint, theUnIndent);
                      thisConstraint . setConstraintType (
                                            DataConstraint.ACTIVATE_AT_EVENT );
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIZEOF:
            case NEW:
            case DELETE:
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case OPERATOR:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case INCREMENT:
            case DECREMENT:
            case SCOPE:
            case OPEN_PAREN:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case NON_NEGATIVE_INTEGER_CONSTANT:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              parseAbsoluteTimeExpression(thisConstraint, theUnIndent);
                      thisConstraint . setConstraintType (
                                             DataConstraint.ACTIVATE_AT_TIME );
              break;
            default:
              jj_la1[107] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[108] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public Token parseConstraintOption() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HANDLING:
      jj_consume_token(HANDLING);
      break;
    case EXPANSION:
      jj_consume_token(EXPANSION);
      break;
    case EXECUTION:
      jj_consume_token(EXECUTION);
      break;
    case ACHIEVEMENT:
      jj_consume_token(ACHIEVEMENT);
      break;
    case PLANNING:
      jj_consume_token(PLANNING);
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return getToken(0);}
    throw new Error("Missing return statement in function");
  }

  static final public Token parseStateBoundary() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENABLED:
      jj_consume_token(ENABLED);
      break;
    case ACTIVE:
      jj_consume_token(ACTIVE);
      break;
    case COMPLETED:
      jj_consume_token(COMPLETED);
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return getToken(0);}
    throw new Error("Missing return statement in function");
  }

  static final public void parseTagTaskIdWithIndexes(DataConstraintTagTaskIndexes theTagTaskObject,
                          DataComponent                theTagTaskDataComponent,
                          int                          theUnIndent) throws ParseException {
  DataVector      indexes = null;
  Token           token;
  DataExpression  dataExpression;
    token = parseIdToken();
            theTagTaskObject . setTagTask ( token.image );
            parseFluff ( theTagTaskDataComponent, token, theUnIndent );
            theTagTaskDataComponent
              . setIndex ( DataConstraintTagTaskIndexes.TAG_TASK );
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_19;
      }
      token = jj_consume_token(OPEN_BRACKET);
              parseFluff ( theTagTaskDataComponent, token, theUnIndent );
              if ( indexes == null )
                indexes = new DataVector();
              theTagTaskDataComponent . setIndex (
                      DataConstraintTagTaskIndexes.BEGIN_TAG_TASK_INDEX
                    + indexes.count() );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        dataExpression = parseExpressionObject(theUnIndent);
                  theTagTaskDataComponent . setIndex ( "" + indexes.count() );
                  indexes . addElement ( dataExpression );
        break;
      case PERIOD:
        token = jj_consume_token(PERIOD);
                  parseFluff ( theTagTaskDataComponent, token, theUnIndent );
                  theTagTaskDataComponent . setIndex ( "" + indexes.count() );
                  indexes . addElement (
                        DataConstraintTagTaskIndexes.DEFAULT_TAG_TASK_INDEX );
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      token = jj_consume_token(CLOSE_BRACKET);
              parseFluff ( theTagTaskDataComponent, token, theUnIndent );
              theTagTaskDataComponent . setIndex (
                      DataConstraintTagTaskIndexes.END_TAG_TASK_INDEX
                    + indexes.count() );
    }
             if ( indexes == null )
               theTagTaskObject . setTagTaskIndexesWithoutParsing( null );
             else
             {
               Object[]  tagIndexes = new Object [ indexes.count() ];
               for ( int i=0;   i < indexes.count();   i++ )
               {
                 tagIndexes [ i ] = indexes . elementAt(i);
               }
               theTagTaskObject . setTagTaskIndexesWithoutParsing (tagIndexes);
             }

  }

  static final public DataConstraint parseTagTask(DataConstraint  theDataConstraint,
               int             theUnIndent) throws ParseException {
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );

  DataVector      indexes = null;
  Token           token, periodToken;
  DataExpression  dataExpression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS_CS:
    case THIS_CI:
    case SELF:
    case CHILD:
    case PARENT:
    case PREVIOUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PREVIOUS:
        token = jj_consume_token(PREVIOUS);
                thisConstraint . setEventTagTask ( DataConstraint.PREVIOUS );
        break;
      case THIS_CS:
      case THIS_CI:
      case PARENT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PARENT:
          token = jj_consume_token(PARENT);
                    System.err.println (
                                    TDLParser.getFilenameWithoutPathPlusColon()
                                    + (token.beginLine + 1)
                                    + TDLParser.PARENT_WARNING );
          break;
        case THIS_CS:
          token = jj_consume_token(THIS_CS);
          break;
        case THIS_CI:
          token = jj_consume_token(THIS_CI);
          break;
        default:
          jj_la1[115] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              thisConstraint . setEventTagTask ( DataConstraint.THIS );
        break;
      case SELF:
      case CHILD:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SELF:
          token = jj_consume_token(SELF);
                    System.err.println (
                                    TDLParser.getFilenameWithoutPathPlusColon()
                                    + (token.beginLine + 1)
                                    + TDLParser.SELF_WARNING );
          break;
        case CHILD:
          token = jj_consume_token(CHILD);
          break;
        default:
          jj_la1[116] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              thisConstraint . setEventTagTask ( DataConstraint.CHILD );
        break;
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          parseFluff ( thisConstraint, token, theUnIndent );
          thisConstraint . setIndex ( DataConstraint.TAG_TASK );
          thisConstraint . setEventTagTaskIndexesWithoutParsing ( null );
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseTagTaskIdWithIndexes(thisConstraint, thisConstraint,
                                          theUnIndent);
      break;
    default:
      jj_la1[118] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseEvent(DataConstraint  theDataConstraint,
             int             theUnIndent) throws ParseException {
  DataConstraint thisConstraint             = null;
  Token          eventConstraintOptionToken = null;
  Token          stateBoundaryToken         = null;
    thisConstraint = parseTagTask(theDataConstraint, theUnIndent);
           /* Establish default of NO ConstraintOption... */
        thisConstraint . setEventConstraintOption ( DataConstraint.INVALID );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HANDLING:
    case EXPANSION:
    case EXECUTION:
    case PLANNING:
    case ACHIEVEMENT:
      eventConstraintOptionToken = parseConstraintOption();
          thisConstraint . setEventConstraintOptionStringWithoutParsing (
                                          eventConstraintOptionToken . image );
          parseFluff ( thisConstraint, eventConstraintOptionToken,
                       theUnIndent );
          thisConstraint . setIndex ( DataConstraint.EVENT_CONSTRAINT_OPTION );
      break;
    default:
      jj_la1[119] = jj_gen;
      ;
    }
    stateBoundaryToken = parseStateBoundary();
        thisConstraint . setStateBoundaryStringWithoutParsing (
                                                  stateBoundaryToken . image );
        parseFluff ( thisConstraint, stateBoundaryToken, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.STATE_BOUNDARY );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseAbsoluteTimeExpression(DataConstraint  theDataConstraint,
                              int             theUnIndent) throws ParseException {
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
                                    ?   theDataConstraint
                                    :   new DataConstraint() );
  DataExpression dataExpression;
    if (jj_2_31(2147483647)) {
      parseAbsoluteTime(thisConstraint, theUnIndent);
          thisConstraint . setTimeExpression ( null );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        dataExpression = parseAssignmentExpressionObject(getToken(0).endColumn,
                                                                 false);
          thisConstraint . setTimeExpression ( dataExpression );
        break;
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseRelativeTimeExpression(DataConstraint  theDataConstraint,
                              int             theUnIndent) throws ParseException {
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
  DataExpression dataExpression;
    if (jj_2_32(2147483647)) {
      parseRelativeTime(thisConstraint, theUnIndent);
          thisConstraint . setTimeExpression ( null );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        dataExpression = parseAssignmentExpressionObject(getToken(0).endColumn,
                                                                 false);
          thisConstraint . setTimeExpression ( dataExpression );
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseAbsoluteTime(DataConstraint  theDataConstraint,
                    int             theUnIndent) throws ParseException {
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
                                    ?   theDataConstraint
                                    :   new DataConstraint() );
  Token    token,
           hours             = null,
           minutes           = null,
           seconds           = null,
           fractionOfASecond = null;
  int      intValue;
  String   errorString       = null;
  String   tmpString;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_CONSTANT:
      hours = jj_consume_token(INTEGER_CONSTANT);
      break;
    case NON_NEGATIVE_INTEGER_CONSTANT:
      hours = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        parseFluff ( thisConstraint, hours, theUnIndent );
        intValue = Integer.parseInt ( hours.image );
        if ( intValue < 0 )
          errorString =  "Hours (" + hours.image + ") < 0.";
        if ( intValue > 23 )
          errorString = "Hours (" + hours.image + ") > 23.";
        if ( errorString != null )
        {
          {if (true) throw generateParseException ( hours, errorString );}
        }
        else
        {
          thisConstraint . setHoursWithoutParsing ( hours.image );
          thisConstraint . setIndex ( DataConstraint.PRE_TIME_HOURS );
        }
    token = jj_consume_token(COLON);
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.POST_TIME_HOURS );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_CONSTANT:
      minutes = jj_consume_token(INTEGER_CONSTANT);
      break;
    case NON_NEGATIVE_INTEGER_CONSTANT:
      minutes = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        parseFluff ( thisConstraint, minutes, theUnIndent );
        intValue = Integer.parseInt ( minutes.image );
        if ( intValue < 0 )
          errorString = "Minutes (" + minutes.image + ") < 0.";
        if ( intValue > 59 )
          errorString = "Minutes (" + minutes.image + ") > 59.";
        if ( errorString != null )
        {
          {if (true) throw generateParseException ( minutes, errorString );}
        }
        else
        {
          thisConstraint . setMinutesWithoutParsing ( minutes.image );
          thisConstraint . setIndex ( DataConstraint.PRE_TIME_MINUTES );
        }
    token = jj_consume_token(COLON);
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.POST_TIME_MINUTES);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT_CONSTANT_BASIC:
      seconds = jj_consume_token(FLOAT_CONSTANT_BASIC);
              parseFluff ( thisConstraint, seconds, theUnIndent );
              thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
              thisConstraint . removeIndex( DataConstraint.POST_TIME_SECONDS );
              thisConstraint . removeIndex (
                               DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );

                    /* If there is no period, something is very very wrong. */
              if ( seconds.image . indexOf ( '.' ) == -1 )
              {
                {if (true) throw generateParseException ( seconds,
                                           "Internal error:  No <PERIOD> "
                                         + "found in floating point number." );}
              }

                    /* If the period is the first character */
              else if ( seconds.image . startsWith ( "." ) )
              {
                thisConstraint . setSecondsWithoutParsing ( "0" );
              }

                    /* Lets extract the seconds the hard way... */
              else
              {
                tmpString = seconds.image
                              . substring ( 0,
                                            seconds.image . indexOf( '.' ) );
                intValue = Integer.parseInt ( tmpString );

                if ( intValue < 0 )
                  errorString =  "Seconds (" + seconds.image + ") < 0.";
                if ( intValue > 59 )
                  errorString = "Seconds (" + seconds.image + ") > 59.";
                if ( errorString != null )
                  {if (true) throw generateParseException ( seconds, errorString );}
                else
                  thisConstraint . setSecondsWithoutParsing ( tmpString );
              }

                    /* And set the fractions-of-a-second value... */
              if (    ( seconds.image . indexOf ( '.' ) + 1 )
                   >= ( seconds.image . length()            ) )
              {
                thisConstraint . setFractionsOfASecondWithoutParsing ( "0" );
              }
              else
              {
                thisConstraint . setFractionsOfASecondWithoutParsing (
                    seconds.image . substring ( seconds.image . indexOf ( '.' )
                                                + 1 ) );
              }
      break;
    case INTEGER_CONSTANT:
    case NON_NEGATIVE_INTEGER_CONSTANT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_CONSTANT:
        seconds = jj_consume_token(INTEGER_CONSTANT);
        break;
      case NON_NEGATIVE_INTEGER_CONSTANT:
        seconds = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
        break;
      default:
        jj_la1[124] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              parseFluff ( thisConstraint, seconds, theUnIndent );
              intValue = Integer.parseInt ( seconds.image );
              if ( intValue < 0 )
                errorString =  "Seconds (" + seconds.image + ") < 0.";
              if ( intValue > 59 )
                errorString = "Seconds (" + seconds.image + ") > 59.";
              if ( errorString != null )
                {if (true) throw generateParseException ( seconds, errorString );}
              else
              {
                thisConstraint . setSecondsWithoutParsing ( seconds.image );
                thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS);
              }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        token = jj_consume_token(PERIOD);
                parseFluff ( thisConstraint, token, theUnIndent );
                thisConstraint.setIndex ( DataConstraint.POST_TIME_SECONDS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_CONSTANT:
          fractionOfASecond = jj_consume_token(INTEGER_CONSTANT);
          break;
        case NON_NEGATIVE_INTEGER_CONSTANT:
          fractionOfASecond = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
          break;
        default:
          jj_la1[125] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                parseFluff ( thisConstraint, fractionOfASecond, theUnIndent );
                thisConstraint . setFractionsOfASecondWithoutParsing (
                                                     fractionOfASecond.image );
                thisConstraint . setIndex (
                               DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );
        break;
      default:
        jj_la1[126] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraint parseRelativeTime(DataConstraint  theDataConstraint,
                    int             theUnIndent) throws ParseException {
  Token           token, hours, minutes, seconds, fractionOfASecond ;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :   new DataConstraint() );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_CONSTANT:
      hours = jj_consume_token(INTEGER_CONSTANT);
      break;
    case NON_NEGATIVE_INTEGER_CONSTANT:
      hours = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
      break;
    default:
      jj_la1[128] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        parseFluff ( thisConstraint, hours, theUnIndent );
        thisConstraint . setHoursWithoutParsing ( hours.image );
        thisConstraint . setIndex ( DataConstraint.PRE_TIME_HOURS );
    token = jj_consume_token(COLON);
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.POST_TIME_HOURS );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_CONSTANT:
      minutes = jj_consume_token(INTEGER_CONSTANT);
      break;
    case NON_NEGATIVE_INTEGER_CONSTANT:
      minutes = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
      break;
    default:
      jj_la1[129] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        parseFluff ( thisConstraint, minutes, theUnIndent );
        thisConstraint . setMinutesWithoutParsing ( minutes.image );
        thisConstraint . setIndex ( DataConstraint.PRE_TIME_MINUTES );
    token = jj_consume_token(COLON);
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint . setIndex ( DataConstraint.POST_TIME_MINUTES );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT_CONSTANT_BASIC:
      seconds = jj_consume_token(FLOAT_CONSTANT_BASIC);
            parseFluff ( thisConstraint, seconds, theUnIndent );
            thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
            thisConstraint . removeIndex ( DataConstraint.POST_TIME_SECONDS );
            thisConstraint
              . removeIndex ( DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );

                /* If there is no period, something is very very wrong. */
            if ( seconds.image . indexOf ( '.' ) == -1 )
            {
              {if (true) throw generateParseException ( seconds,
                                           "Internal error:  No <PERIOD> "
                                         + "found in floating point number." );}
            }

                /* If the period is the first character */
            else if ( seconds.image . startsWith ( "." ) )
            {
              thisConstraint . setSecondsWithoutParsing ( "0" );
            }

                /* Lets extract the seconds the hard way... */
            else
            {
              thisConstraint . setSecondsWithoutParsing (
                seconds.image . substring ( 0,
                                            seconds.image . indexOf( '.' ) ) );
            }


                /* And set the fractions-of-a-second value... */
            if (    ( seconds.image . indexOf ( '.' ) + 1 )
                 >= ( seconds.image . length()            ) )
            {
              thisConstraint . setFractionsOfASecondWithoutParsing ( "0" );
            }
            else
            {
              thisConstraint . setFractionsOfASecondWithoutParsing (
                seconds.image . substring( seconds.image . indexOf('.') + 1 ));
            }
      break;
    case INTEGER_CONSTANT:
    case NON_NEGATIVE_INTEGER_CONSTANT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_CONSTANT:
        seconds = jj_consume_token(INTEGER_CONSTANT);
        break;
      case NON_NEGATIVE_INTEGER_CONSTANT:
        seconds = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
        break;
      default:
        jj_la1[130] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
              parseFluff ( thisConstraint, seconds, theUnIndent );
              thisConstraint . setSecondsWithoutParsing ( seconds.image );
              thisConstraint . setIndex ( DataConstraint.PRE_TIME_SECONDS );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        token = jj_consume_token(PERIOD);
                parseFluff ( thisConstraint, token, theUnIndent );
                thisConstraint . setIndex ( DataConstraint.POST_TIME_SECONDS );
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_CONSTANT:
          fractionOfASecond = jj_consume_token(INTEGER_CONSTANT);
          break;
        case NON_NEGATIVE_INTEGER_CONSTANT:
          fractionOfASecond = jj_consume_token(NON_NEGATIVE_INTEGER_CONSTANT);
          break;
        default:
          jj_la1[131] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                parseFluff ( thisConstraint, fractionOfASecond, theUnIndent );
                thisConstraint . setFractionsOfASecondWithoutParsing (
                                                     fractionOfASecond.image );
                thisConstraint
                  . setIndex ( DataConstraint.PRE_TIME_FRACTIONS_OF_A_SECOND );
        break;
      default:
        jj_la1[132] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[133] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

/** Extremely useful, if somewhat hard to describe routine...
  * It processes the last token, then parses <relative-time>,
  * followed by an optional "AFTER event" clause.
  */
  static final public DataConstraint parseTrailingChunkIncludingAfterEvent(DataConstraint  theDataConstraint,
                                        Token           theInitialToken,
                                        int             theKeywordIndex,
                                        int             theUnIndent) throws ParseException {
  DataConstraint thisConstraint = (   ( theDataConstraint != null )
                                    ?   theDataConstraint
                                    :   new DataConstraint() );
  Token    token;

        /* Handle initial token processing */
  parseFluff ( thisConstraint, theInitialToken, theUnIndent );
  thisConstraint . setIndex ( DataConstraint.KEYWORD + (theKeywordIndex++) );
        /* Note that we have no "AFTER" event by default... */
  thisConstraint . setEventTagTask ( null );
    parseRelativeTimeExpression(thisConstraint, theUnIndent);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AFTER:
      token = jj_consume_token(AFTER);
           parseFluff ( thisConstraint, token, theUnIndent );
           thisConstraint
             . setIndex ( DataConstraint.KEYWORD + (theKeywordIndex++) );
      parseEvent(thisConstraint, theUnIndent);
      break;
    default:
      jj_la1[134] = jj_gen;
      ;
    }
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataConstraintStatement parseConstraintStatement(int theUnIndent) throws ParseException {
  DataVector               indexes = null;
  Token                    token = getToken(1); /* The First Token */
  DataConstraintStatement  constraintStatement = new DataConstraintStatement();
  DataExpression           dataExpression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS_CS:
    case THIS_CI:
    case PARENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARENT:
        token = jj_consume_token(PARENT);
                  System.err.println (
                                    TDLParser.getFilenameWithoutPathPlusColon()
                                    + (token.beginLine + 1)
                                    + TDLParser.PARENT_WARNING );
        break;
      case THIS_CS:
        token = jj_consume_token(THIS_CS);
        break;
      case THIS_CI:
        token = jj_consume_token(THIS_CI);
        break;
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            constraintStatement . setTaskTag ( DataConstraintStatement.THIS );
            parseFluff ( constraintStatement, token, theUnIndent );
            constraintStatement . setIndex ( DataConstraintStatement.TAG_TASK);
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseTagTaskIdWithIndexes(constraintStatement, constraintStatement,
                                            theUnIndent);
      break;
    default:
      jj_la1[136] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        constraintStatement . setLineNumber ( token.beginLine + 1 );
    parseConstraint(constraintStatement . getConstraint(), theUnIndent);
    token = jj_consume_token(SEMICOLON);
        parseFluff ( constraintStatement, token, theUnIndent );
        constraintStatement . setIndex ( DataConstraintStatement.SEMICOLON );
      {if (true) return constraintStatement;}
    throw new Error("Missing return statement in function");
  }

/*
 * This constraint, unlike most constraints, assume's the "PARENT" value
 * is a TCM_Task_Tree_Ref object.
 */
  static final public DataConstraint parseTcmTaskTreeParentConstraint(DataConstraint theDataConstraint,
                                   int            theUnIndent) throws ParseException {
  Token           token;
  int             keywordIndex = 0;
  DataExpression  parentDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    /* PARENT "TCM_Task_Tree_Ref" constraint */
        token = jj_consume_token(PARENT);
        thisConstraint
        . setConstraintType ( DataConstraint.TCM_TASK_TREE_PARENT );
        thisConstraint . setLineNumber ( token.beginLine + 1 );
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint
          . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
    parentDataExpression = parseAssignmentExpressionObject(theUnIndent, true);
        thisConstraint
          . setTcmTaskTreeParentExpression ( parentDataExpression );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

/*
 * This constraint, unlike most constraints, assume's the "TDL_REF_IN" value
 * is a TCM_Task_Tree_Ref object.
 */
  static final public DataConstraint parseTdlRefInConstraint(DataConstraint theDataConstraint,
                          int            theUnIndent) throws ParseException {
  Token           token;
  int             keywordIndex = 0;
  DataExpression  tdlRefInExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TDL_REF:
      token = jj_consume_token(TDL_REF);
              thisConstraint . setConstraintType ( DataConstraint.TDL_REF_IN );
              thisConstraint . setLineNumber ( token.beginLine + 1 );
              parseFluff ( thisConstraint, token, theUnIndent );
              thisConstraint
                . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        token = jj_consume_token(IN);
                parseFluff ( thisConstraint, token, theUnIndent );
                thisConstraint
                  . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
        break;
      default:
        jj_la1[137] = jj_gen;
        ;
      }
      break;
    case TDL_REF_IN:
      token = jj_consume_token(TDL_REF_IN);
              thisConstraint . setConstraintType ( DataConstraint.TDL_REF_IN );
              thisConstraint . setLineNumber ( token.beginLine + 1 );
              parseFluff ( thisConstraint, token, theUnIndent );
              thisConstraint
                . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
      break;
    default:
      jj_la1[138] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    //da0g: Double-check #line number macros
        tdlRefInExpression = parseAssignmentExpressionObject(theUnIndent, true);
        thisConstraint . setTdlRefInExpression ( tdlRefInExpression );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

/*
 * Assume's the "NAME" value evaluates to a TCM (STRING) type.
 */
  static final public DataConstraint parseTcmTaskTreeNameConstraint(DataConstraint theDataConstraint,
                                 int            theUnIndent) throws ParseException {
  Token           token;
  int             keywordIndex = 0;
  DataExpression  nameDataExpression;
  DataConstraint  thisConstraint = (   ( theDataConstraint != null )
                                     ?   theDataConstraint
                                     :  new DataConstraint() );
  if ( theDataConstraint != null )
    theDataConstraint . clearConstraint();
    /* NAME "(STRING)" constraint */
        token = jj_consume_token(NAME);
        thisConstraint
        . setConstraintType ( DataConstraint.TCM_TASK_TREE_NAME );
        thisConstraint . setLineNumber ( token.beginLine + 1 );
        parseFluff ( thisConstraint, token, theUnIndent );
        thisConstraint
          . setIndex ( DataConstraint.KEYWORD + (keywordIndex++) );
    nameDataExpression = parseAssignmentExpressionObject(theUnIndent, true);
        thisConstraint . setTcmTaskTreeNameExpression ( nameDataExpression );
      {if (true) return thisConstraint;}
    throw new Error("Missing return statement in function");
  }

/************************/
/*** Task Spawning... ***/
/************************/
  static final public DataSpawnTask parseSpawnTask_ScopedTaskOnly(DataSpawnTask theDataSpawnTask,
                                int           theUnIndent) throws ParseException {
  Token           token;
  DataExpression  dataExpression = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
                               ?  theDataSpawnTask : new DataSpawnTask() );
    token = parseScopedIdentifier(spawnTask . getTaskScope());
        parseFluff ( spawnTask, token, theUnIndent );
        spawnTask . setIndex ( DataSpawnTask.TASK_NAME_INDEX );
        spawnTask . setTaskName ( token.image );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( spawnTask, token, theUnIndent );
        spawnTask . setIndex ( DataSpawnTask.OPEN_PAREN );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      dataExpression = parseAssignmentExpressionObject(theUnIndent, false);
          spawnTask . addArgument ( dataExpression );
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[139] = jj_gen;
          break label_20;
        }
        token = jj_consume_token(COMMA);
            parseFluff ( dataExpression, token, theUnIndent );
        dataExpression = parseAssignmentExpressionObject(theUnIndent, false);
            spawnTask . addArgument ( dataExpression );
      }
      break;
    default:
      jj_la1[140] = jj_gen;
      ;
    }
    token = jj_consume_token(CLOSE_PAREN);
        if ( dataExpression != null )
          parseFluff ( dataExpression, token, theUnIndent );
        else
          parseFluff ( spawnTask, token, theUnIndent );
        spawnTask . setIndex ( DataSpawnTask.CLOSE_PAREN );
      {if (true) return spawnTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSpawnTask parseSpawnTask_ExpressionAndScopedTaskOnly(DataSpawnTask theDataSpawnTask,
                                             int           theUnIndent) throws ParseException {
  Token           token;
  DataExpression  dataExpression = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
                               ?  theDataSpawnTask : new DataSpawnTask() );
    label_21:
    while (true) {
      if (jj_2_33(2147483647)) {
        ;
      } else {
        break label_21;
      }
      dataExpression = parseAssignmentExpressionObject_NoDereference(dataExpression,
                                                                   theUnIndent);
          spawnTask . setTaskExpression ( dataExpression );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEREFERENCE:
        token = jj_consume_token(DEREFERENCE);
        break;
      case PERIOD:
        token = jj_consume_token(PERIOD);
        break;
      default:
        jj_la1[141] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          parseFluff ( dataExpression, token, theUnIndent );
          dataExpression . addSubcomponent ( token . image );
    }
    parseSpawnTask_ScopedTaskOnly(spawnTask, theUnIndent);
      {if (true) return spawnTask;}
    throw new Error("Missing return statement in function");
  }

//DataSpawnTask
//parseSpawnTask_TaskOnly ( DataSpawnTask theDataSpawnTask, int theUnIndent ) :
  static final public DataConstraint parseSpawnTask_IndividualSpawnConstraint(int theUnIndent) throws ParseException {
  DataConstraint  dataConstraint;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
    case HANDLER:
    case EXPAND:
    case DELAY:
    case SEQUENTIAL:
    case SERIAL:
    case PARALLEL:
    case WAIT:
    case DISABLE:
    case TERMINATE:
    case MAXIMUM:
    case ACTIVATE:
    case MONITOR_PERIOD:
    case ON:
    case EXPAND_FIRST:
    case DELAY_EXPANSION:
    case SEQUENTIAL_HANDLING:
    case SEQUENTIAL_EXPANSION:
    case SEQUENTIAL_EXECUTION:
    case SEQUENTIAL_PLANNING:
    case SEQUENTIAL_ACHIEVEMENT:
    case DISABLE_UNTIL:
    case DISABLE_FOR:
    case TERMINATE_AT:
    case TERMINATE_IN:
    case ACTIVATE_AT:
    case ACTIVATE_IN:
    case MAXIMUM_ACTIVATE:
    case MAXIMUM_TRIGGER:
    case ON_TERMINATE:
      dataConstraint = parseConstraint(null, theUnIndent);
      break;
    case PARENT:
      dataConstraint = parseTcmTaskTreeParentConstraint(null, theUnIndent);
      break;
    case TDL_REF:
    case TDL_REF_IN:
      dataConstraint = parseTdlRefInConstraint(null, theUnIndent);
      break;
    case NAME:
      dataConstraint = parseTcmTaskTreeNameConstraint(null, theUnIndent);
      break;
    default:
      jj_la1[142] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return dataConstraint;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSpawnTask parseSpawnTask_ConstraintsOnly(DataSpawnTask  theDataSpawnTask,
                                 int            theUnIndent) throws ParseException {
  Token           token;
  DataConstraint  dataConstraint = null;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
                               ?  theDataSpawnTask : new DataSpawnTask() );
    dataConstraint = parseSpawnTask_IndividualSpawnConstraint(theUnIndent);
        spawnTask . addConstraint ( dataConstraint );
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[143] = jj_gen;
        break label_22;
      }
      token = jj_consume_token(COMMA);
          parseFluff ( dataConstraint, token, theUnIndent );
      dataConstraint = parseSpawnTask_IndividualSpawnConstraint(theUnIndent);
          spawnTask . addConstraint ( dataConstraint );
    }
      {if (true) return spawnTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSpawnTask parseSpawnTask(DataSpawnTask  theDataSpawnTask, int theUnIndent) throws ParseException {
  Token           token;
  DataSpawnTask   spawnTask = ( ( theDataSpawnTask != null )
                               ?  theDataSpawnTask : new DataSpawnTask() );
    token = jj_consume_token(SPAWN);
        spawnTask . setLineNumber ( token.beginLine + 1 );
        parseFluff ( spawnTask, token, theUnIndent );
        spawnTask . setIndex ( DataSpawnTask.SPAWN );
    parseSpawnTask_ExpressionAndScopedTaskOnly(spawnTask, theUnIndent);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      token = jj_consume_token(WITH);
          parseFluff ( spawnTask, token, theUnIndent );
          spawnTask . setIndex ( DataSpawnTask.WITH );
      parseSpawnTask_ConstraintsOnly(spawnTask, theUnIndent);
      break;
    default:
      jj_la1[144] = jj_gen;
      ;
    }
    token = jj_consume_token(SEMICOLON);
        parseFluff ( spawnTask, token, theUnIndent );
        spawnTask . setIndex ( DataSpawnTask.SEMICOLON );
      {if (true) return spawnTask;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSpawnTask parseLabeledSpawnTask(DataSpawnTask  theDataSpawnTask, int theUnIndent) throws ParseException {
  DataLabelStatement  dataLabel, oldLabel  = null;
  DataSpawnTask       spawnTask = ( ( theDataSpawnTask != null )
                                   ?  theDataSpawnTask : new DataSpawnTask() );
    label_23:
    while (true) {
      if (jj_2_34(2147483647)) {
        ;
      } else {
        break label_23;
      }
      dataLabel = parseLabel(theUnIndent, false);
                  /* Order is important here to preserve parent information */
        if ( oldLabel == null )
          spawnTask . setLabel ( dataLabel );
        else
          oldLabel . setLabel ( dataLabel );
        oldLabel = dataLabel;
    }
    parseSpawnTask(spawnTask, theUnIndent);
      {if (true) return spawnTask;}
    throw new Error("Missing return statement in function");
  }

/*************************/
/*** TCM Task Binding ****/
/*************************/
  static final public DataBindTaskStatement parseBindTaskStatement(int theUnIndent) throws ParseException {
  Token                   token;
  DataBindTaskStatement   dataBindTaskStatement = new DataBindTaskStatement();
  DataExpression          dataExpression = null;
    token = jj_consume_token(TDL_BIND);
        dataBindTaskStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataBindTaskStatement, token, theUnIndent );
        dataBindTaskStatement
          . setIndex ( DataBindTaskStatement.BIND_INDEX );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataBindTaskStatement, token, theUnIndent );
        dataBindTaskStatement
          . setIndex ( DataBindTaskStatement.OPEN_PAREN );
    if (jj_2_35(2147483647)) {
      dataExpression = parseAssignmentExpressionObject(theUnIndent, false);
              dataBindTaskStatement
                . setLineNumberOfTaskValueToBind ( token.next.beginLine + 1 );
                /*parseFluff is dealt with in parseAssignmentExpressionObject*/
              dataBindTaskStatement
                . setTaskValueToBind ( dataExpression . toString() );
              dataBindTaskStatement
                . setIndex ( DataBindTaskStatement.TASK_VALUE );
      token = jj_consume_token(COMMA);
              parseFluff ( dataBindTaskStatement, token, theUnIndent );
              dataBindTaskStatement
                . setIndex ( DataBindTaskStatement.COMMA );
      token = parseIdToken();
              parseFluff ( dataBindTaskStatement, token, theUnIndent );
              dataBindTaskStatement . setTaskNameToBind( token.image );
              dataBindTaskStatement
                . setIndex ( DataBindTaskStatement.TASK_NAME );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case ID:
        token = parseIdToken();
            dataBindTaskStatement
              . setLineNumberOfTaskValueToBind ( token.beginLine + 1 );
            parseFluff ( dataBindTaskStatement, token, theUnIndent );
            dataBindTaskStatement . setTaskValueToBind ( token.image );
            dataBindTaskStatement . setTaskNameToBind  ( null );
            dataBindTaskStatement
            . setIndex ( DataBindTaskStatement.TASK_VALUE );
        break;
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataBindTaskStatement, token, theUnIndent );
        dataBindTaskStatement
          . setIndex ( DataBindTaskStatement.CLOSE_PAREN );
    token = jj_consume_token(SEMICOLON);
        parseFluff ( dataBindTaskStatement, token, theUnIndent );
        dataBindTaskStatement
          . setIndex ( DataBindTaskStatement.SEMICOLON );
      {if (true) return dataBindTaskStatement;}
    throw new Error("Missing return statement in function");
  }

/******************/
/*** Statements ***/
/******************/
  static final public DataStatement parseStatement(int theUnIndent, int theCompoundUnIndent) throws ParseException {
  DataStatement returnValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACE:
      returnValue = parseCompoundStatement(theCompoundUnIndent);
      break;
    case WITH:
      returnValue = parseWithDo(theUnIndent);
      break;
    case SPAWN:
      returnValue = parseSpawnTask(null, theUnIndent);
      break;
    case TDL_BIND:
      returnValue = parseBindTaskStatement(theUnIndent);
      break;
    case IF:
    case SWITCH:
      returnValue = parseSelectionStatement(theUnIndent);
      break;
    case DO:
    case WHILE:
    case FOR_CS:
      returnValue = parseIterationStatement(theUnIndent);
      break;
    case BREAK:
    case CONTINUE:
    case RETURN:
    case SUCCESS:
    case POSTPONE:
    case FAIL:
      returnValue = parseJumpStatement(theUnIndent);
      break;
    case DEFAULT_LABEL:
    case CASE:
    case SIZEOF:
    case NEW:
    case DELETE:
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case ASM:
    case OPERATOR:
    case GOTO:
    case THROW:
    case CATCH:
    case FINALLY:
    case SETJMP:
    case LONGJMP:
    case _SETJMP:
    case _LONGJMP:
    case SIGSETJMP:
    case SIGLONGJMP:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case THIS_CS:
    case THIS_CI:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case PARENT:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case SEMICOLON:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      if (jj_2_38(2147483647)) {
        /* Was it a label? */
                  returnValue = parseLabeledStatement(theUnIndent);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case FRIEND:
        case TYPEDEF:
        case AUTO:
        case REGISTER:
        case INLINE:
        case CONST:
        case VOLATILE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case CLASS:
        case STRUCT:
        case UNION:
        case ENUM:
        case ASM:
        case OPERATOR:
        case GOTO:
        case THROW:
        case CATCH:
        case FINALLY:
        case SETJMP:
        case LONGJMP:
        case _SETJMP:
        case _LONGJMP:
        case SIGSETJMP:
        case SIGLONGJMP:
        case EXTERN_CS:
        case STATIC_CS:
        case VIRTUAL_CS:
        case THIS_CS:
        case THIS_CI:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case PARENT:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case SEMICOLON:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          if (jj_2_37(2147483647)) {
            catchIllegalCode();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIZEOF:
            case NEW:
            case DELETE:
            case FRIEND:
            case TYPEDEF:
            case AUTO:
            case REGISTER:
            case INLINE:
            case CONST:
            case VOLATILE:
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case CLASS:
            case STRUCT:
            case UNION:
            case ENUM:
            case ASM:
            case OPERATOR:
            case EXTERN_CS:
            case STATIC_CS:
            case VIRTUAL_CS:
            case THIS_CS:
            case THIS_CI:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case PARENT:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case INCREMENT:
            case DECREMENT:
            case SCOPE:
            case OPEN_PAREN:
            case SEMICOLON:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              if (jj_2_36(2147483647)) {
                /* Was it a constraintStatement? */
                                  returnValue = parseConstraintStatement(theUnIndent);
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case SIZEOF:
                case NEW:
                case DELETE:
                case FRIEND:
                case TYPEDEF:
                case AUTO:
                case REGISTER:
                case INLINE:
                case CONST:
                case VOLATILE:
                case CHAR:
                case SHORT:
                case INT:
                case LONG:
                case SIGNED:
                case UNSIGNED:
                case FLOAT:
                case DOUBLE:
                case VOID:
                case CLASS:
                case STRUCT:
                case UNION:
                case ENUM:
                case ASM:
                case OPERATOR:
                case EXTERN_CS:
                case STATIC_CS:
                case VIRTUAL_CS:
                case TASK:
                case GOAL:
                case COMMAND:
                case MONITOR:
                case EXCEPTION:
                case HANDLER:
                case RESUME:
                case HANDLES:
                case FIRST:
                case TRIGGER:
                case DISTRIBUTED:
                case THREADED:
                case NAME:
                case TDL_REF:
                case GET_NUMBER_OF_TRIGGERS:
                case GET_NUMBER_OF_ACTIVATES:
                case NOT:
                case PLUS:
                case MINUS:
                case INCREMENT:
                case DECREMENT:
                case SCOPE:
                case OPEN_PAREN:
                case SEMICOLON:
                case AMPERSAND:
                case ASTERISK:
                case TILDE:
                case INTEGER_CONSTANT:
                case CHARACTER_CONSTANT:
                case STRING_CONSTANT:
                case ID:
                case FLOAT_CONSTANT_BASIC:
                case FLOATING_CONSTANT:
                  returnValue = parseForInitStatement(theUnIndent);
                  break;
                default:
                  jj_la1[146] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
              }
              break;
            default:
              jj_la1[147] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[148] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[149] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      if ( returnValue == null )
      {
        System.err.println ( "[TDLParser:parseStatement] Error:  "
                   + "returnValue is null.  Possibly programmer error..." );
      }
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

  static final public DataLabelStatement parseLabel(int theUnIndent, boolean theAllowCaseOrDefaultLabels) throws ParseException {
  Token               token;
  DataLabelStatement  dataLabel = new DataLabelStatement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      token = parseIdToken();
              dataLabel . setLineNumber ( token.beginLine + 1 );
              parseFluff ( dataLabel, token, theUnIndent );
              dataLabel . setId    ( token.image );
              dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
      break;
    case CASE:
      token = jj_consume_token(CASE);
              if ( theAllowCaseOrDefaultLabels == false )
              {
                {if (true) throw generateParseException ( token,
                              "A \u005c"case ...:\u005c" label is not permitted here." );}
              }
              dataLabel . setIsCase ( true );
              dataLabel . setLineNumber ( token.beginLine + 1 );
              parseFluff ( dataLabel, token, theUnIndent );
              dataLabel . addSubcomponent ( token.image );
              dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
      parseConstantExpression();
              parseMiscTokens ( dataLabel, token, theUnIndent );
      break;
    case DEFAULT_LABEL:
      token = jj_consume_token(DEFAULT_LABEL);
              if ( theAllowCaseOrDefaultLabels == false )
              {
                {if (true) throw generateParseException ( token,
                               "A \u005c"default:\u005c" label is not permitted here." );}
              }
              dataLabel . setIsDefault ( true );
              dataLabel . setLineNumber ( token.beginLine + 1 );
              parseFluff ( dataLabel, token, theUnIndent );
              dataLabel . addSubcomponent ( token.image );
              dataLabel . setIndex ( DataLabelStatement.FIRST_TOKEN_INDEX );
      break;
    default:
      jj_la1[150] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    token = jj_consume_token(COLON);
        parseFluff ( dataLabel, token, theUnIndent );
        dataLabel . setIndex ( DataLabelStatement.COLON );
      {if (true) return dataLabel;}
    throw new Error("Missing return statement in function");
  }

  static final public DataStatement parseLabeledStatement(int theUnIndent) throws ParseException {
  DataLabelStatement   dataLabel, oldStatmentLabel;
  DataStatement        dataStatement;
    dataLabel = parseLabel(theUnIndent, true);
    dataStatement = parseStatement(theUnIndent, theUnIndent);
        /* Order is important here to preserve parent information */
      oldStatmentLabel = dataStatement . getLabel();
      dataStatement . setLabel ( dataLabel );
      dataLabel     . setLabel ( oldStatmentLabel );
      {if (true) return dataStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataExpressionStatement parseExpressionStatement(int theUnIndent) throws ParseException {
  Token                    token;
  Token                    firstToken     = getToken(1);
  DataExpression           dataExpression = null;
  DataExpressionStatement  dataExpressionStatement
                                          = new DataExpressionStatement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      dataExpression = parseExpressionObject(theUnIndent);
           dataExpressionStatement . setIndex (
                                    DataExpressionStatement.EXPRESSION_INDEX );
      break;
    default:
      jj_la1[151] = jj_gen;
      ;
    }
    token = jj_consume_token(SEMICOLON);
         dataExpressionStatement . setLineNumber ( firstToken.beginLine + 1 );
         dataExpressionStatement . setExpression ( dataExpression );
         parseFluff ( dataExpressionStatement, token, theUnIndent );
         dataExpressionStatement . setIndex (
                                        DataExpressionStatement.SEMICOLON );
      {if (true) return dataExpressionStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataCompoundStatement parseCompoundStatement(int theUnIndent) throws ParseException {
  Token                  token;
  DataCompoundStatement  dataCompound = new DataCompoundStatement();
  DataStatement          dataStatement;
    token = jj_consume_token(OPEN_BRACE);
        dataCompound . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataCompound, token, theUnIndent );
        dataCompound . setIndex ( DataCompoundStatement.OPEN_BRACE );
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
      case IF:
      case SWITCH:
      case DEFAULT_LABEL:
      case WHILE:
      case BREAK:
      case CONTINUE:
      case RETURN:
      case CASE:
      case SIZEOF:
      case NEW:
      case DELETE:
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case ASM:
      case OPERATOR:
      case GOTO:
      case THROW:
      case CATCH:
      case FINALLY:
      case SETJMP:
      case LONGJMP:
      case _SETJMP:
      case _LONGJMP:
      case SIGSETJMP:
      case SIGLONGJMP:
      case EXTERN_CS:
      case FOR_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case THIS_CS:
      case THIS_CI:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case SUCCESS:
      case POSTPONE:
      case FAIL:
      case PARENT:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SPAWN:
      case WITH:
      case TDL_REF:
      case TDL_BIND:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case OPEN_BRACE:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        ;
        break;
      default:
        jj_la1[152] = jj_gen;
        break label_24;
      }
      dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                            theUnIndent + DataComponent.getIndent());
          dataCompound . addSubcomponent ( dataStatement );
    }
    token = jj_consume_token(CLOSE_BRACE);
        dataCompound . setLineNumberOfCloseBrace ( token.beginLine + 1 );
        parseFluff ( dataCompound, token, theUnIndent );
        dataCompound . setIndex ( DataCompoundStatement.CLOSE_BRACE );
      {if (true) return dataCompound;}
    throw new Error("Missing return statement in function");
  }

  static final public DataWithDoStatement parseWithDo_Constraints(DataWithDoStatement  theDataWithDoStatement,
                          int                  theUnIndent) throws ParseException {
  Token                token;
  DataConstraint       dataConstraint = null;
  DataWithDoStatement  dataWithDoStatement
                         = (   ( theDataWithDoStatement != null )
                             ? theDataWithDoStatement
                             : new DataWithDoStatement() );
    dataConstraint = parseConstraint(null, theUnIndent);
        dataWithDoStatement . addConstraint ( dataConstraint );
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[153] = jj_gen;
        break label_25;
      }
      token = jj_consume_token(COMMA);
          parseFluff ( dataConstraint, token, theUnIndent );
      dataConstraint = parseConstraint(null, theUnIndent);
          dataWithDoStatement . addConstraint ( dataConstraint );
    }
        /* Parse the fluff off the next (future) token... */
      parseFluff ( dataConstraint, getToken(1), theUnIndent );
      {if (true) return dataWithDoStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataWithDoStatement parseWithDo(int theUnIndent) throws ParseException {
  Token                token;
  DataWithDoStatement  dataWithDoStatement = new DataWithDoStatement();
  DataConstraint       dataConstraint      = null;
  DataStatement        dataStatement       = null;
    token = jj_consume_token(WITH);
        dataWithDoStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataWithDoStatement, token, theUnIndent );
        dataWithDoStatement . setIndex ( DataWithDoStatement.WITH );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataWithDoStatement, token, theUnIndent );
        dataWithDoStatement . setIndex ( DataWithDoStatement.OPEN_PAREN );
    parseWithDo_Constraints(dataWithDoStatement, theUnIndent);
    token = jj_consume_token(CLOSE_PAREN);
        dataWithDoStatement . setIndex ( DataWithDoStatement.CLOSE_PAREN );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataWithDoStatement . setStatement ( dataStatement );
      {if (true) return dataWithDoStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSelectionStatement parseSelectionStatement(int theUnIndent) throws ParseException {
  DataSelectionStatement   dataSelectionStatement;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      dataSelectionStatement = parseIfElse(theUnIndent);
      break;
    case SWITCH:
      dataSelectionStatement = parseSwitch(theUnIndent);
      break;
    default:
      jj_la1[154] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return dataSelectionStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataIterationStatement parseIterationStatement(int theUnIndent) throws ParseException {
  DataIterationStatement  dataIterationStatement = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR_CS:
      dataIterationStatement = parseFor(theUnIndent);
      break;
    case WHILE:
      dataIterationStatement = parseWhile(theUnIndent);
      break;
    case DO:
      dataIterationStatement = parseDoWhile(theUnIndent);
      break;
    default:
      jj_la1[155] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return dataIterationStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataJumpStatement parseJumpStatement(int theUnIndent) throws ParseException {
  Token                 token;
  DataJumpStatement     dataJumpStatement    = new DataJumpStatement();
  DataExpression        dataExpression       = null;
  DataSpawnTask         exceptionTask        = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      token = jj_consume_token(BREAK);
            dataJumpStatement.setType ( DataJumpStatement.BREAK_TYPE    );
      break;
    case CONTINUE:
      token = jj_consume_token(CONTINUE);
            dataJumpStatement.setType ( DataJumpStatement.CONTINUE_TYPE );
      break;
    case RETURN:
      token = jj_consume_token(RETURN);
              dataJumpStatement.setType ( DataJumpStatement.RETURN_TYPE );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        dataExpression = parseExpressionObject(theUnIndent);
        break;
      default:
        jj_la1[156] = jj_gen;
        ;
      }
      break;
    case SUCCESS:
      token = jj_consume_token(SUCCESS);
            dataJumpStatement.setType ( DataJumpStatement.SUCCESS_TYPE  );
      break;
    case POSTPONE:
      token = jj_consume_token(POSTPONE);
            dataJumpStatement.setType ( DataJumpStatement.POSTPONE_TYPE );
      break;
    case FAIL:
      token = jj_consume_token(FAIL);
              dataJumpStatement.setType ( DataJumpStatement.FAIL_TYPE   );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        exceptionTask = parseSpawnTask_ExpressionAndScopedTaskOnly(null,
                                                              getToken(0).endColumn);
        break;
      default:
        jj_la1[157] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[158] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        parseFluff ( dataJumpStatement, token, theUnIndent );
        dataJumpStatement . setIndex ( DataJumpStatement.FIRST_TOKEN_INDEX );
        dataJumpStatement . setLineNumber     ( token.beginLine + 1 );
        dataJumpStatement . setDataExpression ( dataExpression );
        dataJumpStatement . setExceptionTask  ( exceptionTask );
    token = jj_consume_token(SEMICOLON);
        parseFluff ( dataJumpStatement, token, theUnIndent );
        dataJumpStatement . setIndex ( DataJumpStatement.SEMICOLON );
      {if (true) return dataJumpStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public void catchIllegalCode() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[159] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GOTO:
      jj_consume_token(GOTO);
      break;
    case THROW:
      jj_consume_token(THROW);
      break;
    case CATCH:
      jj_consume_token(CATCH);
      break;
    case FINALLY:
      jj_consume_token(FINALLY);
      break;
    case SETJMP:
      jj_consume_token(SETJMP);
      break;
    case LONGJMP:
      jj_consume_token(LONGJMP);
      break;
    case _SETJMP:
      jj_consume_token(_SETJMP);
      break;
    case _LONGJMP:
      jj_consume_token(_LONGJMP);
      break;
    case SIGSETJMP:
      jj_consume_token(SIGSETJMP);
      break;
    case SIGLONGJMP:
      jj_consume_token(SIGLONGJMP);
      break;
    default:
      jj_la1[160] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) throw generateParseException ( getToken(0),
                     "\u005c"" + getToken(0).image + "\u005c" "
                   + "Is not permitted inside Task Statements.\u005cn"
                   + "(Consider using \u005c"break\u005c", \u005c"continue\u005c", or \u005c"return\u005c".)"
                   );}
  }

  static final public DataDeclarationStatement parseDeclarationStatement(int theUnIndent) throws ParseException {
  Token                      token      = getToken(0);
  Token                      firstToken = getToken(1);
  DataDeclarationStatement   dataDeclarationStatement
                                        = new DataDeclarationStatement();
    parseDeclaration();
        dataDeclarationStatement . setLineNumber ( firstToken.beginLine + 1 );
        parseMiscTokens ( dataDeclarationStatement, token, theUnIndent );
        dataDeclarationStatement
          . setIndex ( DataDeclarationStatement.FIRST_TOKEN_INDEX,
                       firstToken.image );
      {if (true) return dataDeclarationStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataIfElseStatement parseIfElse(int theUnIndent) throws ParseException {
  Token                token;
  DataExpression       dataExpression;
  DataStatement        dataStatement;
  DataIfElseStatement  dataIfElseStatement = new DataIfElseStatement();
    token = jj_consume_token(IF);
        dataIfElseStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataIfElseStatement, token, theUnIndent );
        dataIfElseStatement . setIndex ( DataIfElseStatement.IF );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataIfElseStatement, token, theUnIndent );
        dataIfElseStatement . setIndex ( DataIfElseStatement.OPEN_PAREN );
    /* conditional expression */
        dataExpression = parseExpressionObject(theUnIndent);
        dataIfElseStatement . setExpression ( dataExpression );
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataExpression, token, theUnIndent );
        dataIfElseStatement . setIndex ( DataIfElseStatement.CLOSE_PAREN );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataIfElseStatement . setIfStatement ( dataStatement );
    if (jj_2_39(2147483647)) {
      token = jj_consume_token(ELSE);
          dataIfElseStatement . setLineNumberOfElse ( token.beginLine + 1 );
          parseFluff ( dataIfElseStatement, token, theUnIndent );
          dataIfElseStatement . setIndex ( DataIfElseStatement.ELSE );
      dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                             theUnIndent);
          dataIfElseStatement . setElseStatement ( dataStatement );
    } else {
      ;
    }
      {if (true) return dataIfElseStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataSwitchStatement parseSwitch(int theUnIndent) throws ParseException {
  Token                token;
  DataExpression       dataExpression;
  DataStatement        dataStatement;
  DataSwitchStatement  dataSwitchStatement = new DataSwitchStatement();
    token = jj_consume_token(SWITCH);
        dataSwitchStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataSwitchStatement, token, theUnIndent );
        dataSwitchStatement . setIndex ( dataSwitchStatement.SWITCH );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataSwitchStatement, token, theUnIndent );
        dataSwitchStatement . setIndex ( dataSwitchStatement.OPEN_PAREN );
    /* conditional expression */
        dataExpression = parseExpressionObject(theUnIndent);
        dataSwitchStatement . setExpression ( dataExpression );
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataSwitchStatement, token, theUnIndent );
        dataSwitchStatement . setIndex ( dataSwitchStatement.CLOSE_PAREN );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataSwitchStatement . setStatement ( dataStatement );
      {if (true) return dataSwitchStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataForStatement parseFor(int theUnIndent) throws ParseException {
  Token             token;
  DataStatement     initialStatement    = null;
  DataExpression    testExpression      = null;
  DataExpression    iterationExpression = null;
  DataStatement     dataStatement;
  DataForStatement  dataForStatement = new DataForStatement();
    token = jj_consume_token(FOR_CS);
        dataForStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataForStatement, token, theUnIndent );
        dataForStatement . setIndex ( DataForStatement.FOR );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataForStatement, token, theUnIndent );
        dataForStatement . setIndex ( DataForStatement.OPEN_PAREN );
    /* optional initializer expression/declaration */
        initialStatement = parseForInitStatement(theUnIndent);
        dataForStatement
          . setInitialExpressionOrDeclarationStatement ( initialStatement );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      testExpression = parseExpressionObject(theUnIndent);
      break;
    default:
      jj_la1[161] = jj_gen;
      ;
    }
    token = jj_consume_token(SEMICOLON);
        parseFluff ( dataForStatement, token, theUnIndent );
        dataForStatement . setIndex ( DataForStatement.SEMICOLON );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      iterationExpression = parseExpressionObject(theUnIndent);
      break;
    default:
      jj_la1[162] = jj_gen;
      ;
    }
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataForStatement, token, theUnIndent );
        dataForStatement . setIndex ( DataForStatement.CLOSE_PAREN );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataForStatement . setStatement ( dataStatement );
        /* Store these here so we can set them to null if they don't exist.. */
      dataForStatement . setTestExpression      ( testExpression      );
      dataForStatement . setIterationExpression ( iterationExpression );

        /* And return the result. */
      {if (true) return dataForStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataStatement parseForInitStatement(int theUnIndent) throws ParseException {
  DataStatement returnValue;
    if (jj_2_40(2147483647)) {
      returnValue = parseDeclarationStatement(theUnIndent);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        returnValue = parseExpressionStatement(theUnIndent);
        break;
      default:
        jj_la1[163] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return returnValue;}
    throw new Error("Missing return statement in function");
  }

  static final public DataWhileStatement parseWhile(int theUnIndent) throws ParseException {
  Token               token;
  DataExpression      dataExpression;
  DataStatement       dataStatement;
  DataWhileStatement  dataWhileStatement = new DataWhileStatement();
    token = jj_consume_token(WHILE);
        dataWhileStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataWhileStatement, token, theUnIndent );
        dataWhileStatement . setIndex ( DataWhileStatement.WHILE );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataWhileStatement, token, theUnIndent );
        dataWhileStatement . setIndex ( DataWhileStatement.OPEN_PAREN );
    /* conditional expression */
        dataExpression = parseExpressionObject(theUnIndent);
        dataWhileStatement . setExpression ( dataExpression );
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataWhileStatement, token, theUnIndent );
        dataWhileStatement . setIndex ( DataWhileStatement.CLOSE_PAREN );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataWhileStatement . setStatement ( dataStatement );
      {if (true) return dataWhileStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataDoWhileStatement parseDoWhile(int theUnIndent) throws ParseException {
  Token                 token;
  DataExpression        dataExpression;
  DataStatement         dataStatement;
  DataDoWhileStatement  dataDoWhileStatement = new DataDoWhileStatement();
    token = jj_consume_token(DO);
        dataDoWhileStatement . setLineNumber ( token.beginLine + 1 );
        parseFluff ( dataDoWhileStatement, token, theUnIndent );
        dataDoWhileStatement . setIndex ( DataDoWhileStatement.DO );
    dataStatement = parseStatement(theUnIndent + DataComponent.getIndent(),
                                         theUnIndent);
        dataDoWhileStatement . setStatement ( dataStatement );
    token = jj_consume_token(WHILE);
        parseFluff ( dataDoWhileStatement, token, theUnIndent );
        dataDoWhileStatement . setIndex ( DataDoWhileStatement.WHILE );
    token = jj_consume_token(OPEN_PAREN);
        parseFluff ( dataDoWhileStatement, token, theUnIndent );
        dataDoWhileStatement . setIndex ( DataDoWhileStatement.OPEN_PAREN );
    /* conditional expression */
        dataExpression = parseExpressionObject(theUnIndent);
        dataDoWhileStatement . setExpression ( dataExpression );
    token = jj_consume_token(CLOSE_PAREN);
        parseFluff ( dataDoWhileStatement, token, theUnIndent );
        dataDoWhileStatement . setIndex ( DataDoWhileStatement.CLOSE_PAREN );
    token = jj_consume_token(SEMICOLON);
        parseFluff ( dataDoWhileStatement, token, theUnIndent );
        dataDoWhileStatement . setIndex ( DataDoWhileStatement.SEMICOLON );
      {if (true) return dataDoWhileStatement;}
    throw new Error("Missing return statement in function");
  }

  static final public DataExpression parseExpressionObject(int theUnIndent) throws ParseException {
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
    parseExpression();
        dataExpression . setLineNumber ( firstToken.beginLine + 1 );
        parseMiscTokens ( dataExpression, token, theUnIndent );
        dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
                                    firstToken.image );
      {if (true) return dataExpression;}
    throw new Error("Missing return statement in function");
  }

  static final public DataExpression parseConstantExpressionObject(int theUnIndent) throws ParseException {
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
    parseConstantExpression();
        dataExpression . setLineNumber ( firstToken.beginLine + 1 );
        parseMiscTokens ( dataExpression, token, theUnIndent );
        dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
                                    firstToken.image );
      {if (true) return dataExpression;}
    throw new Error("Missing return statement in function");
  }

        /* Sometime we just can't deal with the comma operator
	 * like in with-do constrants, or argument defaults...
	 */
  static final public DataExpression parseAssignmentExpressionObject(int      theUnIndent,
                                  boolean  theLineNumberStartsAtFirstToken) throws ParseException {
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = new DataExpression();
    parseAssignmentExpression();
        parseMiscTokens ( dataExpression, token, theUnIndent );

        if ( theLineNumberStartsAtFirstToken == false )
        {
            /* "token" is the last token before our Assignment-Expression */
          dataExpression . setLineNumber ( token . endLine + 1 );
        }
        else
        {
          dataExpression . setLineNumber ( firstToken.beginLine + 1 );
          dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
                                      firstToken.image );
        }
      {if (true) return dataExpression;}
    throw new Error("Missing return statement in function");
  }

  static final public DataExpression parseAssignmentExpressionObject_NoDereference(DataExpression theDataExpression,
                                           int            theUnIndent) throws ParseException {
  Token           token          = getToken(0);
  Token           firstToken     = getToken(1);
  DataExpression  dataExpression = ( ( theDataExpression != null )
                                    ?  theDataExpression
                                    : new DataExpression() );
    parseAssignmentExpression_NoDereference();
        parseMiscTokens ( dataExpression, token, theUnIndent );
        if ( theDataExpression == null )
        {
          dataExpression . setLineNumber ( firstToken.beginLine + 1 );
          dataExpression . setIndex ( DataExpression.FIRST_TOKEN_INDEX,
                                      firstToken.image );
        }
      {if (true) return dataExpression;}
    throw new Error("Missing return statement in function");
  }

/********************/
/***  Basic Types ***/
/********************/

  /* Note:  Includes templateClassNames as class-names. */
  static final public void parseClassName() throws ParseException {
    if (jj_2_41(2147483647)) {
      parseTemplateClassName();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case ID:
        parseIdToken();
        break;
      default:
        jj_la1[164] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseEnumName() throws ParseException {
    parseIdToken();

  }

  static final public void parseTypedefName() throws ParseException {
    parseIdToken();

  }

  static final public void parseTemplateName() throws ParseException {
    parseIdToken();

  }

/******************************/
/***  Expression parsing..  ***/
/******************************/
  static final public void parseExpression() throws ParseException {
    parseAssignmentExpression();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[165] = jj_gen;
        break label_26;
      }
      jj_consume_token(COMMA);
      parseAssignmentExpression();
    }

  }

  static final public void parseAssignmentExpression_Subpart() throws ParseException {
    parseUnaryExpression();
    parseAssignmentOperator();
    parseAssignmentExpression();

  }

  static final public void parseAssignmentExpression() throws ParseException {
    if (jj_2_42(2147483647)) {
      parseAssignmentExpression_Subpart();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseConditionalExpression();
        break;
      default:
        jj_la1[166] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseAssignmentOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      break;
    case MULTIPLY_EQUAL:
      jj_consume_token(MULTIPLY_EQUAL);
      break;
    case DIVIDE_EQUAL:
      jj_consume_token(DIVIDE_EQUAL);
      break;
    case MODULO_EQUAL:
      jj_consume_token(MODULO_EQUAL);
      break;
    case PLUS_EQUAL:
      jj_consume_token(PLUS_EQUAL);
      break;
    case MINUS_EQUAL:
      jj_consume_token(MINUS_EQUAL);
      break;
    case RIGHTSHIFT_EQUAL:
      jj_consume_token(RIGHTSHIFT_EQUAL);
      break;
    case LEFTSHIFT_EQUAL:
      jj_consume_token(LEFTSHIFT_EQUAL);
      break;
    case AND_EQUAL:
      jj_consume_token(AND_EQUAL);
      break;
    case XOR_EQUAL:
      jj_consume_token(XOR_EQUAL);
      break;
    case OR_EQUAL:
      jj_consume_token(OR_EQUAL);
      break;
    default:
      jj_la1[167] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/* AKA:  parseConstantExpression() */
  static final public void parseConditionalExpression() throws ParseException {
    parseLogicalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_MARK:
      jj_consume_token(QUESTION_MARK);
      parseExpression();
      jj_consume_token(COLON);
      parseAssignmentExpression();
      break;
    default:
      jj_la1[168] = jj_gen;
      ;
    }

  }

  static final public void parseLogicalOrExpression() throws ParseException {
    parseLogicalAndExpression();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_OR:
        ;
        break;
      default:
        jj_la1[169] = jj_gen;
        break label_27;
      }
      jj_consume_token(LOGICAL_OR);
      parseLogicalAndExpression();
    }

  }

  static final public void parseLogicalAndExpression() throws ParseException {
    parseInclusiveOrExpression();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_AND:
        ;
        break;
      default:
        jj_la1[170] = jj_gen;
        break label_28;
      }
      jj_consume_token(LOGICAL_AND);
      parseInclusiveOrExpression();
    }

  }

  static final public void parseInclusiveOrExpression() throws ParseException {
    parseExclusiveOrExpression();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCLUSIVE_OR:
        ;
        break;
      default:
        jj_la1[171] = jj_gen;
        break label_29;
      }
      jj_consume_token(INCLUSIVE_OR);
      parseExclusiveOrExpression();
    }

  }

  static final public void parseExclusiveOrExpression() throws ParseException {
    parseAndExpression();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCLUSIVE_OR:
        ;
        break;
      default:
        jj_la1[172] = jj_gen;
        break label_30;
      }
      jj_consume_token(EXCLUSIVE_OR);
      parseAndExpression();
    }

  }

  static final public void parseAndExpression() throws ParseException {
    parseEqualityExpression();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        ;
        break;
      default:
        jj_la1[173] = jj_gen;
        break label_31;
      }
      jj_consume_token(AMPERSAND);
      parseEqualityExpression();
    }

  }

  static final public void parseEqualityExpression() throws ParseException {
    parseRelationalExpression();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALITY:
      case INEQUALITY:
        ;
        break;
      default:
        jj_la1[174] = jj_gen;
        break label_32;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALITY:
        jj_consume_token(EQUALITY);
        break;
      case INEQUALITY:
        jj_consume_token(INEQUALITY);
        break;
      default:
        jj_la1[175] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseRelationalExpression();
    }

  }

  static final public void parseRelationalExpression() throws ParseException {
    parseShiftExpression();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_THAN_OR_EQUALS:
      case GREATER_THAN_OR_EQUALS:
        ;
        break;
      default:
        jj_la1[176] = jj_gen;
        break label_33;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
        jj_consume_token(LESS_THAN);
        break;
      case GREATER_THAN:
        jj_consume_token(GREATER_THAN);
        break;
      case LESS_THAN_OR_EQUALS:
        jj_consume_token(LESS_THAN_OR_EQUALS);
        break;
      case GREATER_THAN_OR_EQUALS:
        jj_consume_token(GREATER_THAN_OR_EQUALS);
        break;
      default:
        jj_la1[177] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseShiftExpression();
    }

  }

        /* TemplateArg's have a problem with <GREATER_THAN> */
  static final public void parseRelationalExpression_ExcludingGreaterThan() throws ParseException {
    parseShiftExpression();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
      case LESS_THAN_OR_EQUALS:
      case GREATER_THAN_OR_EQUALS:
        ;
        break;
      default:
        jj_la1[178] = jj_gen;
        break label_34;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
        jj_consume_token(LESS_THAN);
        break;
      case LESS_THAN_OR_EQUALS:
        jj_consume_token(LESS_THAN_OR_EQUALS);
        break;
      case GREATER_THAN_OR_EQUALS:
        jj_consume_token(GREATER_THAN_OR_EQUALS);
        break;
      default:
        jj_la1[179] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseShiftExpression();
    }

  }

  static final public void parseShiftExpression() throws ParseException {
    parseAdditiveExpression();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
      case RIGHT_SHIFT:
        ;
        break;
      default:
        jj_la1[180] = jj_gen;
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
        jj_consume_token(LEFT_SHIFT);
        break;
      case RIGHT_SHIFT:
        jj_consume_token(RIGHT_SHIFT);
        break;
      default:
        jj_la1[181] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseAdditiveExpression();
    }

  }

  static final public void parseAdditiveExpression() throws ParseException {
    parseMultiplicativeExpression();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[182] = jj_gen;
        break label_36;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        break;
      case MINUS:
        jj_consume_token(MINUS);
        break;
      default:
        jj_la1[183] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseMultiplicativeExpression();
    }

  }

  static final public void parseMultiplicativeExpression() throws ParseException {
    parsePointerToMemberExpression();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIVIDE:
      case MODULO:
      case ASTERISK:
        ;
        break;
      default:
        jj_la1[184] = jj_gen;
        break label_37;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        jj_consume_token(DIVIDE);
        break;
      case MODULO:
        jj_consume_token(MODULO);
        break;
      default:
        jj_la1[185] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parsePointerToMemberExpression();
    }

  }

  static final public void parsePointerToMemberExpression() throws ParseException {
    parseCastExpression();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POINTER_TO_MEMBER:
      case POINTER_TO_MEMBER_DEREFERENCE:
        ;
        break;
      default:
        jj_la1[186] = jj_gen;
        break label_38;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POINTER_TO_MEMBER:
        jj_consume_token(POINTER_TO_MEMBER);
        break;
      case POINTER_TO_MEMBER_DEREFERENCE:
        jj_consume_token(POINTER_TO_MEMBER_DEREFERENCE);
        break;
      default:
        jj_la1[187] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseCastExpression();
    }

  }

  static final public void parseCastExpression_Subpart() throws ParseException {
    jj_consume_token(OPEN_PAREN);
    parseTypeName();
    jj_consume_token(CLOSE_PAREN);
    parseCastExpression();

  }

  static final public void parseCastExpression() throws ParseException {
    if (jj_2_43(2147483647)) {
      parseCastExpression_Subpart();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseUnaryExpression();
        break;
      default:
        jj_la1[188] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseUnaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
      jj_consume_token(INCREMENT);
      parseUnaryExpression();
      break;
    case DECREMENT:
      jj_consume_token(DECREMENT);
      parseUnaryExpression();
      break;
    case SIZEOF:
      jj_consume_token(SIZEOF);
      if (jj_2_44(2147483647)) {
        parseCastExpression_Subpart();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseUnaryExpression();
          break;
        default:
          jj_la1[189] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      if (jj_2_47(2147483647)) {
        parseDeallocationExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          if (jj_2_46(2147483647)) {
            parseAllocationExpression();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case OPERATOR:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case SCOPE:
            case OPEN_PAREN:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              if (jj_2_45(2147483647)) {
                parseUnaryOperator();
                parseCastExpression();
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case CHAR:
                case SHORT:
                case INT:
                case LONG:
                case SIGNED:
                case UNSIGNED:
                case FLOAT:
                case DOUBLE:
                case VOID:
                case OPERATOR:
                case TASK:
                case GOAL:
                case COMMAND:
                case MONITOR:
                case EXCEPTION:
                case HANDLER:
                case RESUME:
                case HANDLES:
                case FIRST:
                case TRIGGER:
                case DISTRIBUTED:
                case THREADED:
                case NAME:
                case TDL_REF:
                case GET_NUMBER_OF_TRIGGERS:
                case GET_NUMBER_OF_ACTIVATES:
                case SCOPE:
                case OPEN_PAREN:
                case TILDE:
                case INTEGER_CONSTANT:
                case CHARACTER_CONSTANT:
                case STRING_CONSTANT:
                case ID:
                case FLOAT_CONSTANT_BASIC:
                case FLOATING_CONSTANT:
                  parsePostfixExpression();
                  break;
                default:
                  jj_la1[190] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
              }
              break;
            default:
              jj_la1[191] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[192] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[193] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void parseUnaryOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case AMPERSAND:
      jj_consume_token(AMPERSAND);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    case NOT:
      jj_consume_token(NOT);
      break;
    case TILDE:
      jj_consume_token(TILDE);
      break;
    default:
      jj_la1[194] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseAllocationExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[195] = jj_gen;
      ;
    }
    jj_consume_token(NEW);
    if (jj_2_48(2147483647)) {
      parsePlacement();
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseNewTypeName();
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      parseTypeName();
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[196] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      parseNewInitializer();
      break;
    default:
      jj_la1[197] = jj_gen;
      ;
    }

  }

  static final public void parsePlacement() throws ParseException {
    jj_consume_token(OPEN_PAREN);
    parseExpressionList();
    jj_consume_token(CLOSE_PAREN);

  }

  static final public void parseNewTypeName() throws ParseException {
    parseTypeSpecifier();
    if (jj_2_50(2147483647)) {
      parseNewDeclarator();
    } else {
      if (jj_2_49(2147483647)) {
        parseNewTypeName();
      } else {
        ;
      }
    }

  }

  static final public void parseNewDeclarator_Subpart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseCompleteClassName();
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[198] = jj_gen;
      ;
    }
    jj_consume_token(ASTERISK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
    case VOLATILE:
      parseCvQualifierList();
      break;
    default:
      jj_la1[199] = jj_gen;
      ;
    }

  }

  static final public void parseNewDeclarator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ASTERISK:
    case ID:
      label_39:
      while (true) {
        parseNewDeclarator_Subpart();
        if (jj_2_51(2147483647)) {
          ;
        } else {
          break label_39;
        }
      }
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
          ;
          break;
        default:
          jj_la1[200] = jj_gen;
          break label_40;
        }
        jj_consume_token(OPEN_BRACKET);
        parseExpression();
        jj_consume_token(CLOSE_BRACKET);
      }
      break;
    case OPEN_BRACKET:
      label_41:
      while (true) {
        jj_consume_token(OPEN_BRACKET);
        parseExpression();
        jj_consume_token(CLOSE_BRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
          ;
          break;
        default:
          jj_la1[201] = jj_gen;
          break label_41;
        }
      }
      break;
    default:
      jj_la1[202] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseNewInitializer() throws ParseException {
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case OPEN_BRACE:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      parseInitializerList();
      break;
    default:
      jj_la1[203] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_PAREN);

  }

  static final public void parseDeallocationExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[204] = jj_gen;
      ;
    }
    jj_consume_token(DELETE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      jj_consume_token(CLOSE_BRACKET);
      break;
    default:
      jj_la1[205] = jj_gen;
      ;
    }
    parseCastExpression();

  }

  static final public void parsePostfixExpression_internalSimpleTypeNameBit() throws ParseException {
    parseSimpleTypeName();
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      parseExpressionList();
      break;
    default:
      jj_la1[206] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_PAREN);

  }

  static final public void parsePostfixExpression() throws ParseException {
    if (jj_2_52(2147483647)) {
      parsePostfixExpression_internalSimpleTypeNameBit();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case SCOPE:
      case OPEN_PAREN:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parsePrimaryExpression();
        break;
      default:
        jj_la1[207] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEREFERENCE:
      case INCREMENT:
      case DECREMENT:
      case OPEN_PAREN:
      case OPEN_BRACKET:
      case PERIOD:
        ;
        break;
      default:
        jj_la1[208] = jj_gen;
        break label_42;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        parseExpression();
        jj_consume_token(CLOSE_BRACKET);
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseExpressionList();
          break;
        default:
          jj_la1[209] = jj_gen;
          ;
        }
        jj_consume_token(CLOSE_PAREN);
        break;
      case PERIOD:
        jj_consume_token(PERIOD);
        parseName();
        break;
      case DEREFERENCE:
        jj_consume_token(DEREFERENCE);
        parseName();
        break;
      case INCREMENT:
        jj_consume_token(INCREMENT);
        break;
      case DECREMENT:
        jj_consume_token(DECREMENT);
        break;
      default:
        jj_la1[210] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseExpressionList() throws ParseException {
    parseAssignmentExpression();
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[211] = jj_gen;
        break label_43;
      }
      jj_consume_token(COMMA);
      parseAssignmentExpression();
    }

  }

  static final public String parseTdlRefTaskName() throws ParseException {
  Token    token;
  String   taskName;
    jj_consume_token(TDL_REF);
            /* <TDL_REF> matches regardless of case and underscores. *
	     * We want uppercaes only.                               */
          getToken ( 0 ) . image = "TDL_REF";
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS_CS:
    case THIS_CI:
    case PARENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARENT:
        jj_consume_token(PARENT);
                   System.err.println (
                                    TDLParser.getFilenameWithoutPathPlusColon()
                                    + ( getToken( 0 ) . beginLine + 1 )
                                    + TDLParser.PARENT_WARNING );
        break;
      case THIS_CS:
        jj_consume_token(THIS_CS);
        break;
      case THIS_CI:
        jj_consume_token(THIS_CI);
        break;
      default:
        jj_la1[212] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  /* We want uppercase "THIS" only. */
               getToken ( 0 ) . image = "THIS";
               taskName = "THIS";
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      token = parseIdToken();
               taskName = token.image;
      break;
    default:
      jj_la1[213] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSE_PAREN);
      {if (true) return taskName;}
    throw new Error("Missing return statement in function");
  }

  static final public void parsePrimaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      if (jj_2_54(2147483647)) {
        parseLiteral();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          if (jj_2_53(2147483647)) {
            parseName();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              parseLiteral();
              break;
            default:
              jj_la1[214] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[215] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case SCOPE:
      jj_consume_token(SCOPE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
        parseOperatorFunctionName();
        break;
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case ID:
        if (jj_2_55(2147483647)) {
          parseQualifiedName();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TASK:
          case GOAL:
          case COMMAND:
          case MONITOR:
          case EXCEPTION:
          case HANDLER:
          case RESUME:
          case HANDLES:
          case FIRST:
          case DISTRIBUTED:
          case THREADED:
          case NAME:
          case ID:
            parseIdToken();
            break;
          default:
            jj_la1[216] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[217] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      parseExpression();
      jj_consume_token(CLOSE_PAREN);
      break;
    case TRIGGER:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRIGGER:
        jj_consume_token(TRIGGER);
                   /* Trigger can only be used inside Monitors! */
                if ( getIsParsingMonitorBody() != true )
                {
                  {if (true) throw generateParseException ( getToken ( 0 ),
                        "Encountered TRIGGER in a non-Monitor Task." );}
                }
                   /* <TRIGGER> matches regardless of case. *
		    *  We want uppercase only.              */
                getToken ( 0 ) . image = "TRIGGER";
        jj_consume_token(OPEN_PAREN);
        jj_consume_token(CLOSE_PAREN);
        break;
      case TDL_REF:
        parseTdlRefTaskName();
        break;
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GET_NUMBER_OF_TRIGGERS:
          jj_consume_token(GET_NUMBER_OF_TRIGGERS);
          break;
        case GET_NUMBER_OF_ACTIVATES:
          jj_consume_token(GET_NUMBER_OF_ACTIVATES);
          break;
        default:
          jj_la1[218] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                   /* These can only be used inside Monitors! */
                if ( getIsParsingMonitorBody() != true )
                {
                  {if (true) throw generateParseException ( getToken ( 0 ),
                              "Encountered " + getToken ( 0 ) . image
                            + "() in a non-Monitor Task." );}
                }
                   /* These match regardless of case.      *
		    * We want these specific strings only. */
                if      ( getToken ( 0 ) . kind == GET_NUMBER_OF_TRIGGERS  )
                  getToken ( 0 ) . image = "getNumberOfTriggers";
                else if ( getToken ( 0 ) . kind == GET_NUMBER_OF_ACTIVATES )
                  getToken ( 0 ) . image = "getNumberOfActivates";
        jj_consume_token(OPEN_PAREN);
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[219] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[220] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/*
 * Used as a hack to avoid declaring Operator() and Conversion functions
 * inside classes inside TDL code.
 */
  static final public void parseName_WithoutOperatorOrConversionFunctionNames() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      if (jj_2_56(2147483647)) {
        parseQualifiedName();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case ID:
          parseIdToken();
          break;
        default:
          jj_la1[221] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case TILDE:
      jj_consume_token(TILDE);
      parseClassName();
      break;
    default:
      jj_la1[222] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TILDE:
    case ID:
      parseName_WithoutOperatorOrConversionFunctionNames();
      break;
    case OPERATOR:
      if (jj_2_57(2147483647)) {
        parseOperatorFunctionName();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERATOR:
          parseConversionFunctionName();
          break;
        default:
          jj_la1[223] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[224] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseQualifiedName() throws ParseException {
    parseClassName();
    jj_consume_token(SCOPE);
    parseName();

  }

  static final public void parseLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_CONSTANT:
      jj_consume_token(INTEGER_CONSTANT);
      break;
    case FLOAT_CONSTANT_BASIC:
      jj_consume_token(FLOAT_CONSTANT_BASIC);
      break;
    case FLOATING_CONSTANT:
      jj_consume_token(FLOATING_CONSTANT);
      break;
    case CHARACTER_CONSTANT:
      jj_consume_token(CHARACTER_CONSTANT);
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case STRING_CONSTANT:
    case ID:
      parseStringConstantAndIdsAssumingTheyAreMacros();
      break;
    default:
      jj_la1[225] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/*******************************/
/***  Declaration parsing..  ***/
/*******************************/
  static final public void parseDeclaration_Subpart() throws ParseException {
    if (jj_2_58(2147483647)) {
      parseDeclaratorList();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case SEMICOLON:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        case FRIEND:
        case TYPEDEF:
        case AUTO:
        case REGISTER:
        case INLINE:
        case CONST:
        case VOLATILE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case CLASS:
        case STRUCT:
        case UNION:
        case ENUM:
        case EXTERN_CS:
        case STATIC_CS:
        case VIRTUAL_CS:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case SCOPE:
        case ID:
          parseDeclSpecifier();
          parseDeclaration_Subpart();
          break;
        default:
          jj_la1[226] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[227] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case OPERATOR:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case OPEN_PAREN:
    case SEMICOLON:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case ID:
      if (jj_2_59(2147483647)) {
        parseLinkageSpecification();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FRIEND:
        case TYPEDEF:
        case AUTO:
        case REGISTER:
        case INLINE:
        case CONST:
        case VOLATILE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case CLASS:
        case STRUCT:
        case UNION:
        case ENUM:
        case OPERATOR:
        case EXTERN_CS:
        case STATIC_CS:
        case VIRTUAL_CS:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case SCOPE:
        case OPEN_PAREN:
        case SEMICOLON:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case ID:
          parseDeclaration_Subpart();
          break;
        default:
          jj_la1[228] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case ASM:
      parseAsmDeclaration();
      break;
    default:
      jj_la1[229] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseDeclSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
    case REGISTER:
    case EXTERN_CS:
    case STATIC_CS:
      parseStorageClassSpecifier();
      break;
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseTypeSpecifier();
      break;
    case INLINE:
    case VIRTUAL_CS:
      parseFctSpecifier();
      break;
    case FRIEND:
      jj_consume_token(FRIEND);
      break;
    case TYPEDEF:
      jj_consume_token(TYPEDEF);
      break;
    default:
      jj_la1[230] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseDeclSpecifiers() throws ParseException {
    label_44:
    while (true) {
      parseDeclSpecifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        ;
        break;
      default:
        jj_la1[231] = jj_gen;
        break label_44;
      }
    }

  }

  static final public void parseStorageClassSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
      jj_consume_token(AUTO);
      break;
    case REGISTER:
      jj_consume_token(REGISTER);
      break;
    case STATIC_CS:
      jj_consume_token(STATIC_CS);
      break;
    case EXTERN_CS:
      jj_consume_token(EXTERN_CS);
      break;
    default:
      jj_la1[232] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseFctSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INLINE:
      jj_consume_token(INLINE);
      break;
    case VIRTUAL_CS:
      jj_consume_token(VIRTUAL_CS);
      break;
    default:
      jj_la1[233] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseTypeSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseSimpleTypeName();
      break;
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
      if (jj_2_61(2147483647)) {
        parseEnumSpecifier();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case STRUCT:
        case UNION:
        case ENUM:
          if (jj_2_60(2147483647)) {
            parseClassSpecifier();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CLASS:
            case STRUCT:
            case UNION:
            case ENUM:
              parseElaboratedTypeSpecifier();
              break;
            default:
              jj_la1[234] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[235] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case CONST:
      jj_consume_token(CONST);
      break;
    case VOLATILE:
      jj_consume_token(VOLATILE);
      break;
    default:
      jj_la1[236] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseSimpleTypeName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      if (jj_2_62(2147483647)) {
        parseCompleteClassName();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case ID:
          parseQualifiedTypeName();
          break;
        default:
          jj_la1[237] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case CHAR:
      jj_consume_token(CHAR);
      break;
    case SHORT:
      jj_consume_token(SHORT);
      break;
    case INT:
      jj_consume_token(INT);
      break;
    case LONG:
      jj_consume_token(LONG);
      break;
    case SIGNED:
      jj_consume_token(SIGNED);
      break;
    case UNSIGNED:
      jj_consume_token(UNSIGNED);
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      break;
    case VOID:
      jj_consume_token(VOID);
      break;
    default:
      jj_la1[238] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseElaboratedTypeSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
    case STRUCT:
    case UNION:
      parseClassKey();
      parseClassName();
      break;
    case ENUM:
      jj_consume_token(ENUM);
      parseEnumName();
      break;
    default:
      jj_la1[239] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseClassKey() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
      break;
    case STRUCT:
      jj_consume_token(STRUCT);
      break;
    case UNION:
      jj_consume_token(UNION);
      break;
    default:
      jj_la1[240] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseQualifiedTypeName_Subpart() throws ParseException {
    parseClassName();
    jj_consume_token(SCOPE);

  }

  static final public void parseQualifiedTypeName() throws ParseException {
    label_45:
    while (true) {
      if (jj_2_63(2147483647)) {
        ;
      } else {
        break label_45;
      }
      parseQualifiedTypeName_Subpart();
    }
    parseTypedefName();

  }

  static final public void parseCompleteClassName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[241] = jj_gen;
      ;
    }
    parseQualifiedClassName();

  }

  static final public void parseQualifiedClassName_LeaveTrailingScope() throws ParseException {
    parseClassName();
    label_46:
    while (true) {
      if (jj_2_64(2147483647)) {
        ;
      } else {
        break label_46;
      }
      jj_consume_token(SCOPE);
      parseClassName();
    }

  }

  static final public void parseQualifiedClassName() throws ParseException {
    parseClassName();
    label_47:
    while (true) {
      if (jj_2_65(2147483647)) {
        ;
      } else {
        break label_47;
      }
      jj_consume_token(SCOPE);
      parseClassName();
    }

  }

  static final public void parseEnumSpecifier() throws ParseException {
    jj_consume_token(ENUM);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseIdToken();
      break;
    default:
      jj_la1[242] = jj_gen;
      ;
    }
    jj_consume_token(OPEN_BRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseEnumList();
      break;
    default:
      jj_la1[243] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACE);

  }

  static final public void parseEnumList() throws ParseException {
    parseEnumerator();
    label_48:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[244] = jj_gen;
        break label_48;
      }
      jj_consume_token(COMMA);
      parseEnumerator();
    }

  }

  static final public void parseEnumerator() throws ParseException {
    parseIdToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      parseConstantExpression();
      break;
    default:
      jj_la1[245] = jj_gen;
      ;
    }

  }

  static final public void parseConstantExpression() throws ParseException {
    parseConditionalExpression();
  }

  static final public void parseLinkageSpecification() throws ParseException {
    jj_consume_token(EXTERN_CS);
    jj_consume_token(STRING_CONSTANT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACE:
      jj_consume_token(OPEN_BRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case ASM:
      case OPERATOR:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case ID:
        parseDeclarationList();
        break;
      default:
        jj_la1[246] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACE);
      break;
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case ASM:
    case OPERATOR:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case OPEN_PAREN:
    case SEMICOLON:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case ID:
      parseDeclaration();
      break;
    default:
      jj_la1[247] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseDeclarationList() throws ParseException {
    label_49:
    while (true) {
      parseDeclaration();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case ASM:
      case OPERATOR:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case ID:
        ;
        break;
      default:
        jj_la1[248] = jj_gen;
        break label_49;
      }
    }

  }

  static final public void parseAsmDeclaration() throws ParseException {
    jj_consume_token(ASM);
    jj_consume_token(OPEN_PAREN);
    parseStringConstantAndIdsAssumingTheyAreMacros();
    jj_consume_token(CLOSE_PAREN);
    jj_consume_token(SEMICOLON);

  }

/*******************************/
/***  Declarators parsing..  ***/
/*******************************/
  static final public void parseDeclaratorList() throws ParseException {
    parseInitDeclarator();
    label_50:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[249] = jj_gen;
        break label_50;
      }
      jj_consume_token(COMMA);
      parseInitDeclarator();
    }

  }

  static final public void parseInitDeclarator() throws ParseException {
    parseDeclarator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case OPEN_PAREN:
      parseInitializer();
      break;
    default:
      jj_la1[250] = jj_gen;
      ;
    }

  }

  static final public void parseDeclarator_Subpart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      parseArgumentDeclarationList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case VOLATILE:
        parseCvQualifierList();
        break;
      default:
        jj_la1[251] = jj_gen;
        ;
      }
      break;
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseConstantExpression();
        break;
      default:
        jj_la1[252] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
      break;
    default:
      jj_la1[253] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/*
 * Used as a hack to avoid declaring methods inside classes inside TDL code.
 */
  static final public void parseDeclarator_WithoutFunctions() throws ParseException {
    label_51:
    while (true) {
      if (jj_2_66(2147483647)) {
        ;
      } else {
        break label_51;
      }
      parsePtrOperator();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TILDE:
    case ID:
      parseDname_WithoutOperatorOrConversionFunctionNames();
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      parseDeclarator();
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[254] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_52:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        ;
        break;
      default:
        jj_la1[255] = jj_gen;
        break label_52;
      }
      jj_consume_token(OPEN_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseConstantExpression();
        break;
      default:
        jj_la1[256] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
    }

  }

  static final public void parseDeclarator() throws ParseException {
    label_53:
    while (true) {
      if (jj_2_67(2147483647)) {
        ;
      } else {
        break label_53;
      }
      parsePtrOperator();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TILDE:
    case ID:
      parseDname();
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      parseDeclarator();
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[257] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_54:
    while (true) {
      if (jj_2_68(2147483647)) {
        ;
      } else {
        break label_54;
      }
      parseDeclarator_Subpart();
    }

  }

  static final public void parsePtrOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case AMPERSAND:
      jj_consume_token(AMPERSAND);
      break;
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseCompleteClassName();
      jj_consume_token(SCOPE);
      jj_consume_token(ASTERISK);
      break;
    default:
      jj_la1[258] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
    case VOLATILE:
      parseCvQualifierList();
      break;
    default:
      jj_la1[259] = jj_gen;
      ;
    }

  }

  static final public void parseCvQualifierList() throws ParseException {
    label_55:
    while (true) {
      parseCvQualifer();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[260] = jj_gen;
        break label_55;
      }
    }

  }

  static final public void parseCvQualifer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      jj_consume_token(CONST);
      break;
    case VOLATILE:
      jj_consume_token(VOLATILE);
      break;
    default:
      jj_la1[261] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/*
 * Used as a hack to avoid declaring Operator() and Conversion functions
 * inside classes inside TDL code.
 */
  static final public void parseDname_WithoutOperatorOrConversionFunctionNames() throws ParseException {
    if (jj_2_70(2147483647)) {
      parseQualifiedTypeName();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TILDE:
      case ID:
        if (jj_2_69(2147483647)) {
          parseClassName();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TASK:
          case GOAL:
          case COMMAND:
          case MONITOR:
          case EXCEPTION:
          case HANDLER:
          case RESUME:
          case HANDLES:
          case FIRST:
          case DISTRIBUTED:
          case THREADED:
          case NAME:
          case TILDE:
          case ID:
            parseName_WithoutOperatorOrConversionFunctionNames();
            break;
          default:
            jj_la1[262] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[263] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseDname() throws ParseException {
    if (jj_2_72(2147483647)) {
      parseQualifiedTypeName();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TILDE:
      case ID:
        if (jj_2_71(2147483647)) {
          parseClassName();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPERATOR:
          case TASK:
          case GOAL:
          case COMMAND:
          case MONITOR:
          case EXCEPTION:
          case HANDLER:
          case RESUME:
          case HANDLES:
          case FIRST:
          case DISTRIBUTED:
          case THREADED:
          case NAME:
          case TILDE:
          case ID:
            parseName();
            break;
          default:
            jj_la1[264] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[265] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseTypeName() throws ParseException {
    parseTypeSpecifier();
    if (jj_2_74(2147483647)) {
      parseAbstractDeclarator();
    } else {
      if (jj_2_73(2147483647)) {
        parseTypeName();
      } else {
        ;
      }
    }

  }

  static final public void parseTypeSpecifierList() throws ParseException {
    label_56:
    while (true) {
      parseTypeSpecifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        ;
        break;
      default:
        jj_la1[266] = jj_gen;
        break label_56;
      }
    }

  }

  static final public void parseAbstractDeclarator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case AMPERSAND:
    case ASTERISK:
    case ID:
      label_57:
      while (true) {
        parsePtrOperator();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case SCOPE:
        case AMPERSAND:
        case ASTERISK:
        case ID:
          ;
          break;
        default:
          jj_la1[267] = jj_gen;
          break label_57;
        }
      }
      if (jj_2_75(2147483647)) {
        jj_consume_token(OPEN_PAREN);
        parseAbstractDeclarator();
        jj_consume_token(CLOSE_PAREN);
      } else {
        ;
      }
      label_58:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
        case OPEN_BRACKET:
          ;
          break;
        default:
          jj_la1[268] = jj_gen;
          break label_58;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
          parseArgumentDeclarationList();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
          case VOLATILE:
            parseCvQualifierList();
            break;
          default:
            jj_la1[269] = jj_gen;
            ;
          }
          break;
        case OPEN_BRACKET:
          jj_consume_token(OPEN_BRACKET);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SIZEOF:
          case NEW:
          case DELETE:
          case CHAR:
          case SHORT:
          case INT:
          case LONG:
          case SIGNED:
          case UNSIGNED:
          case FLOAT:
          case DOUBLE:
          case VOID:
          case OPERATOR:
          case TASK:
          case GOAL:
          case COMMAND:
          case MONITOR:
          case EXCEPTION:
          case HANDLER:
          case RESUME:
          case HANDLES:
          case FIRST:
          case TRIGGER:
          case DISTRIBUTED:
          case THREADED:
          case NAME:
          case TDL_REF:
          case GET_NUMBER_OF_TRIGGERS:
          case GET_NUMBER_OF_ACTIVATES:
          case NOT:
          case PLUS:
          case MINUS:
          case INCREMENT:
          case DECREMENT:
          case SCOPE:
          case OPEN_PAREN:
          case AMPERSAND:
          case ASTERISK:
          case TILDE:
          case INTEGER_CONSTANT:
          case CHARACTER_CONSTANT:
          case STRING_CONSTANT:
          case ID:
          case FLOAT_CONSTANT_BASIC:
          case FLOATING_CONSTANT:
            parseConstantExpression();
            break;
          default:
            jj_la1[270] = jj_gen;
            ;
          }
          jj_consume_token(CLOSE_BRACKET);
          break;
        default:
          jj_la1[271] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case OPEN_PAREN:
    case OPEN_BRACKET:
      if (jj_2_76(2147483647)) {
        jj_consume_token(OPEN_PAREN);
        parseAbstractDeclarator();
        jj_consume_token(CLOSE_PAREN);
        label_59:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPEN_PAREN:
          case OPEN_BRACKET:
            ;
            break;
          default:
            jj_la1[272] = jj_gen;
            break label_59;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPEN_PAREN:
            parseArgumentDeclarationList();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CONST:
            case VOLATILE:
              parseCvQualifierList();
              break;
            default:
              jj_la1[273] = jj_gen;
              ;
            }
            break;
          case OPEN_BRACKET:
            jj_consume_token(OPEN_BRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SIZEOF:
            case NEW:
            case DELETE:
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case OPERATOR:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case INCREMENT:
            case DECREMENT:
            case SCOPE:
            case OPEN_PAREN:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              parseConstantExpression();
              break;
            default:
              jj_la1[274] = jj_gen;
              ;
            }
            jj_consume_token(CLOSE_BRACKET);
            break;
          default:
            jj_la1[275] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
        case OPEN_BRACKET:
          label_60:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case OPEN_PAREN:
              parseArgumentDeclarationList();
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case CONST:
              case VOLATILE:
                parseCvQualifierList();
                break;
              default:
                jj_la1[276] = jj_gen;
                ;
              }
              break;
            case OPEN_BRACKET:
              jj_consume_token(OPEN_BRACKET);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case SIZEOF:
              case NEW:
              case DELETE:
              case CHAR:
              case SHORT:
              case INT:
              case LONG:
              case SIGNED:
              case UNSIGNED:
              case FLOAT:
              case DOUBLE:
              case VOID:
              case OPERATOR:
              case TASK:
              case GOAL:
              case COMMAND:
              case MONITOR:
              case EXCEPTION:
              case HANDLER:
              case RESUME:
              case HANDLES:
              case FIRST:
              case TRIGGER:
              case DISTRIBUTED:
              case THREADED:
              case NAME:
              case TDL_REF:
              case GET_NUMBER_OF_TRIGGERS:
              case GET_NUMBER_OF_ACTIVATES:
              case NOT:
              case PLUS:
              case MINUS:
              case INCREMENT:
              case DECREMENT:
              case SCOPE:
              case OPEN_PAREN:
              case AMPERSAND:
              case ASTERISK:
              case TILDE:
              case INTEGER_CONSTANT:
              case CHARACTER_CONSTANT:
              case STRING_CONSTANT:
              case ID:
              case FLOAT_CONSTANT_BASIC:
              case FLOATING_CONSTANT:
                parseConstantExpression();
                break;
              default:
                jj_la1[277] = jj_gen;
                ;
              }
              jj_consume_token(CLOSE_BRACKET);
              break;
            default:
              jj_la1[278] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case OPEN_PAREN:
            case OPEN_BRACKET:
              ;
              break;
            default:
              jj_la1[279] = jj_gen;
              break label_60;
            }
          }
          break;
        default:
          jj_la1[280] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[281] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseArgumentDeclarationList_Subpart() throws ParseException {
    parseArgDeclarationList_AndTrailingToken();

  }

  static final public void parseArgumentDeclarationList() throws ParseException {
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case ID:
      parseArgumentDeclarationList_Subpart();
      break;
    case CLOSE_PAREN:
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[282] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseArgDeclarationList_AndTrailingToken() throws ParseException {
    label_61:
    while (true) {
      if (jj_2_77(2147483647)) {
        ;
      } else {
        break label_61;
      }
      parseArgumentDeclaration_AndTrailing_Comma();
    }
    parseArgumentDeclaration_AndTrailing_CloseParen();

  }

  static final public void parseArgumentDeclaration_Subpart() throws ParseException {
    if (jj_2_78(2147483647)) {
      parseDeclarator();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case OPEN_BRACKET:
      case AMPERSAND:
      case ASTERISK:
      case ID:
        parseAbstractDeclarator();
        break;
      default:
        jj_la1[283] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      parseAssignmentExpression();
      break;
    default:
      jj_la1[284] = jj_gen;
      ;
    }

  }

  static final public void parseArgumentDeclaration_AndTrailing_Comma() throws ParseException {
    parseDeclSpecifier();
    if (jj_2_79(2147483647)) {
      parseArgumentDeclaration_Subpart();
      jj_consume_token(COMMA);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        parseArgumentDeclaration_AndTrailing_Comma();
        break;
      default:
        jj_la1[285] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseArgumentDeclaration_AndTrailing_CloseParen() throws ParseException {
    parseDeclSpecifier();
    if (jj_2_80(2147483647)) {
      parseArgumentDeclaration_Subpart();
      jj_consume_token(CLOSE_PAREN);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case ID:
        parseArgumentDeclaration_AndTrailing_CloseParen();
        break;
      default:
        jj_la1[286] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

        /* No Functions inside TDL code... */
// void
// parseFunctionDefinition ( ) :
// {}
// {
//   (
//     [ parseDeclSpecifiers() ]
//     parseDeclarator()
//     [ parseCtorInitializer() ]
//     parseFctBody()
//   )
//     {}
// }

        /* No Functions inside TDL code... */
// void
// parseFctBody ( ) :
// {}
// {
//   (
//     parseCompoundStatement()
//   )
//     {}
// }
  static final public void parseInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseAssignmentExpression();
        break;
      case OPEN_BRACE:
        jj_consume_token(OPEN_BRACE);
        parseInitializerList();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[287] = jj_gen;
          ;
        }
        jj_consume_token(CLOSE_BRACE);
        break;
      default:
        jj_la1[288] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      parseExpressionList();
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[289] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseInitializerList_Subpart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      parseAssignmentExpression();
      break;
    case OPEN_BRACE:
      jj_consume_token(OPEN_BRACE);
      parseInitializerList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[290] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACE);
      break;
    default:
      jj_la1[291] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseInitializerList() throws ParseException {
    parseInitializerList_Subpart();
    label_62:
    while (true) {
      if (jj_2_81(2147483647)) {
        ;
      } else {
        break label_62;
      }
      jj_consume_token(COMMA);
      parseInitializerList_Subpart();
    }

  }

/**************************************/
/***  Class Declarations Parsing..  ***/
/**************************************/
  static final public void parseClassSpecifier() throws ParseException {
    parseClassHead();
    jj_consume_token(OPEN_BRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case OPEN_PAREN:
    case SEMICOLON:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case COLON:
    case ID:
      parseMembersList();
      break;
    default:
      jj_la1[292] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACE);

  }

  static final public void parseClassHead() throws ParseException {
    parseClassKey();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseClassName();
      break;
    default:
      jj_la1[293] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      parseBaseSpec();
      break;
    default:
      jj_la1[294] = jj_gen;
      ;
    }

  }

  static final public void parseMembersList() throws ParseException {
    label_63:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case COLON:
      case ID:
        parseMemeberDeclaration();
        break;
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
        parseAccessSpecifier();
        jj_consume_token(COLON);
        break;
      default:
        jj_la1[295] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case COLON:
      case ID:
        ;
        break;
      default:
        jj_la1[296] = jj_gen;
        break label_63;
      }
    }

  }

  static final public void parseMemeberDeclaration_Subpart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case FRIEND:
    case TYPEDEF:
    case AUTO:
    case REGISTER:
    case INLINE:
    case CONST:
    case VOLATILE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case CLASS:
    case STRUCT:
    case UNION:
    case ENUM:
    case EXTERN_CS:
    case STATIC_CS:
    case VIRTUAL_CS:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case COLON:
    case ID:
      if (jj_2_82(2147483647)) {
        parseMemberDeclaratorList();
        jj_consume_token(SEMICOLON);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FRIEND:
        case TYPEDEF:
        case AUTO:
        case REGISTER:
        case INLINE:
        case CONST:
        case VOLATILE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case CLASS:
        case STRUCT:
        case UNION:
        case ENUM:
        case EXTERN_CS:
        case STATIC_CS:
        case VIRTUAL_CS:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case SCOPE:
        case ID:
          parseDeclSpecifier();
          parseMemeberDeclaration_Subpart();
          break;
        default:
          jj_la1[297] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[298] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseMemeberDeclaration() throws ParseException {
    if (jj_2_83(2147483647)) {
      parseQualifiedName();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRIEND:
      case TYPEDEF:
      case AUTO:
      case REGISTER:
      case INLINE:
      case CONST:
      case VOLATILE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case CLASS:
      case STRUCT:
      case UNION:
      case ENUM:
      case EXTERN_CS:
      case STATIC_CS:
      case VIRTUAL_CS:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case SEMICOLON:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case COLON:
      case ID:
        parseMemeberDeclaration_Subpart();
        break;
      default:
        jj_la1[299] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseMemberDeclaratorList() throws ParseException {
    parseMemberDeclarator();
    label_64:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[300] = jj_gen;
        break label_64;
      }
      jj_consume_token(COMMA);
      parseMemberDeclarator();
    }

  }

  static final public void parseMemberDeclarator_Subpart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case ID:
      parseIdToken();
      break;
    default:
      jj_la1[301] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    parseConstantExpression();

  }

  static final public void parseMemberDeclarator() throws ParseException {
    if (jj_2_84(2147483647)) {
      parseMemberDeclarator_Subpart();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case ID:
        parseDeclarator_WithoutFunctions();
        break;
      default:
        jj_la1[302] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

        /* I'll disallow this since it could only be used for a pure-virtual
	 * FUNCTION (method), which are disallowed in TDL
	 */
// void
// parsePureSpecifier ( ) :
// {}
// {
//   (
// 	/* Zero is an INTEGER_CONSTANT, so this may bomb.
// 	 * But then again, we should never have pure virtual methods
// 	 * inside TDL code to begin with...
// 	 *
// 	 * (But it's too much trouble to dike them out...)
// 	 */
//     <EQUAL>  "0" //<ZERO>
//   )
//     {}
// }
  static final public void parseBaseSpec() throws ParseException {
    jj_consume_token(COLON);
    parseBaseList();

  }

  static final public void parseBaseList() throws ParseException {
    parseBaseSpecifier();
    label_65:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[303] = jj_gen;
        break label_65;
      }
      jj_consume_token(COMMA);
      parseBaseSpecifier();
    }

  }

  static final public void parseBaseSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case VIRTUAL_CS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRTUAL_CS:
        jj_consume_token(VIRTUAL_CS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
          parseAccessSpecifier();
          break;
        default:
          jj_la1[304] = jj_gen;
          ;
        }
        break;
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
        parseAccessSpecifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VIRTUAL_CS:
          jj_consume_token(VIRTUAL_CS);
          break;
        default:
          jj_la1[305] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[306] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[307] = jj_gen;
      ;
    }
    parseCompleteClassName();

  }

  static final public void parseAccessSpecifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      jj_consume_token(PRIVATE);
      break;
    case PROTECTED:
      jj_consume_token(PROTECTED);
      break;
    case PUBLIC:
      jj_consume_token(PUBLIC);
      break;
    default:
      jj_la1[308] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final public void parseConversionFunctionName() throws ParseException {
    jj_consume_token(OPERATOR);
    parseConversionTypeName();

  }

  static final public void parseConversionTypeName() throws ParseException {
    parseTypeSpecifier();
    if (jj_2_86(2147483647)) {
      parsePtrOperator();
    } else {
      if (jj_2_85(2147483647)) {
        parseConversionTypeName();
      } else {
        ;
      }
    }

  }

  static final public void parseCtorInitializer() throws ParseException {
    jj_consume_token(COLON);
    parseMemInitializerList();

  }

  static final public void parseMemInitializerList() throws ParseException {
    parseMemInitializer();
    label_66:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[309] = jj_gen;
        break label_66;
      }
      jj_consume_token(COMMA);
      parseMemInitializer();
    }

  }

  static final public void parseMemInitializer() throws ParseException {
    parseCompleteClassName();
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIZEOF:
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case INCREMENT:
    case DECREMENT:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      parseExpressionList();
      break;
    default:
      jj_la1[310] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_PAREN);

  }

  static final public void parseOperatorFunctionName() throws ParseException {
    jj_consume_token(OPERATOR);
    parseOperator();

  }

  static final public void parseOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEW:
      jj_consume_token(NEW);
      break;
    case DELETE:
      jj_consume_token(DELETE);
      break;
    case PLUS:
      jj_consume_token(PLUS);
      break;
    case MINUS:
      jj_consume_token(MINUS);
      break;
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case DIVIDE:
      jj_consume_token(DIVIDE);
      break;
    case MODULO:
      jj_consume_token(MODULO);
      break;
    case EXCLUSIVE_OR:
      jj_consume_token(EXCLUSIVE_OR);
      break;
    case AMPERSAND:
      jj_consume_token(AMPERSAND);
      break;
    case INCLUSIVE_OR:
      jj_consume_token(INCLUSIVE_OR);
      break;
    case TILDE:
      jj_consume_token(TILDE);
      break;
    case NOT:
      jj_consume_token(NOT);
      break;
    case EQUAL:
      jj_consume_token(EQUAL);
      break;
    case LESS_THAN:
      jj_consume_token(LESS_THAN);
      break;
    case GREATER_THAN:
      jj_consume_token(GREATER_THAN);
      break;
    case PLUS_EQUAL:
      jj_consume_token(PLUS_EQUAL);
      break;
    case MINUS_EQUAL:
      jj_consume_token(MINUS_EQUAL);
      break;
    case MULTIPLY_EQUAL:
      jj_consume_token(MULTIPLY_EQUAL);
      break;
    case DIVIDE_EQUAL:
      jj_consume_token(DIVIDE_EQUAL);
      break;
    case MODULO_EQUAL:
      jj_consume_token(MODULO_EQUAL);
      break;
    case XOR_EQUAL:
      jj_consume_token(XOR_EQUAL);
      break;
    case AND_EQUAL:
      jj_consume_token(AND_EQUAL);
      break;
    case OR_EQUAL:
      jj_consume_token(OR_EQUAL);
      break;
    case LEFT_SHIFT:
      jj_consume_token(LEFT_SHIFT);
      break;
    case RIGHT_SHIFT:
      jj_consume_token(RIGHT_SHIFT);
      break;
    case LEFTSHIFT_EQUAL:
      jj_consume_token(LEFTSHIFT_EQUAL);
      break;
    case RIGHTSHIFT_EQUAL:
      jj_consume_token(RIGHTSHIFT_EQUAL);
      break;
    case EQUALITY:
      jj_consume_token(EQUALITY);
      break;
    case INEQUALITY:
      jj_consume_token(INEQUALITY);
      break;
    case LESS_THAN_OR_EQUALS:
      jj_consume_token(LESS_THAN_OR_EQUALS);
      break;
    case GREATER_THAN_OR_EQUALS:
      jj_consume_token(GREATER_THAN_OR_EQUALS);
      break;
    case LOGICAL_AND:
      jj_consume_token(LOGICAL_AND);
      break;
    case LOGICAL_OR:
      jj_consume_token(LOGICAL_OR);
      break;
    case INCREMENT:
      jj_consume_token(INCREMENT);
      break;
    case DECREMENT:
      jj_consume_token(DECREMENT);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    case POINTER_TO_MEMBER_DEREFERENCE:
      jj_consume_token(POINTER_TO_MEMBER_DEREFERENCE);
      break;
    case DEREFERENCE:
      jj_consume_token(DEREFERENCE);
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      jj_consume_token(CLOSE_PAREN);
      break;
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      jj_consume_token(CLOSE_BRACKET);
      break;
    default:
      jj_la1[311] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

/*************************/
/***  Template parsing ***/
/*************************/


        /* Templates must be declared GLOBAL, and are therefore **NOT**
	 * part of the TDL syntax.
	 */

// void
// parseTemplateDeclaration ( ) :
// {}
// {
//   (
//     <TEMPLATE>  <LESS_THAN>  parseTemplateArgumentList()  <GREATER_THAN>
//     parseDeclaration()
//   )
//     {}
// }


// void
// parseTemplateArgumentList ( ) :
// {}
// {
//   (
//     parseTemplateArgument() ( <COMMA> parseTemplateArgument() ) *
//   )
//     {}
// }


// void
// parseTemplateArgument ( ) :
// {}
// {
//   (
//       parseTypeArgument()
//     | parseArgumentDeclaration()
//   )
//     {}
// }


// void
// parseTypeArgument ( ) :
// {}
// {
//   (
//     <CLASS> parseIdToken()
//   )
//     {}
// }


        /* Of course, TDL code can USE PRE-EXISTING GLOBAL Templated classes */
  static final public void parseTemplateClassName() throws ParseException {
    parseTemplateName();
    jj_consume_token(LESS_THAN);
    if (jj_2_87(2147483647)) {
      parseTypeName();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseRelationalExpression_ExcludingGreaterThan();
        break;
      default:
        jj_la1[312] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_67:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[313] = jj_gen;
        break label_67;
      }
      jj_consume_token(COMMA);
      if (jj_2_88(2147483647)) {
        parseTypeName();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseRelationalExpression_ExcludingGreaterThan();
          break;
        default:
          jj_la1[314] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    jj_consume_token(GREATER_THAN);

  }

        /* Note:  Template Args are dealt with directly up above... */
// void
// parseTemplateArgList ( ) :
// {}
// {
//   (
//     parseTemplateArg()  ( <COMMA> parseTemplateArg() ) *
//   )
//     {}
// }

// void
// parseTemplateArg ( ) :
// {}
// {
//   (
//       parseExpression
//     | parseTypeName()
//   )
//     {}
// }



/**************************/
/*** Note:
 ***       Neither Exception Handling nor preprocessing is included here.
 ***/
/**************************/



/********************************************************************
 ***  For Tasks inside classes, we need a specialized version of  ***
 ***  Expression Parsing that does not include "." or "->".       ***
 ***  Due to JavaCC limitations, we are re-implementing           ***
 ***  Expression Parsing here...                                  ***
 ********************************************************************/
  static final public void parseExpression_NoDereference() throws ParseException {
    parseAssignmentExpression_NoDereference();
    label_68:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[315] = jj_gen;
        break label_68;
      }
      jj_consume_token(COMMA);
      parseAssignmentExpression_NoDereference();
    }

  }

  static final public void parseAssignmentExpression_Subpart_NoDereference() throws ParseException {
    parseUnaryExpression_NoDereference();
    parseAssignmentOperator();
    parseAssignmentExpression_NoDereference();

  }

  static final public void parseAssignmentExpression_NoDereference() throws ParseException {
    if (jj_2_89(2147483647)) {
      parseAssignmentExpression_Subpart_NoDereference();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseConditionalExpression_NoDereference();
        break;
      default:
        jj_la1[316] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

/* AKA:  parseConstantExpression_NoDereference() */
  static final public void parseConditionalExpression_NoDereference() throws ParseException {
    parseLogicalOrExpression_NoDereference();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_MARK:
      jj_consume_token(QUESTION_MARK);
      parseExpression_NoDereference();
      jj_consume_token(COLON);
      parseAssignmentExpression_NoDereference();
      break;
    default:
      jj_la1[317] = jj_gen;
      ;
    }

  }

  static final public void parseLogicalOrExpression_NoDereference() throws ParseException {
    parseLogicalAndExpression_NoDereference();
    label_69:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_OR:
        ;
        break;
      default:
        jj_la1[318] = jj_gen;
        break label_69;
      }
      jj_consume_token(LOGICAL_OR);
      parseLogicalAndExpression_NoDereference();
    }

  }

  static final public void parseLogicalAndExpression_NoDereference() throws ParseException {
    parseInclusiveOrExpression_NoDereference();
    label_70:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_AND:
        ;
        break;
      default:
        jj_la1[319] = jj_gen;
        break label_70;
      }
      jj_consume_token(LOGICAL_AND);
      parseInclusiveOrExpression_NoDereference();
    }

  }

  static final public void parseInclusiveOrExpression_NoDereference() throws ParseException {
    parseExclusiveOrExpression_NoDereference();
    label_71:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCLUSIVE_OR:
        ;
        break;
      default:
        jj_la1[320] = jj_gen;
        break label_71;
      }
      jj_consume_token(INCLUSIVE_OR);
      parseExclusiveOrExpression_NoDereference();
    }

  }

  static final public void parseExclusiveOrExpression_NoDereference() throws ParseException {
    parseAndExpression_NoDereference();
    label_72:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCLUSIVE_OR:
        ;
        break;
      default:
        jj_la1[321] = jj_gen;
        break label_72;
      }
      jj_consume_token(EXCLUSIVE_OR);
      parseAndExpression_NoDereference();
    }

  }

  static final public void parseAndExpression_NoDereference() throws ParseException {
    parseEqualityExpression_NoDereference();
    label_73:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        ;
        break;
      default:
        jj_la1[322] = jj_gen;
        break label_73;
      }
      jj_consume_token(AMPERSAND);
      parseEqualityExpression_NoDereference();
    }

  }

  static final public void parseEqualityExpression_NoDereference() throws ParseException {
    parseRelationalExpression_NoDereference();
    label_74:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALITY:
      case INEQUALITY:
        ;
        break;
      default:
        jj_la1[323] = jj_gen;
        break label_74;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALITY:
        jj_consume_token(EQUALITY);
        break;
      case INEQUALITY:
        jj_consume_token(INEQUALITY);
        break;
      default:
        jj_la1[324] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseRelationalExpression_NoDereference();
    }

  }

  static final public void parseRelationalExpression_NoDereference() throws ParseException {
    parseShiftExpression_NoDereference();
    label_75:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_THAN_OR_EQUALS:
      case GREATER_THAN_OR_EQUALS:
        ;
        break;
      default:
        jj_la1[325] = jj_gen;
        break label_75;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
        jj_consume_token(LESS_THAN);
        break;
      case GREATER_THAN:
        jj_consume_token(GREATER_THAN);
        break;
      case LESS_THAN_OR_EQUALS:
        jj_consume_token(LESS_THAN_OR_EQUALS);
        break;
      case GREATER_THAN_OR_EQUALS:
        jj_consume_token(GREATER_THAN_OR_EQUALS);
        break;
      default:
        jj_la1[326] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseShiftExpression_NoDereference();
    }

  }

  static final public void parseShiftExpression_NoDereference() throws ParseException {
    parseAdditiveExpression_NoDereference();
    label_76:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
      case RIGHT_SHIFT:
        ;
        break;
      default:
        jj_la1[327] = jj_gen;
        break label_76;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
        jj_consume_token(LEFT_SHIFT);
        break;
      case RIGHT_SHIFT:
        jj_consume_token(RIGHT_SHIFT);
        break;
      default:
        jj_la1[328] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseAdditiveExpression_NoDereference();
    }

  }

  static final public void parseAdditiveExpression_NoDereference() throws ParseException {
    parseMultiplicativeExpression_NoDereference();
    label_77:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[329] = jj_gen;
        break label_77;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        break;
      case MINUS:
        jj_consume_token(MINUS);
        break;
      default:
        jj_la1[330] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseMultiplicativeExpression_NoDereference();
    }

  }

  static final public void parseMultiplicativeExpression_NoDereference() throws ParseException {
    parsePointerToMemberExpression_NoDereference();
    label_78:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIVIDE:
      case MODULO:
      case ASTERISK:
        ;
        break;
      default:
        jj_la1[331] = jj_gen;
        break label_78;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        jj_consume_token(DIVIDE);
        break;
      case MODULO:
        jj_consume_token(MODULO);
        break;
      default:
        jj_la1[332] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parsePointerToMemberExpression_NoDereference();
    }

  }

  static final public void parsePointerToMemberExpression_NoDereference() throws ParseException {
    parseCastExpression_NoDereference();
    label_79:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POINTER_TO_MEMBER:
      case POINTER_TO_MEMBER_DEREFERENCE:
        ;
        break;
      default:
        jj_la1[333] = jj_gen;
        break label_79;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POINTER_TO_MEMBER:
        jj_consume_token(POINTER_TO_MEMBER);
        break;
      case POINTER_TO_MEMBER_DEREFERENCE:
        jj_consume_token(POINTER_TO_MEMBER_DEREFERENCE);
        break;
      default:
        jj_la1[334] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      parseCastExpression_NoDereference();
    }

  }

  static final public void parseCastExpression_Subpart_NoDereference() throws ParseException {
    jj_consume_token(OPEN_PAREN);
    parseTypeName();
    jj_consume_token(CLOSE_PAREN);
    parseCastExpression_NoDereference();

  }

  static final public void parseCastExpression_NoDereference() throws ParseException {
    if (jj_2_90(2147483647)) {
      parseCastExpression_Subpart_NoDereference();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
      case NEW:
      case DELETE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case SIGNED:
      case UNSIGNED:
      case FLOAT:
      case DOUBLE:
      case VOID:
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case NOT:
      case PLUS:
      case MINUS:
      case INCREMENT:
      case DECREMENT:
      case SCOPE:
      case OPEN_PAREN:
      case AMPERSAND:
      case ASTERISK:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parseUnaryExpression_NoDereference();
        break;
      default:
        jj_la1[335] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static final public void parseUnaryExpression_NoDereference() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
      jj_consume_token(INCREMENT);
      parseUnaryExpression_NoDereference();
      break;
    case DECREMENT:
      jj_consume_token(DECREMENT);
      parseUnaryExpression_NoDereference();
      break;
    case SIZEOF:
      jj_consume_token(SIZEOF);
      if (jj_2_91(2147483647)) {
        parseCastExpression_Subpart_NoDereference();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseUnaryExpression_NoDereference();
          break;
        default:
          jj_la1[336] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case NEW:
    case DELETE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case SIGNED:
    case UNSIGNED:
    case FLOAT:
    case DOUBLE:
    case VOID:
    case OPERATOR:
    case TASK:
    case GOAL:
    case COMMAND:
    case MONITOR:
    case EXCEPTION:
    case HANDLER:
    case RESUME:
    case HANDLES:
    case FIRST:
    case TRIGGER:
    case DISTRIBUTED:
    case THREADED:
    case NAME:
    case TDL_REF:
    case GET_NUMBER_OF_TRIGGERS:
    case GET_NUMBER_OF_ACTIVATES:
    case NOT:
    case PLUS:
    case MINUS:
    case SCOPE:
    case OPEN_PAREN:
    case AMPERSAND:
    case ASTERISK:
    case TILDE:
    case INTEGER_CONSTANT:
    case CHARACTER_CONSTANT:
    case STRING_CONSTANT:
    case ID:
    case FLOAT_CONSTANT_BASIC:
    case FLOATING_CONSTANT:
      if (jj_2_94(2147483647)) {
        parseDeallocationExpression_NoDereference();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          if (jj_2_93(2147483647)) {
            parseAllocationExpression();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CHAR:
            case SHORT:
            case INT:
            case LONG:
            case SIGNED:
            case UNSIGNED:
            case FLOAT:
            case DOUBLE:
            case VOID:
            case OPERATOR:
            case TASK:
            case GOAL:
            case COMMAND:
            case MONITOR:
            case EXCEPTION:
            case HANDLER:
            case RESUME:
            case HANDLES:
            case FIRST:
            case TRIGGER:
            case DISTRIBUTED:
            case THREADED:
            case NAME:
            case TDL_REF:
            case GET_NUMBER_OF_TRIGGERS:
            case GET_NUMBER_OF_ACTIVATES:
            case NOT:
            case PLUS:
            case MINUS:
            case SCOPE:
            case OPEN_PAREN:
            case AMPERSAND:
            case ASTERISK:
            case TILDE:
            case INTEGER_CONSTANT:
            case CHARACTER_CONSTANT:
            case STRING_CONSTANT:
            case ID:
            case FLOAT_CONSTANT_BASIC:
            case FLOATING_CONSTANT:
              if (jj_2_92(2147483647)) {
                parseUnaryOperator();
                parseCastExpression_NoDereference();
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case CHAR:
                case SHORT:
                case INT:
                case LONG:
                case SIGNED:
                case UNSIGNED:
                case FLOAT:
                case DOUBLE:
                case VOID:
                case OPERATOR:
                case TASK:
                case GOAL:
                case COMMAND:
                case MONITOR:
                case EXCEPTION:
                case HANDLER:
                case RESUME:
                case HANDLES:
                case FIRST:
                case TRIGGER:
                case DISTRIBUTED:
                case THREADED:
                case NAME:
                case TDL_REF:
                case GET_NUMBER_OF_TRIGGERS:
                case GET_NUMBER_OF_ACTIVATES:
                case SCOPE:
                case OPEN_PAREN:
                case TILDE:
                case INTEGER_CONSTANT:
                case CHARACTER_CONSTANT:
                case STRING_CONSTANT:
                case ID:
                case FLOAT_CONSTANT_BASIC:
                case FLOATING_CONSTANT:
                  parsePostfixExpression_NoDereference();
                  break;
                default:
                  jj_la1[337] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
              }
              break;
            default:
              jj_la1[338] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[339] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[340] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void parseDeallocationExpression_NoDereference() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[341] = jj_gen;
      ;
    }
    jj_consume_token(DELETE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      jj_consume_token(CLOSE_BRACKET);
      break;
    default:
      jj_la1[342] = jj_gen;
      ;
    }
    parseCastExpression_NoDereference();

  }

  static final public void parsePostfixExpression_NoDereference() throws ParseException {
    if (jj_2_95(2147483647)) {
      parsePostfixExpression_internalSimpleTypeNameBit();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
      case TASK:
      case GOAL:
      case COMMAND:
      case MONITOR:
      case EXCEPTION:
      case HANDLER:
      case RESUME:
      case HANDLES:
      case FIRST:
      case TRIGGER:
      case DISTRIBUTED:
      case THREADED:
      case NAME:
      case TDL_REF:
      case GET_NUMBER_OF_TRIGGERS:
      case GET_NUMBER_OF_ACTIVATES:
      case SCOPE:
      case OPEN_PAREN:
      case TILDE:
      case INTEGER_CONSTANT:
      case CHARACTER_CONSTANT:
      case STRING_CONSTANT:
      case ID:
      case FLOAT_CONSTANT_BASIC:
      case FLOATING_CONSTANT:
        parsePrimaryExpression();
        break;
      default:
        jj_la1[343] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_80:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCREMENT:
      case DECREMENT:
      case OPEN_PAREN:
      case OPEN_BRACKET:
        ;
        break;
      default:
        jj_la1[344] = jj_gen;
        break label_80;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        parseExpression();
        jj_consume_token(CLOSE_BRACKET);
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIZEOF:
        case NEW:
        case DELETE:
        case CHAR:
        case SHORT:
        case INT:
        case LONG:
        case SIGNED:
        case UNSIGNED:
        case FLOAT:
        case DOUBLE:
        case VOID:
        case OPERATOR:
        case TASK:
        case GOAL:
        case COMMAND:
        case MONITOR:
        case EXCEPTION:
        case HANDLER:
        case RESUME:
        case HANDLES:
        case FIRST:
        case TRIGGER:
        case DISTRIBUTED:
        case THREADED:
        case NAME:
        case TDL_REF:
        case GET_NUMBER_OF_TRIGGERS:
        case GET_NUMBER_OF_ACTIVATES:
        case NOT:
        case PLUS:
        case MINUS:
        case INCREMENT:
        case DECREMENT:
        case SCOPE:
        case OPEN_PAREN:
        case AMPERSAND:
        case ASTERISK:
        case TILDE:
        case INTEGER_CONSTANT:
        case CHARACTER_CONSTANT:
        case STRING_CONSTANT:
        case ID:
        case FLOAT_CONSTANT_BASIC:
        case FLOATING_CONSTANT:
          parseExpressionList();
          break;
        default:
          jj_la1[345] = jj_gen;
          ;
        }
        jj_consume_token(CLOSE_PAREN);
        break;
      case INCREMENT:
        jj_consume_token(INCREMENT);
        break;
      case DECREMENT:
        jj_consume_token(DECREMENT);
        break;
      default:
        jj_la1[346] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }

  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  static private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  static private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  static private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  static private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  static private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  static private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  static private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  static private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  static private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  static private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  static private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  static private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  static private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  static private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  static private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  static private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  static private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  static private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  static private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  static private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  static private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  static private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  static private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  static private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  static private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  static private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  static private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  static private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  static private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  static private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  static private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  static private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  static private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  static private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  static private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  static private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  static private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  static private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  static private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  static private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  static private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  static private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  static private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  static private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  static private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  static private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  static private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  static private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  static private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  static private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  static private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  static private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  static private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  static private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  static private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  static private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  static private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  static private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  static private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  static private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  static private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  static private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  static private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  static private boolean jj_2_78(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  static private boolean jj_2_79(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  static private boolean jj_2_80(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  static private boolean jj_2_81(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_81(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  static private boolean jj_2_82(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_82(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  static private boolean jj_2_83(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_83(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  static private boolean jj_2_84(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_84(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  static private boolean jj_2_85(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_85(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(84, xla); }
  }

  static private boolean jj_2_86(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_86(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(85, xla); }
  }

  static private boolean jj_2_87(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_87(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(86, xla); }
  }

  static private boolean jj_2_88(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_88(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(87, xla); }
  }

  static private boolean jj_2_89(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_89(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(88, xla); }
  }

  static private boolean jj_2_90(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_90(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(89, xla); }
  }

  static private boolean jj_2_91(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_91(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(90, xla); }
  }

  static private boolean jj_2_92(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_92(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(91, xla); }
  }

  static private boolean jj_2_93(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_93(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(92, xla); }
  }

  static private boolean jj_2_94(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_94(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(93, xla); }
  }

  static private boolean jj_2_95(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_95(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(94, xla); }
  }

  static private boolean jj_3R_495() {
    if (jj_scan_token(TDL_BIND)) return true;
    return false;
  }

  static private boolean jj_3R_773() {
    if (jj_scan_token(PARENT)) return true;
    return false;
  }

  static private boolean jj_3R_504() {
    if (jj_scan_token(PERSISTENT)) return true;
    if (jj_3R_605()) return true;
    return false;
  }

  static private boolean jj_3R_750() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(156)) return true;
    }
    if (jj_3R_749()) return true;
    return false;
  }

  static private boolean jj_3R_769() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_773()) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_737() {
    if (jj_3R_749()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_750()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_34() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_303() {
    if (jj_scan_token(ACHIEVEMENT)) return true;
    return false;
  }

  static private boolean jj_3R_738() {
    if (jj_scan_token(AMPERSAND)) return true;
    if (jj_3R_737()) return true;
    return false;
  }

  static private boolean jj_3R_302() {
    if (jj_scan_token(PLANNING)) return true;
    return false;
  }

  static private boolean jj_3R_397() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  static private boolean jj_3R_301() {
    if (jj_scan_token(EXECUTION)) return true;
    return false;
  }

  static private boolean jj_3R_721() {
    if (jj_3R_737()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_738()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_765() {
    if (jj_scan_token(TDL_REF)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_769()) {
    jj_scanpos = xsp;
    if (jj_3R_770()) return true;
    }
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_300() {
    if (jj_scan_token(EXPANSION)) return true;
    return false;
  }

  static private boolean jj_3R_743() {
    if (jj_3R_211()) return true;
    return false;
  }

  static private boolean jj_3R_722() {
    if (jj_scan_token(EXCLUSIVE_OR)) return true;
    if (jj_3R_721()) return true;
    return false;
  }

  static private boolean jj_3R_299() {
    if (jj_scan_token(HANDLING)) return true;
    return false;
  }

  static private boolean jj_3R_342() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_700() {
    if (jj_3R_721()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_722()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_211() {
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_342()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_701() {
    if (jj_scan_token(INCLUSIVE_OR)) return true;
    if (jj_3R_700()) return true;
    return false;
  }

  static private boolean jj_3R_184() {
    if (jj_scan_token(SEQUENTIAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) return true;
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_304()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_52() {
    if (jj_3R_121()) return true;
    return false;
  }

  static private boolean jj_3R_727() {
    if (jj_scan_token(DEREFERENCE)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3R_726() {
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3R_673() {
    if (jj_3R_700()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_701()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) return true;
    }
    return false;
  }

  static private boolean jj_3R_725() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_743()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_724() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_705() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_724()) {
    jj_scanpos = xsp;
    if (jj_3R_725()) {
    jj_scanpos = xsp;
    if (jj_3R_726()) {
    jj_scanpos = xsp;
    if (jj_3R_727()) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_704() {
    if (jj_3R_723()) return true;
    return false;
  }

  static private boolean jj_3R_674() {
    if (jj_scan_token(LOGICAL_AND)) return true;
    if (jj_3R_673()) return true;
    return false;
  }

  static private boolean jj_3R_703() {
    if (jj_3R_121()) return true;
    return false;
  }

  static private boolean jj_3R_615() {
    if (jj_3R_673()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_674()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_680() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_703()) {
    jj_scanpos = xsp;
    if (jj_3R_704()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_705()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_616() {
    if (jj_scan_token(LOGICAL_OR)) return true;
    if (jj_3R_615()) return true;
    return false;
  }

  static private boolean jj_3R_494() {
    if (jj_scan_token(SPAWN)) return true;
    return false;
  }

  static private boolean jj_3R_219() {
    if (jj_3R_211()) return true;
    return false;
  }

  static private boolean jj_3R_691() {
    if (jj_3R_98()) return true;
    return false;
  }

  static private boolean jj_3R_536() {
    if (jj_3R_615()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_616()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_121() {
    if (jj_3R_218()) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_210() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_458() {
    if (jj_3R_372()) return true;
    return false;
  }

  static private boolean jj_3R_537() {
    if (jj_scan_token(QUESTION_MARK)) return true;
    if (jj_3R_617()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_192()) return true;
    return false;
  }

  static private boolean jj_3R_297() {
    if (jj_3R_427()) return true;
    return false;
  }

  static private boolean jj_3R_116() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(172)) jj_scanpos = xsp;
    if (jj_scan_token(DELETE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_210()) jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3R_183() {
    if (jj_scan_token(MONITOR_PERIOD)) return true;
    if (jj_3R_298()) return true;
    return false;
  }

  static private boolean jj_3_89() {
    if (jj_3R_142()) return true;
    return false;
  }

  static private boolean jj_3_20() {
    if (jj_3R_98()) return true;
    return false;
  }

  static private boolean jj_3R_430() {
    if (jj_3R_536()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_537()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_182() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) return true;
    }
    return false;
  }

  static private boolean jj_3R_181() {
    if (jj_3R_101()) return true;
    return false;
  }

  static private boolean jj_3_51() {
    if (jj_3R_120()) return true;
    return false;
  }

  static private boolean jj_3R_180() {
    if (jj_3R_296()) return true;
    return false;
  }

  static private boolean jj_3R_316() {
    if (jj_3R_430()) return true;
    return false;
  }

  static private boolean jj_3R_341() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_458()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_347() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_315() {
    if (jj_3R_142()) return true;
    return false;
  }

  static private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) return true;
    }
    return false;
  }

  static private boolean jj_3R_346() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_215() {
    Token xsp;
    if (jj_3R_347()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_347()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_345() {
    if (jj_3R_120()) return true;
    return false;
  }

  static private boolean jj_3R_214() {
    Token xsp;
    if (jj_3R_345()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_345()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_346()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_217() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3R_142() {
    if (jj_3R_255()) return true;
    if (jj_3R_203()) return true;
    if (jj_3R_192()) return true;
    return false;
  }

  static private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) return true;
    }
    return false;
  }

  static private boolean jj_3R_675() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_192()) return true;
    return false;
  }

  static private boolean jj_3_49() {
    if (jj_3R_118()) return true;
    return false;
  }

  static private boolean jj_3R_216() {
    if (jj_3R_130()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  static private boolean jj_3R_617() {
    if (jj_3R_192()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_675()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_535() {
    if (jj_scan_token(MAXIMUM)) return true;
    if (jj_scan_token(TRIGGER)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_120() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    if (jj_scan_token(ASTERISK)) return true;
    xsp = jj_scanpos;
    if (jj_3R_217()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_264() {
    if (jj_3R_152()) return true;
    return false;
  }

  static private boolean jj_3_50() {
    if (jj_3R_119()) return true;
    return false;
  }

  static private boolean jj_3R_554() {
    if (jj_3R_340()) return true;
    return false;
  }

  static private boolean jj_3R_457() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_554()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_456() {
    if (jj_3R_119()) return true;
    return false;
  }

  static private boolean jj_3R_534() {
    if (jj_scan_token(MAXIMUM_TRIGGER)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_427() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_534()) {
    jj_scanpos = xsp;
    if (jj_3R_535()) return true;
    }
    return false;
  }

  static private boolean jj_3R_340() {
    if (jj_3R_118()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_456()) {
    jj_scanpos = xsp;
    if (jj_3R_457()) return true;
    }
    return false;
  }

  static private boolean jj_3_33() {
    if (jj_3R_105()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) return true;
    }
    if (jj_3R_105()) return true;
    return false;
  }

  static private boolean jj_3R_614() {
    if (jj_3R_105()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) return true;
    }
    return false;
  }

  static private boolean jj_3R_265() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_529() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_614()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3_88() {
    if (jj_3R_141()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) return true;
    }
    return false;
  }

  static private boolean jj_3R_152() {
    if (jj_3R_95()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_265()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_87() {
    if (jj_3R_141()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) return true;
    }
    return false;
  }

  static private boolean jj_3R_335() {
    if (jj_3R_333()) return true;
    return false;
  }

  static private boolean jj_3R_117() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_211()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_48() {
    if (jj_3R_117()) return true;
    return false;
  }

  static private boolean jj_3R_334() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_201() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) return true;
    }
    return false;
  }

  static private boolean jj_3R_209() {
    if (jj_3R_341()) return true;
    return false;
  }

  static private boolean jj_3R_200() {
    if (jj_3R_333()) return true;
    return false;
  }

  static private boolean jj_3R_208() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_177() {
    if (jj_scan_token(MAXIMUM)) return true;
    if (jj_scan_token(ACTIVATE)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_207() {
    if (jj_3R_340()) return true;
    return false;
  }

  static private boolean jj_3R_199() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_206() {
    if (jj_3R_117()) return true;
    return false;
  }

  static private boolean jj_3R_266() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_508() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3R_176() {
    if (jj_scan_token(MAXIMUM_ACTIVATE)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_115() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(172)) jj_scanpos = xsp;
    if (jj_scan_token(NEW)) return true;
    xsp = jj_scanpos;
    if (jj_3R_206()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_209()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_153() {
    if (jj_3R_106()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_266()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_45() {
    if (jj_3R_113()) return true;
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    return false;
  }

  static private boolean jj_3R_402() {
    if (jj_3R_507()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_508()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_631() {
    if (jj_3R_680()) return true;
    return false;
  }

  static private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(34)) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_630() {
    if (jj_3R_113()) return true;
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_506() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  static private boolean jj_3R_553() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_630()) {
    jj_scanpos = xsp;
    if (jj_3R_631()) return true;
    }
    return false;
  }

  static private boolean jj_3_46() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3_44() {
    if (jj_3R_112()) return true;
    return false;
  }

  static private boolean jj_3R_401() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_506()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_85() {
    if (jj_3R_152()) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_153()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_47() {
    if (jj_3R_116()) return true;
    return false;
  }

  static private boolean jj_3R_110() {
    if (jj_3R_198()) return true;
    if (jj_scan_token(LESS_THAN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_201()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GREATER_THAN)) return true;
    return false;
  }

  static private boolean jj_3R_552() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3R_453() {
    if (jj_3R_202()) return true;
    return false;
  }

  static private boolean jj_3R_533() {
    if (jj_scan_token(SPAWN)) return true;
    return false;
  }

  static private boolean jj_3R_455() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_552()) {
    jj_scanpos = xsp;
    if (jj_3R_553()) return true;
    }
    return false;
  }

  static private boolean jj_3R_452() {
    if (jj_3R_112()) return true;
    return false;
  }

  static private boolean jj_3_19() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_454() {
    if (jj_3R_116()) return true;
    return false;
  }

  static private boolean jj_3R_339() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_454()) {
    jj_scanpos = xsp;
    if (jj_3R_455()) return true;
    }
    return false;
  }

  static private boolean jj_3R_151() {
    if (jj_3R_264()) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) return true;
    }
    return false;
  }

  static private boolean jj_3R_532() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_338() {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_452()) {
    jj_scanpos = xsp;
    if (jj_3R_453()) return true;
    }
    return false;
  }

  static private boolean jj_3R_337() {
    if (jj_scan_token(DECREMENT)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  static private boolean jj_3R_336() {
    if (jj_scan_token(INCREMENT)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  static private boolean jj_3_43() {
    if (jj_3R_112()) return true;
    return false;
  }

  static private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_205() {
    if (jj_3R_202()) return true;
    return false;
  }

  static private boolean jj_3R_531() {
    if (jj_scan_token(ON)) return true;
    if (jj_scan_token(TERMINATE)) return true;
    return false;
  }

  static private boolean jj_3R_204() {
    if (jj_3R_112()) return true;
    return false;
  }

  static private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) return true;
    }
    return false;
  }

  static private boolean jj_3R_530() {
    if (jj_scan_token(ON_TERMINATE)) return true;
    return false;
  }

  static private boolean jj_3R_112() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3R_426() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_530()) {
    jj_scanpos = xsp;
    if (jj_3R_531()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_532()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_533()) jj_scanpos = xsp;
    if (jj_3R_529()) return true;
    return false;
  }

  static private boolean jj_3R_702() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(167)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) return true;
    }
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3R_353() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_352() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_492() {
    if (jj_scan_token(RESUME)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_678() {
    if (jj_3R_114()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_702()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_679() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) return true;
    }
    }
    if (jj_3R_678()) return true;
    return false;
  }

  static private boolean jj_3R_150() {
    if (jj_scan_token(EXCEPTION)) return true;
    if (jj_scan_token(HANDLER)) return true;
    return false;
  }

  static private boolean jj_3R_528() {
    if (jj_scan_token(EXCEPTION)) return true;
    return false;
  }

  static private boolean jj_3R_628() {
    if (jj_3R_678()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_679()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_425() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_528()) jj_scanpos = xsp;
    if (jj_scan_token(HANDLER)) return true;
    if (jj_3R_529()) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) return true;
    }
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_629() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) return true;
    }
    if (jj_3R_628()) return true;
    return false;
  }

  static private boolean jj_3R_527() {
    if (jj_scan_token(DELAY)) return true;
    if (jj_scan_token(EXPANSION)) return true;
    return false;
  }

  static private boolean jj_3R_550() {
    if (jj_3R_628()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_629()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_526() {
    if (jj_scan_token(EXPAND)) return true;
    if (jj_scan_token(FIRST)) return true;
    return false;
  }

  static private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) {
    jj_scanpos = xsp;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) {
    jj_scanpos = xsp;
    if (jj_scan_token(153)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_scan_token(152)) {
    jj_scanpos = xsp;
    if (jj_scan_token(184)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(147)) {
    jj_scanpos = xsp;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(156)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) {
    jj_scanpos = xsp;
    if (jj_scan_token(151)) {
    jj_scanpos = xsp;
    if (jj_scan_token(150)) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_424() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_526()) {
    jj_scanpos = xsp;
    if (jj_3R_527()) return true;
    }
    return false;
  }

  static private boolean jj_3R_551() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) return true;
    }
    if (jj_3R_550()) return true;
    return false;
  }

  static private boolean jj_3R_525() {
    if (jj_scan_token(DELAY_EXPANSION)) return true;
    return false;
  }

  static private boolean jj_3R_125() {
    if (jj_scan_token(OPERATOR)) return true;
    if (jj_3R_222()) return true;
    return false;
  }

  static private boolean jj_3R_450() {
    if (jj_3R_550()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_551()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_524() {
    if (jj_scan_token(EXPAND_FIRST)) return true;
    return false;
  }

  static private boolean jj_3R_423() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_524()) {
    jj_scanpos = xsp;
    if (jj_3R_525()) return true;
    }
    return false;
  }

  static private boolean jj_3R_451() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) return true;
    }
    }
    if (jj_3R_450()) return true;
    return false;
  }

  static private boolean jj_3R_296() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_423()) {
    jj_scanpos = xsp;
    if (jj_3R_424()) {
    jj_scanpos = xsp;
    if (jj_3R_425()) {
    jj_scanpos = xsp;
    if (jj_3R_426()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_333() {
    if (jj_3R_450()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_451()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_158() {
    if (jj_scan_token(MONITOR)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_96() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3_85() {
    if (jj_3R_118()) return true;
    return false;
  }

  static private boolean jj_3R_732() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) return true;
    }
    }
    }
    if (jj_3R_450()) return true;
    return false;
  }

  static private boolean jj_3R_714() {
    if (jj_3R_450()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_732()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_86() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_682() {
    if (jj_3R_558()) return true;
    return false;
  }

  static private boolean jj_3R_635() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_682()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_269() {
    if (jj_scan_token(COMMAND)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_415() {
    if (jj_3R_285()) return true;
    return false;
  }

  static private boolean jj_3R_715() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(156)) return true;
    }
    if (jj_3R_714()) return true;
    return false;
  }

  static private boolean jj_3R_634() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_519() {
    if (jj_3R_612()) return true;
    return false;
  }

  static private boolean jj_3R_195() {
    if (jj_3R_295()) return true;
    return false;
  }

  static private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_96()) jj_scanpos = xsp;
    if (jj_scan_token(OPEN_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_689() {
    if (jj_3R_714()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_715()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_518() {
    if (jj_3R_611()) return true;
    return false;
  }

  static private boolean jj_3R_558() {
    if (jj_3R_118()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_634()) {
    jj_scanpos = xsp;
    if (jj_3R_635()) return true;
    }
    return false;
  }

  static private boolean jj_3R_268() {
    if (jj_scan_token(GOAL)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_690() {
    if (jj_scan_token(AMPERSAND)) return true;
    if (jj_3R_689()) return true;
    return false;
  }

  static private boolean jj_3R_728() {
    if (jj_3R_641()) return true;
    return false;
  }

  static private boolean jj_3R_414() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_518()) {
    jj_scanpos = xsp;
    if (jj_3R_519()) return true;
    }
    return false;
  }

  static private boolean jj_3R_319() {
    if (jj_scan_token(PARENT)) return true;
    return false;
  }

  static private boolean jj_3R_650() {
    if (jj_3R_689()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_690()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_286() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) return true;
    }
    return false;
  }

  static private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_465() {
    if (jj_scan_token(OPERATOR)) return true;
    if (jj_3R_558()) return true;
    return false;
  }

  static private boolean jj_3R_651() {
    if (jj_scan_token(EXCLUSIVE_OR)) return true;
    if (jj_3R_650()) return true;
    return false;
  }

  static private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    }
    if (jj_3R_196()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_261() {
    if (jj_scan_token(TASK)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  static private boolean jj_3R_580() {
    if (jj_3R_650()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_651()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_641() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_639() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_638()) return true;
    return false;
  }

  static private boolean jj_3R_581() {
    if (jj_scan_token(INCLUSIVE_OR)) return true;
    if (jj_3R_580()) return true;
    return false;
  }

  static private boolean jj_3R_396() {
    if (jj_3R_503()) return true;
    return false;
  }

  static private boolean jj_3R_395() {
    if (jj_3R_502()) return true;
    return false;
  }

  static private boolean jj_3R_707() {
    if (jj_3R_641()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(59)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_267() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) {
    jj_scanpos = xsp;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_394() {
    if (jj_3R_501()) return true;
    return false;
  }

  static private boolean jj_3R_486() {
    if (jj_3R_580()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_581()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_706() {
    if (jj_scan_token(VIRTUAL_CS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_728()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_683() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_706()) {
    jj_scanpos = xsp;
    if (jj_3R_707()) return true;
    }
    return false;
  }

  static private boolean jj_3R_541() {
    if (jj_scan_token(AFTER)) return true;
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_487() {
    if (jj_scan_token(LOGICAL_AND)) return true;
    if (jj_3R_486()) return true;
    return false;
  }

  static private boolean jj_3R_154() {
    Token xsp;
    if (jj_3R_267()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_267()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_638() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_683()) jj_scanpos = xsp;
    if (jj_3R_130()) return true;
    return false;
  }

  static private boolean jj_3R_437() {
    if (jj_3R_298()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_541()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_419() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_380() {
    if (jj_3R_486()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_487()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_677() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_627() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(194)) {
    jj_scanpos = xsp;
    if (jj_3R_677()) return true;
    }
    return false;
  }

  static private boolean jj_3R_381() {
    if (jj_scan_token(LOGICAL_OR)) return true;
    if (jj_3R_380()) return true;
    return false;
  }

  static private boolean jj_3R_653() {
    if (jj_3R_502()) return true;
    return false;
  }

  static private boolean jj_3R_562() {
    if (jj_3R_638()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_639()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_549() {
    Token xsp;
    if (jj_3R_627()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_627()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_652() {
    if (jj_3R_501()) return true;
    return false;
  }

  static private boolean jj_3R_582() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_652()) {
    jj_scanpos = xsp;
    if (jj_3R_653()) return true;
    }
    return false;
  }

  static private boolean jj_3R_259() {
    if (jj_3R_380()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_381()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_489() {
    Token xsp;
    if (jj_3R_582()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_582()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_468() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_562()) return true;
    return false;
  }

  static private boolean jj_3R_260() {
    if (jj_scan_token(QUESTION_MARK)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_146() {
    if (jj_3R_259()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_260()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_521() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_520()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_604() {
    if (jj_scan_token(THREADED)) return true;
    return false;
  }

  static private boolean jj_3R_314() {
    if (jj_scan_token(PERIOD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    return false;
  }

  static private boolean jj_3R_603() {
    if (jj_scan_token(PERSISTENT)) return true;
    return false;
  }

  static private boolean jj_3R_602() {
    if (jj_scan_token(DISTRIBUTED)) return true;
    return false;
  }

  static private boolean jj_3R_418() {
    Token xsp;
    if (jj_3R_521()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_521()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_84() {
    if (jj_3R_140()) return true;
    return false;
  }

  static private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(195)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_503() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_602()) {
    jj_scanpos = xsp;
    if (jj_3R_603()) {
    jj_scanpos = xsp;
    if (jj_3R_604()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_191() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_314()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_374() {
    if (jj_3R_481()) return true;
    return false;
  }

  static private boolean jj_3R_251() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_250()) return true;
    return false;
  }

  static private boolean jj_3_42() {
    if (jj_3R_111()) return true;
    return false;
  }

  static private boolean jj_3R_203() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(147)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(149)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_373() {
    if (jj_3R_140()) return true;
    return false;
  }

  static private boolean jj_3R_250() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_373()) {
    jj_scanpos = xsp;
    if (jj_3R_374()) return true;
    }
    return false;
  }

  static private boolean jj_3R_318() {
    if (jj_3R_146()) return true;
    return false;
  }

  static private boolean jj_3R_252() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_289() {
    if (jj_scan_token(ASTERISK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_317() {
    if (jj_3R_111()) return true;
    return false;
  }

  static private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) return true;
    }
    return false;
  }

  static private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_252()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_170() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_289()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_601() {
    if (jj_scan_token(VIRTUAL_CI)) return true;
    return false;
  }

  static private boolean jj_3R_600() {
    if (jj_scan_token(VIRTUAL_CS)) return true;
    return false;
  }

  static private boolean jj_3R_111() {
    if (jj_3R_202()) return true;
    if (jj_3R_203()) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_139() {
    if (jj_3R_250()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_251()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_83() {
    if (jj_3R_124()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_502() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_600()) {
    jj_scanpos = xsp;
    if (jj_3R_601()) return true;
    }
    return false;
  }

  static private boolean jj_3R_488() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_685() {
    if (jj_3R_708()) return true;
    return false;
  }

  static private boolean jj_3R_382() {
    if (jj_3R_193()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_488()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_82() {
    if (jj_3R_139()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_684() {
    if (jj_3R_124()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_413() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_190() {
    if (jj_scan_token(FLOAT_CONSTANT_BASIC)) return true;
    return false;
  }

  static private boolean jj_3R_640() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_684()) {
    jj_scanpos = xsp;
    if (jj_3R_685()) return true;
    }
    return false;
  }

  static private boolean jj_3R_745() {
    if (jj_3R_238()) return true;
    if (jj_3R_708()) return true;
    return false;
  }

  static private boolean jj_3R_412() {
    if (jj_scan_token(STRUCT)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_744() {
    if (jj_3R_139()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_729() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_744()) {
    jj_scanpos = xsp;
    if (jj_3R_745()) return true;
    }
    return false;
  }

  static private boolean jj_3R_198() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_599() {
    if (jj_scan_token(STATIC_CI)) return true;
    return false;
  }

  static private boolean jj_3R_598() {
    if (jj_scan_token(STATIC_CS)) return true;
    return false;
  }

  static private boolean jj_3R_708() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(180)) {
    jj_scanpos = xsp;
    if (jj_3R_729()) return true;
    }
    return false;
  }

  static private boolean jj_3R_235() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_228() {
    if (jj_3R_359()) return true;
    return false;
  }

  static private boolean jj_3R_501() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_598()) {
    jj_scanpos = xsp;
    if (jj_3R_599()) return true;
    }
    return false;
  }

  static private boolean jj_3R_564() {
    if (jj_3R_641()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3R_563() {
    if (jj_3R_640()) return true;
    return false;
  }

  static private boolean jj_3R_469() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_563()) {
    jj_scanpos = xsp;
    if (jj_3R_564()) return true;
    }
    return false;
  }

  static private boolean jj_3_41() {
    if (jj_3R_110()) return true;
    return false;
  }

  static private boolean jj_3R_681() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_359() {
    Token xsp;
    if (jj_3R_469()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_469()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_233() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    }
    return false;
  }

  static private boolean jj_3R_232() {
    if (jj_3R_110()) return true;
    return false;
  }

  static private boolean jj_3R_358() {
    if (jj_3R_468()) return true;
    return false;
  }

  static private boolean jj_3R_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    }
    return false;
  }

  static private boolean jj_3R_357() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3_16() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_227() {
    if (jj_3R_356()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_357()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_358()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_517() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_385() {
    if (jj_3R_492()) return true;
    return false;
  }

  static private boolean jj_3R_128() {
    if (jj_3R_227()) return true;
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_610() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3_81() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3_17() {
    if (jj_3R_95()) return true;
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_313() {
    if (jj_scan_token(PERIOD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    return false;
  }

  static private boolean jj_3R_105() {
    if (jj_3R_192()) return true;
    return false;
  }

  static private boolean jj_3R_480() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3R_516() {
    if (jj_3R_95()) return true;
    Token xsp;
    if (jj_3R_610()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_610()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_3R_411() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_516()) {
    jj_scanpos = xsp;
    if (jj_3R_517()) return true;
    }
    return false;
  }

  static private boolean jj_3R_410() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  static private boolean jj_3R_372() {
    if (jj_3R_138()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_480()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_409() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  static private boolean jj_3R_249() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    if (jj_3R_372()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(181)) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_515() {
    if (jj_scan_token(LONG)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_248() {
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_313()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_3R_514() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_3R_138() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    return false;
  }

  static private boolean jj_3R_491() {
    if (jj_3R_583()) return true;
    return false;
  }

  static private boolean jj_3R_637() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    if (jj_3R_372()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(181)) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_636() {
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_560() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_211()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_490() {
    if (jj_3R_397()) return true;
    return false;
  }

  static private boolean jj_3R_513() {
    if (jj_scan_token(SHORT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_106() {
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_559() {
    if (jj_scan_token(EQUAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_636()) {
    jj_scanpos = xsp;
    if (jj_3R_637()) return true;
    }
    return false;
  }

  static private boolean jj_3R_512() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  static private boolean jj_3R_384() {
    if (jj_3R_84()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_490()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_491()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(HANDLES)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_466() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_559()) {
    jj_scanpos = xsp;
    if (jj_3R_560()) return true;
    }
    return false;
  }

  static private boolean jj_3R_383() {
    if (jj_3R_489()) return true;
    return false;
  }

  static private boolean jj_3R_609() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  static private boolean jj_3R_608() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  static private boolean jj_3R_262() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_383()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) return true;
    }
    return false;
  }

  static private boolean jj_3R_275() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3R_511() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_608()) {
    jj_scanpos = xsp;
    if (jj_3R_609()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_408() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_511()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_512()) {
    jj_scanpos = xsp;
    if (jj_3R_513()) {
    jj_scanpos = xsp;
    if (jj_3R_514()) {
    jj_scanpos = xsp;
    if (jj_3R_515()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_273() {
    if (jj_3R_397()) return true;
    return false;
  }

  static private boolean jj_3R_520() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) jj_scanpos = xsp;
    if (jj_3R_274()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_275()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_285() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_408()) {
    jj_scanpos = xsp;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) {
    jj_scanpos = xsp;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_80() {
    if (jj_3R_137()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_3R_158()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_697() {
    if (jj_3R_667()) return true;
    return false;
  }

  static private boolean jj_3R_188() {
    if (jj_scan_token(FLOAT_CONSTANT_BASIC)) return true;
    return false;
  }

  static private boolean jj_3R_272() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3R_696() {
    if (jj_3R_137()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_613() {
    if (jj_3R_382()) return true;
    return false;
  }

  static private boolean jj_3R_284() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_270() {
    if (jj_3R_397()) return true;
    return false;
  }

  static private boolean jj_3_79() {
    if (jj_3R_137()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3R_667() {
    if (jj_3R_238()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_696()) {
    jj_scanpos = xsp;
    if (jj_3R_697()) return true;
    }
    return false;
  }

  static private boolean jj_3R_157() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_270()) jj_scanpos = xsp;
    if (jj_3R_271()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_272()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_156() {
    if (jj_3R_269()) return true;
    return false;
  }

  static private boolean jj_3R_291() {
    if (jj_3R_419()) return true;
    return false;
  }

  static private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_290()) {
    jj_scanpos = xsp;
    if (jj_3R_291()) return true;
    }
    return false;
  }

  static private boolean jj_3R_290() {
    if (jj_3R_418()) return true;
    return false;
  }

  static private boolean jj_3R_155() {
    if (jj_3R_268()) return true;
    return false;
  }

  static private boolean jj_3R_240() {
    if (jj_3R_135()) return true;
    return false;
  }

  static private boolean jj_3R_239() {
    if (jj_3R_137()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3R_87() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_157()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_135() {
    if (jj_3R_238()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) return true;
    }
    return false;
  }

  static private boolean jj_3_78() {
    if (jj_3R_136()) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    if (jj_3R_154()) return true;
    return false;
  }

  static private boolean jj_3R_94() {
    if (jj_3R_170()) return true;
    if (jj_3R_171()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_371() {
    if (jj_3R_134()) return true;
    return false;
  }

  static private boolean jj_3R_247() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_246() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_371()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    return false;
  }

  static private boolean jj_3R_245() {
    if (jj_3R_136()) return true;
    return false;
  }

  static private boolean jj_3R_148() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) return true;
    }
    return false;
  }

  static private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_247()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_77() {
    if (jj_3R_135()) return true;
    return false;
  }

  static private boolean jj_3R_147() {
    if (jj_3R_261()) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    return false;
  }

  static private boolean jj_3R_167() {
    if (jj_3R_284()) return true;
    if (jj_3R_286()) return true;
    return false;
  }

  static private boolean jj_3R_666() {
    if (jj_3R_135()) return true;
    return false;
  }

  static private boolean jj_3R_661() {
    if (jj_scan_token(DO)) return true;
    return false;
  }

  static private boolean jj_3R_103() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(196)) return true;
    }
    if (jj_scan_token(COLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) return true;
    }
    return false;
  }

  static private boolean jj_3R_607() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_666()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_667()) return true;
    return false;
  }

  static private boolean jj_3R_644() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3R_407() {
    if (jj_3R_510()) return true;
    return false;
  }

  static private boolean jj_3R_277() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) return true;
    }
    return false;
  }

  static private boolean jj_3R_166() {
    if (jj_3R_284()) return true;
    if (jj_3R_285()) return true;
    return false;
  }

  static private boolean jj_3R_645() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_642() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3_32() {
    if (jj_3R_104()) return true;
    return false;
  }

  static private boolean jj_3R_429() {
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3R_92() {
    if (jj_3R_166()) return true;
    if (jj_3R_94()) return true;
    return false;
  }

  static private boolean jj_3R_428() {
    if (jj_3R_104()) return true;
    return false;
  }

  static private boolean jj_3R_510() {
    if (jj_3R_607()) return true;
    return false;
  }

  static private boolean jj_3R_643() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_298() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) return true;
    }
    return false;
  }

  static private boolean jj_3R_566() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3R_571() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_645()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_570() {
    if (jj_3R_277()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_644()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_475() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_570()) {
    jj_scanpos = xsp;
    if (jj_3R_571()) return true;
    }
    return false;
  }

  static private boolean jj_3R_660() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  static private boolean jj_3_40() {
    if (jj_3R_109()) return true;
    return false;
  }

  static private boolean jj_3_31() {
    if (jj_3R_103()) return true;
    return false;
  }

  static private boolean jj_3R_620() {
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_567() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_569() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_643()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_717() {
    if (jj_3R_733()) return true;
    return false;
  }

  static private boolean jj_3R_568() {
    if (jj_3R_277()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_642()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_366() {
    Token xsp;
    if (jj_3R_475()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_475()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_474() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_568()) {
    jj_scanpos = xsp;
    if (jj_3R_569()) return true;
    }
    return false;
  }

  static private boolean jj_3R_716() {
    if (jj_3R_109()) return true;
    return false;
  }

  static private boolean jj_3R_619() {
    if (jj_3R_103()) return true;
    return false;
  }

  static private boolean jj_3_76() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_134()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_692() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_716()) {
    jj_scanpos = xsp;
    if (jj_3R_717()) return true;
    }
    return false;
  }

  static private boolean jj_3R_540() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_619()) {
    jj_scanpos = xsp;
    if (jj_3R_620()) return true;
    }
    return false;
  }

  static private boolean jj_3_75() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_134()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_365() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_134()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_474()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_473() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_567()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_169() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_168()) return true;
    return false;
  }

  static private boolean jj_3R_237() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_365()) {
    jj_scanpos = xsp;
    if (jj_3R_366()) return true;
    }
    return false;
  }

  static private boolean jj_3R_364() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_472()) {
    jj_scanpos = xsp;
    if (jj_3R_473()) return true;
    }
    return false;
  }

  static private boolean jj_3R_472() {
    if (jj_3R_277()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_566()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_363() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_134()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_362() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_3R_167()) return true;
    if (jj_3R_168()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_169()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_236() {
    Token xsp;
    if (jj_3R_362()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_362()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_363()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_364()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_186() {
    if (jj_3R_312()) return true;
    return false;
  }

  static private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    }
    return false;
  }

  static private boolean jj_3_73() {
    if (jj_3R_118()) return true;
    return false;
  }

  static private boolean jj_3R_102() {
    if (jj_3R_99()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    return false;
  }

  static private boolean jj_3_74() {
    if (jj_3R_134()) return true;
    return false;
  }

  static private boolean jj_3R_375() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_254() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_375()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_288() {
    if (jj_3R_91()) return true;
    if (jj_3R_417()) return true;
    return false;
  }

  static private boolean jj_3R_416() {
    if (jj_3R_417()) return true;
    return false;
  }

  static private boolean jj_3R_179() {
    if (jj_3R_295()) return true;
    return false;
  }

  static private boolean jj_3_13() {
    if (jj_3R_94()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(180)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_253() {
    if (jj_3R_134()) return true;
    return false;
  }

  static private boolean jj_3R_659() {
    if (jj_scan_token(FOR_CS)) return true;
    return false;
  }

  static private boolean jj_3R_141() {
    if (jj_3R_118()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) return true;
    }
    return false;
  }

  static private boolean jj_3R_421() {
    if (jj_scan_token(SELF)) return true;
    return false;
  }

  static private boolean jj_3_71() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_287() {
    if (jj_3R_94()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_416()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_294() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_421()) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) return true;
    }
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_573() {
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3_72() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    return false;
  }

  static private boolean jj_3R_572() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_420() {
    if (jj_scan_token(PARENT)) return true;
    return false;
  }

  static private boolean jj_3R_479() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_572()) {
    jj_scanpos = xsp;
    if (jj_3R_573()) return true;
    }
    return false;
  }

  static private boolean jj_3R_293() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_420()) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_292() {
    if (jj_scan_token(PREVIOUS)) return true;
    return false;
  }

  static private boolean jj_3R_478() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_178() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_69() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_370() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_478()) {
    jj_scanpos = xsp;
    if (jj_3R_479()) return true;
    }
    return false;
  }

  static private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    return false;
  }

  static private boolean jj_3R_710() {
    if (jj_3R_349()) return true;
    return false;
  }

  static private boolean jj_3_70() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_709() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_687() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_709()) {
    jj_scanpos = xsp;
    if (jj_3R_710()) return true;
    }
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_82()) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_686() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_748() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_91()) return true;
    if (jj_3R_417()) return true;
    return false;
  }

  static private boolean jj_3R_658() {
    if (jj_scan_token(SWITCH)) return true;
    return false;
  }

  static private boolean jj_3R_646() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_686()) {
    jj_scanpos = xsp;
    if (jj_3R_687()) return true;
    }
    return false;
  }

  static private boolean jj_3_39() {
    if (jj_scan_token(ELSE)) return true;
    return false;
  }

  static private boolean jj_3R_509() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    return false;
  }

  static private boolean jj_3R_736() {
    if (jj_3R_605()) return true;
    if (jj_3R_417()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_748()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_523() {
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_406() {
    if (jj_3R_509()) return true;
    return false;
  }

  static private boolean jj_3R_522() {
    if (jj_3R_613()) return true;
    return false;
  }

  static private boolean jj_3R_276() {
    Token xsp;
    if (jj_3R_406()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_406()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_12() {
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3R_161() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3R_160() {
    if (jj_3R_130()) return true;
    if (jj_scan_token(SCOPE)) return true;
    if (jj_scan_token(ASTERISK)) return true;
    return false;
  }

  static private boolean jj_3_68() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_720() {
    if (jj_3R_736()) return true;
    return false;
  }

  static private boolean jj_3R_422() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_522()) {
    jj_scanpos = xsp;
    if (jj_3R_523()) return true;
    }
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(182)) {
    jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_161()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_719() {
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3R_698() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_719()) {
    jj_scanpos = xsp;
    if (jj_3R_720()) return true;
    }
    return false;
  }

  static private boolean jj_3_67() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_244() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_243() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_136()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_647() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_242() {
    if (jj_3R_370()) return true;
    return false;
  }

  static private boolean jj_3R_278() {
    if (jj_3R_276()) return true;
    return false;
  }

  static private boolean jj_3R_295() {
    if (jj_3R_95()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_422()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_241() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_657() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  static private boolean jj_3R_136() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_241()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_244()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_66() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_577() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_647()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_576() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_136()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_575() {
    if (jj_3R_646()) return true;
    return false;
  }

  static private boolean jj_3R_279() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_187() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_574() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_171() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_481() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_574()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_575()) {
    jj_scanpos = xsp;
    if (jj_3R_576()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_577()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_354() {
    if (jj_3R_466()) return true;
    return false;
  }

  static private boolean jj_3R_109() {
    if (jj_3R_197()) return true;
    return false;
  }

  static private boolean jj_3R_693() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_30() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_312() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_224() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_223()) return true;
    return false;
  }

  static private boolean jj_3R_163() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_279()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_162() {
    if (jj_3R_277()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_624() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    }
    return false;
  }

  static private boolean jj_3R_672() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_671()) return true;
    return false;
  }

  static private boolean jj_3R_623() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_223() {
    if (jj_3R_136()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_547() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_623()) {
    jj_scanpos = xsp;
    if (jj_3R_624()) return true;
    }
    return false;
  }

  static private boolean jj_3R_126() {
    if (jj_3R_223()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_224()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(172)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_670() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_446() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_546()) {
    jj_scanpos = xsp;
    if (jj_3R_547()) return true;
    }
    return false;
  }

  static private boolean jj_3R_546() {
    if (jj_scan_token(IN)) return true;
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_355() {
    if (jj_3R_467()) return true;
    return false;
  }

  static private boolean jj_3R_612() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_670()) jj_scanpos = xsp;
    if (jj_scan_token(OPEN_BRACE)) return true;
    if (jj_3R_671()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_672()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_449() {
    if (jj_scan_token(ASM)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_549()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_606() {
    if (jj_3R_417()) return true;
    return false;
  }

  static private boolean jj_3R_561() {
    if (jj_3R_197()) return true;
    return false;
  }

  static private boolean jj_3R_594() {
    if (jj_scan_token(FAIL)) return true;
    return false;
  }

  static private boolean jj_3R_467() {
    Token xsp;
    if (jj_3R_561()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_561()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_507() {
    if (jj_3R_605()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_606()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_330() {
    if (jj_scan_token(ACTIVATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_446()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_226() {
    if (jj_3R_197()) return true;
    return false;
  }

  static private boolean jj_3R_225() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_355()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_230() {
    if (jj_3R_360()) return true;
    return false;
  }

  static private boolean jj_3R_565() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_127() {
    if (jj_scan_token(EXTERN_CS)) return true;
    if (jj_scan_token(STRING_CONSTANT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) return true;
    }
    return false;
  }

  static private boolean jj_3R_593() {
    if (jj_scan_token(POSTPONE)) return true;
    return false;
  }

  static private boolean jj_3_29() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_329() {
    if (jj_scan_token(ACTIVATE_IN)) return true;
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_592() {
    if (jj_scan_token(SUCCESS)) return true;
    return false;
  }

  static private boolean jj_3R_664() {
    if (jj_3R_693()) return true;
    return false;
  }

  static private boolean jj_3R_471() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_470()) return true;
    return false;
  }

  static private boolean jj_3R_445() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    if (jj_3R_146()) return true;
    return false;
  }

  static private boolean jj_3R_605() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_664()) jj_scanpos = xsp;
    if (jj_3R_665()) return true;
    return false;
  }

  static private boolean jj_3R_591() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  static private boolean jj_3R_590() {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  static private boolean jj_3R_444() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_589() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  static private boolean jj_3R_470() {
    if (jj_3R_95()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_565()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_498() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_589()) {
    jj_scanpos = xsp;
    if (jj_3R_590()) {
    jj_scanpos = xsp;
    if (jj_3R_591()) {
    jj_scanpos = xsp;
    if (jj_3R_592()) {
    jj_scanpos = xsp;
    if (jj_3R_593()) {
    jj_scanpos = xsp;
    if (jj_3R_594()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_28() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_229() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_328() {
    if (jj_scan_token(ACTIVATE_AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_444()) {
    jj_scanpos = xsp;
    if (jj_3R_445()) return true;
    }
    return false;
  }

  static private boolean jj_3R_360() {
    if (jj_3R_470()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_471()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_622() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_588() {
    if (jj_3R_661()) return true;
    return false;
  }

  static private boolean jj_3_65() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_587() {
    if (jj_3R_660()) return true;
    return false;
  }

  static private boolean jj_3R_586() {
    if (jj_3R_659()) return true;
    return false;
  }

  static private boolean jj_3R_621() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_129() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) jj_scanpos = xsp;
    if (jj_scan_token(OPEN_BRACE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_230()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_695() {
    if (jj_3R_718()) return true;
    return false;
  }

  static private boolean jj_3R_497() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_586()) {
    jj_scanpos = xsp;
    if (jj_3R_587()) {
    jj_scanpos = xsp;
    if (jj_3R_588()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_361() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_545() {
    if (jj_scan_token(AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_621()) {
    jj_scanpos = xsp;
    if (jj_3R_622()) return true;
    }
    return false;
  }

  static private boolean jj_3_64() {
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_132()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  static private boolean jj_3R_699() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_585() {
    if (jj_3R_658()) return true;
    return false;
  }

  static private boolean jj_3R_584() {
    if (jj_3R_657()) return true;
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_3R_92()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) {
    jj_scanpos = xsp;
    if (jj_scan_token(0)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_231() {
    if (jj_3R_132()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_361()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_496() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_584()) {
    jj_scanpos = xsp;
    if (jj_3R_585()) return true;
    }
    return false;
  }

  static private boolean jj_3R_671() {
    if (jj_3R_95()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_699()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_694() {
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_443() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_544()) {
    jj_scanpos = xsp;
    if (jj_3R_545()) return true;
    }
    return false;
  }

  static private boolean jj_3R_544() {
    if (jj_scan_token(IN)) return true;
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_665() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_694()) {
    jj_scanpos = xsp;
    if (jj_3R_695()) return true;
    }
    return false;
  }

  static private boolean jj_3_63() {
    if (jj_3R_131()) return true;
    return false;
  }

  static private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(172)) jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    return false;
  }

  static private boolean jj_3R_327() {
    if (jj_scan_token(TERMINATE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_443()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_234() {
    if (jj_3R_131()) return true;
    return false;
  }

  static private boolean jj_3R_669() {
    if (jj_3R_698()) return true;
    return false;
  }

  static private boolean jj_3R_133() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_234()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_235()) return true;
    return false;
  }

  static private boolean jj_3R_493() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  static private boolean jj_3_27() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_326() {
    if (jj_scan_token(TERMINATE_IN)) return true;
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_131() {
    if (jj_3R_132()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  static private boolean jj_3R_442() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_417() {
    if (jj_scan_token(FORMAT)) return true;
    if (jj_3R_520()) return true;
    return false;
  }

  static private boolean jj_3R_668() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_441() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_611() {
    if (jj_scan_token(STRUCT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_668()) jj_scanpos = xsp;
    if (jj_scan_token(OPEN_BRACE)) return true;
    if (jj_3R_669()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_669()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_735() {
    if (jj_3R_718()) return true;
    return false;
  }

  static private boolean jj_3R_633() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_681()) return true;
    return false;
  }

  static private boolean jj_3_26() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_632() {
    if (jj_3R_356()) return true;
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_325() {
    if (jj_scan_token(TERMINATE_AT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_441()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) return true;
    }
    return false;
  }

  static private boolean jj_3R_543() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_555() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_632()) {
    jj_scanpos = xsp;
    if (jj_3R_633()) return true;
    }
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_3R_91()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(175)) {
    jj_scanpos = xsp;
    if (jj_scan_token(0)) {
    jj_scanpos = xsp;
    if (jj_scan_token(178)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_62() {
    if (jj_3R_130()) return true;
    return false;
  }

  static private boolean jj_3R_542() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_462() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_734() {
    if (jj_3R_91()) return true;
    return false;
  }

  static private boolean jj_3R_461() {
    if (jj_3R_130()) return true;
    return false;
  }

  static private boolean jj_3R_440() {
    if (jj_scan_token(UNTIL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_542()) {
    jj_scanpos = xsp;
    if (jj_3R_543()) return true;
    }
    return false;
  }

  static private boolean jj_3R_348() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_461()) {
    jj_scanpos = xsp;
    if (jj_3R_462()) return true;
    }
    return false;
  }

  static private boolean jj_3_60() {
    if (jj_3R_128()) return true;
    return false;
  }

  static private boolean jj_3R_149() {
    if (jj_3R_263()) return true;
    return false;
  }

  static private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_348()) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_460() {
    if (jj_3R_555()) return true;
    return false;
  }

  static private boolean jj_3R_718() {
    if (jj_3R_238()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_734()) {
    jj_scanpos = xsp;
    if (jj_3R_735()) return true;
    }
    return false;
  }

  static private boolean jj_3_61() {
    if (jj_3R_129()) return true;
    return false;
  }

  static private boolean jj_3R_459() {
    if (jj_3R_128()) return true;
    return false;
  }

  static private boolean jj_3R_344() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_459()) {
    jj_scanpos = xsp;
    if (jj_3R_460()) return true;
    }
    return false;
  }

  static private boolean jj_3R_83() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_149()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_439() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    }
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_343() {
    if (jj_3R_129()) return true;
    return false;
  }

  static private boolean jj_3R_213() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) return true;
    }
    return false;
  }

  static private boolean jj_3R_212() {
    if (jj_3R_218()) return true;
    return false;
  }

  static private boolean jj_3R_438() {
    if (jj_3R_312()) return true;
    return false;
  }

  static private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_747() {
    if (jj_3R_613()) return true;
    return false;
  }

  static private boolean jj_3R_165() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_477() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    return false;
  }

  static private boolean jj_3R_324() {
    if (jj_scan_token(DISABLE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_438()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_439()) {
    jj_scanpos = xsp;
    if (jj_3R_440()) return true;
    }
    return false;
  }

  static private boolean jj_3R_733() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_747()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_91() {
    if (jj_3R_164()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_476() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3_25() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_323() {
    if (jj_scan_token(DISABLE_FOR)) return true;
    if (jj_3R_437()) return true;
    return false;
  }

  static private boolean jj_3R_436() {
    if (jj_3R_540()) return true;
    return false;
  }

  static private boolean jj_3R_595() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_283() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_435() {
    if (jj_3R_102()) return true;
    return false;
  }

  static private boolean jj_3R_369() {
    if (jj_3R_477()) return true;
    return false;
  }

  static private boolean jj_3R_368() {
    if (jj_3R_118()) return true;
    return false;
  }

  static private boolean jj_3R_367() {
    if (jj_3R_476()) return true;
    return false;
  }

  static private boolean jj_3_59() {
    if (jj_3R_127()) return true;
    return false;
  }

  static private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_367()) {
    jj_scanpos = xsp;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_746() {
    if (jj_3R_211()) return true;
    return false;
  }

  static private boolean jj_3R_282() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_164()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_322() {
    if (jj_scan_token(DISABLE_UNTIL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) return true;
    }
    return false;
  }

  static private boolean jj_3R_448() {
    if (jj_3R_548()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_332() {
    if (jj_3R_449()) return true;
    return false;
  }

  static private boolean jj_3R_447() {
    if (jj_3R_127()) return true;
    return false;
  }

  static private boolean jj_3R_331() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_447()) {
    jj_scanpos = xsp;
    if (jj_3R_448()) return true;
    }
    return false;
  }

  static private boolean jj_3R_281() {
    if (jj_3R_171()) return true;
    return false;
  }

  static private boolean jj_3R_175() {
    if (jj_scan_token(DEFAULT_LABEL)) return true;
    return false;
  }

  static private boolean jj_3_23() {
    if (jj_3R_100()) return true;
    return false;
  }

  static private boolean jj_3R_434() {
    if (jj_scan_token(WAIT)) return true;
    return false;
  }

  static private boolean jj_3_58() {
    if (jj_3R_126()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_197() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) return true;
    }
    return false;
  }

  static private boolean jj_3_95() {
    if (jj_3R_121()) return true;
    return false;
  }

  static private boolean jj_3R_676() {
    if (jj_3R_238()) return true;
    if (jj_3R_548()) return true;
    return false;
  }

  static private boolean jj_3R_280() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3R_433() {
    if (jj_scan_token(PARALLEL)) return true;
    return false;
  }

  static private boolean jj_3R_731() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_746()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_539() {
    if (jj_3R_618()) return true;
    return false;
  }

  static private boolean jj_3R_730() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_713() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_730()) {
    jj_scanpos = xsp;
    if (jj_3R_731()) {
    jj_scanpos = xsp;
    if (jj_scan_token(170)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_626() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(180)) {
    jj_scanpos = xsp;
    if (jj_3R_676()) return true;
    }
    return false;
  }

  static private boolean jj_3R_164() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_280()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_3R_282()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_283()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_321() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_433()) {
    jj_scanpos = xsp;
    if (jj_3R_434()) return true;
    }
    return false;
  }

  static private boolean jj_3R_712() {
    if (jj_3R_723()) return true;
    return false;
  }

  static private boolean jj_3R_538() {
    if (jj_3R_100()) return true;
    return false;
  }

  static private boolean jj_3R_625() {
    if (jj_3R_126()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_711() {
    if (jj_3R_121()) return true;
    return false;
  }

  static private boolean jj_3R_432() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_538()) {
    jj_scanpos = xsp;
    if (jj_3R_539()) return true;
    }
    return false;
  }

  static private boolean jj_3R_548() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_625()) {
    jj_scanpos = xsp;
    if (jj_3R_626()) return true;
    }
    return false;
  }

  static private boolean jj_3_24() {
    if (jj_3R_101()) return true;
    return false;
  }

  static private boolean jj_3R_174() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_688() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_711()) {
    jj_scanpos = xsp;
    if (jj_3R_712()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_713()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_92() {
    if (jj_3R_113()) return true;
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_258() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_768() {
    if (jj_3R_549()) return true;
    return false;
  }

  static private boolean jj_3R_431() {
    if (jj_3R_101()) return true;
    return false;
  }

  static private boolean jj_3R_320() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) return true;
    }
    return false;
  }

  static private boolean jj_3R_173() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_649() {
    if (jj_3R_688()) return true;
    return false;
  }

  static private boolean jj_3R_145() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(172)) jj_scanpos = xsp;
    if (jj_scan_token(DELETE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_258()) jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_648() {
    if (jj_3R_113()) return true;
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_760() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(197)) {
    jj_scanpos = xsp;
    if (jj_scan_token(198)) {
    jj_scanpos = xsp;
    if (jj_scan_token(193)) {
    jj_scanpos = xsp;
    if (jj_3R_768()) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_579() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_648()) {
    jj_scanpos = xsp;
    if (jj_3R_649()) return true;
    }
    return false;
  }

  static private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) return true;
    }
    }
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3_93() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3R_656() {
    if (jj_3R_691()) return true;
    return false;
  }

  static private boolean jj_3_91() {
    if (jj_3R_143()) return true;
    return false;
  }

  static private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_36() {
    if (jj_3R_107()) return true;
    return false;
  }

  static private boolean jj_3_94() {
    if (jj_3R_145()) return true;
    return false;
  }

  static private boolean jj_3R_655() {
    if (jj_3R_505()) return true;
    return false;
  }

  static private boolean jj_3R_663() {
    if (jj_3R_692()) return true;
    return false;
  }

  static private boolean jj_3R_654() {
    if (jj_3R_504()) return true;
    return false;
  }

  static private boolean jj_3R_578() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3R_483() {
    if (jj_3R_255()) return true;
    return false;
  }

  static private boolean jj_3_57() {
    if (jj_3R_125()) return true;
    return false;
  }

  static private boolean jj_3R_485() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_578()) {
    jj_scanpos = xsp;
    if (jj_3R_579()) return true;
    }
    return false;
  }

  static private boolean jj_3R_583() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_654()) {
    jj_scanpos = xsp;
    if (jj_3R_655()) {
    jj_scanpos = xsp;
    if (jj_3R_656()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_482() {
    if (jj_3R_143()) return true;
    return false;
  }

  static private boolean jj_3R_662() {
    if (jj_3R_107()) return true;
    return false;
  }

  static private boolean jj_3R_124() {
    if (jj_3R_132()) return true;
    if (jj_scan_token(SCOPE)) return true;
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3R_484() {
    if (jj_3R_145()) return true;
    return false;
  }

  static private boolean jj_3R_597() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_662()) {
    jj_scanpos = xsp;
    if (jj_3R_663()) return true;
    }
    return false;
  }

  static private boolean jj_3_37() {
    if (jj_3R_108()) return true;
    return false;
  }

  static private boolean jj_3R_351() {
    if (jj_3R_465()) return true;
    return false;
  }

  static private boolean jj_3R_379() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_484()) {
    jj_scanpos = xsp;
    if (jj_3R_485()) return true;
    }
    return false;
  }

  static private boolean jj_3R_350() {
    if (jj_3R_125()) return true;
    return false;
  }

  static private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_350()) {
    jj_scanpos = xsp;
    if (jj_3R_351()) return true;
    }
    return false;
  }

  static private boolean jj_3R_378() {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_482()) {
    jj_scanpos = xsp;
    if (jj_3R_483()) return true;
    }
    return false;
  }

  static private boolean jj_3R_220() {
    if (jj_3R_349()) return true;
    return false;
  }

  static private boolean jj_3R_377() {
    if (jj_scan_token(DECREMENT)) return true;
    if (jj_3R_255()) return true;
    return false;
  }

  static private boolean jj_3_38() {
    if (jj_3R_97()) return true;
    return false;
  }

  static private boolean jj_3R_376() {
    if (jj_scan_token(INCREMENT)) return true;
    if (jj_3R_255()) return true;
    return false;
  }

  static private boolean jj_3_56() {
    if (jj_3R_124()) return true;
    return false;
  }

  static private boolean jj_3R_596() {
    if (jj_3R_108()) return true;
    return false;
  }

  static private boolean jj_3_90() {
    if (jj_3R_143()) return true;
    return false;
  }

  static private boolean jj_3R_500() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_596()) {
    jj_scanpos = xsp;
    if (jj_3R_597()) return true;
    }
    return false;
  }

  static private boolean jj_3R_122() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    return false;
  }

  static private boolean jj_3R_255() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) {
    jj_scanpos = xsp;
    if (jj_3R_378()) {
    jj_scanpos = xsp;
    if (jj_3R_379()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_405() {
    if (jj_3R_100()) return true;
    return false;
  }

  static private boolean jj_3R_557() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_464() {
    if (jj_scan_token(TILDE)) return true;
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_257() {
    if (jj_3R_255()) return true;
    return false;
  }

  static private boolean jj_3R_499() {
    if (jj_3R_595()) return true;
    return false;
  }

  static private boolean jj_3R_556() {
    if (jj_3R_124()) return true;
    return false;
  }

  static private boolean jj_3R_393() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_499()) {
    jj_scanpos = xsp;
    if (jj_3R_500()) return true;
    }
    return false;
  }

  static private boolean jj_3R_404() {
    if (jj_3R_505()) return true;
    return false;
  }

  static private boolean jj_3R_463() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_556()) {
    jj_scanpos = xsp;
    if (jj_3R_557()) return true;
    }
    return false;
  }

  static private boolean jj_3R_256() {
    if (jj_3R_143()) return true;
    return false;
  }

  static private boolean jj_3R_403() {
    if (jj_3R_504()) return true;
    return false;
  }

  static private boolean jj_3R_392() {
    if (jj_3R_498()) return true;
    return false;
  }

  static private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) return true;
    }
    return false;
  }

  static private boolean jj_3R_618() {
    if (jj_scan_token(ON)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  static private boolean jj_3R_391() {
    if (jj_3R_497()) return true;
    return false;
  }

  static private boolean jj_3R_274() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) {
    jj_scanpos = xsp;
    if (jj_3R_405()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_390() {
    if (jj_3R_496()) return true;
    return false;
  }

  static private boolean jj_3R_349() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_463()) {
    jj_scanpos = xsp;
    if (jj_3R_464()) return true;
    }
    return false;
  }

  static private boolean jj_3R_389() {
    if (jj_3R_495()) return true;
    return false;
  }

  static private boolean jj_3R_388() {
    if (jj_3R_494()) return true;
    return false;
  }

  static private boolean jj_3R_387() {
    if (jj_3R_493()) return true;
    return false;
  }

  static private boolean jj_3_22() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_386() {
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_143() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_263() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_386()) {
    jj_scanpos = xsp;
    if (jj_3R_387()) {
    jj_scanpos = xsp;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) {
    jj_scanpos = xsp;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_776() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(167)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) return true;
    }
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_311() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_774() {
    if (jj_3R_144()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_776()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_400() {
    if (jj_3R_296()) return true;
    return false;
  }

  static private boolean jj_3R_757() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(138)) return true;
    }
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_756() {
    if (jj_3R_765()) return true;
    return false;
  }

  static private boolean jj_3R_399() {
    if (jj_3R_505()) return true;
    return false;
  }

  static private boolean jj_3R_398() {
    if (jj_3R_504()) return true;
    return false;
  }

  static private boolean jj_3R_775() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(183)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(166)) return true;
    }
    }
    if (jj_3R_774()) return true;
    return false;
  }

  static private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_55() {
    if (jj_3R_124()) return true;
    return false;
  }

  static private boolean jj_3R_771() {
    if (jj_3R_774()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_775()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_123() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_755() {
    if (jj_scan_token(TRIGGER)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_310() {
    if (jj_scan_token(SERIAL)) return true;
    return false;
  }

  static private boolean jj_3R_764() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_742() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_755()) {
    jj_scanpos = xsp;
    if (jj_3R_756()) {
    jj_scanpos = xsp;
    if (jj_3R_757()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_309() {
    if (jj_scan_token(SEQUENTIAL_ACHIEVEMENT)) return true;
    return false;
  }

  static private boolean jj_3_53() {
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3R_772() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(163)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) return true;
    }
    if (jj_3R_771()) return true;
    return false;
  }

  static private boolean jj_3R_763() {
    if (jj_3R_124()) return true;
    return false;
  }

  static private boolean jj_3R_754() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_763()) {
    jj_scanpos = xsp;
    if (jj_3R_764()) return true;
    }
    return false;
  }

  static private boolean jj_3R_741() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_382()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_753() {
    if (jj_3R_125()) return true;
    return false;
  }

  static private boolean jj_3R_308() {
    if (jj_scan_token(SEQUENTIAL_PLANNING)) return true;
    return false;
  }

  static private boolean jj_3R_762() {
    if (jj_3R_760()) return true;
    return false;
  }

  static private boolean jj_3_54() {
    if (jj_3R_95()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_scan_token(194)) return true;
    }
    return false;
  }

  static private boolean jj_3R_766() {
    if (jj_3R_771()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_772()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_307() {
    if (jj_scan_token(SEQUENTIAL_EXECUTION)) return true;
    return false;
  }

  static private boolean jj_3R_761() {
    if (jj_3R_122()) return true;
    return false;
  }

  static private boolean jj_3R_740() {
    if (jj_scan_token(SCOPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_753()) {
    jj_scanpos = xsp;
    if (jj_3R_754()) return true;
    }
    return false;
  }

  static private boolean jj_3R_752() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_761()) {
    jj_scanpos = xsp;
    if (jj_3R_762()) return true;
    }
    return false;
  }

  static private boolean jj_3R_306() {
    if (jj_scan_token(SEQUENTIAL_EXPANSION)) return true;
    return false;
  }

  static private boolean jj_3_35() {
    if (jj_3R_106()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_767() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(161)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) return true;
    }
    if (jj_3R_766()) return true;
    return false;
  }

  static private boolean jj_3R_751() {
    if (jj_3R_760()) return true;
    return false;
  }

  static private boolean jj_3R_505() {
    if (jj_scan_token(FORMAT)) return true;
    if (jj_3R_520()) return true;
    return false;
  }

  static private boolean jj_3R_305() {
    if (jj_scan_token(SEQUENTIAL_HANDLING)) return true;
    return false;
  }

  static private boolean jj_3R_739() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_751()) {
    jj_scanpos = xsp;
    if (jj_3R_752()) return true;
    }
    return false;
  }

  static private boolean jj_3_21() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_758() {
    if (jj_3R_766()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_767()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_185() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_311()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_723() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_739()) {
    jj_scanpos = xsp;
    if (jj_3R_740()) {
    jj_scanpos = xsp;
    if (jj_3R_741()) {
    jj_scanpos = xsp;
    if (jj_3R_742()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_304() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_759() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(158)) {
    jj_scanpos = xsp;
    if (jj_scan_token(159)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) return true;
    }
    }
    }
    if (jj_3R_758()) return true;
    return false;
  }

  static private boolean jj_3R_770() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_749() {
    if (jj_3R_758()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_759()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public TDLParserTokenManager token_source;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[347];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0xfff80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff80000,0x0,0x0,0x0,0x0,0x0,0x0,0xfff80000,0xfff80000,0x0,0x0,0x0,0xfff80000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0xc0000000,0x1000000,0xc0000000,0x1000000,0x1000000,0x3c000000,0x0,0xfc000000,0x1000000,0x1000000,0x0,0x0,0x0,0xfc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0x0,0x0,0xfc070000,0x0,0xfc070000,0xfc070000,0x0,0x0,0xfc070000,0xfc070000,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0x0,0x0,0x0,0x0,0x0,0xfc070000,0xfc070000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0x0,0x0,0x0,0x0,0x0,0xffff0000,0xffff0000,0xffff0000,0xfffffec0,0x8400,0xfc070000,0xfffffec0,0x0,0x280,0x840,0xfc070000,0xfc070000,0x7000,0x0,0x0,0xfc070000,0xfc070000,0xfc070000,0x0,0x0,0xfc070000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0xfc070000,0xfc000000,0xfc000000,0xfc020000,0xfc070000,0x0,0x0,0xff000000,0x0,0x0,0x3000000,0x0,0x0,0x0,0xfc070000,0x0,0x0,0xfc070000,0x0,0x0,0xfc070000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff80000,0xfff80000,0xfff80000,0xfff80000,0xfff80000,0xfff80000,0x600000,0x800000,0x0,0x0,0xff000000,0x0,0xfc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff80000,0xfff80000,0xfff80000,0x0,0x0,0x3000000,0xfc070000,0x0,0x0,0x0,0xfc070000,0x0,0x0,0x3000000,0x3000000,0x3000000,0x0,0x0,0x0,0x0,0xff000000,0x0,0x0,0x3000000,0xfc070000,0x0,0x0,0x3000000,0xfc070000,0x0,0x3000000,0xfc070000,0x0,0x0,0x0,0x0,0xfff80000,0x0,0x0,0xfff80000,0xfff80000,0x0,0xfc070000,0x0,0x0,0xfc070000,0xfff80000,0x0,0x0,0xfff80000,0xfff80000,0xfff80000,0xfff80000,0xfff80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0x60000,0xfc070000,0x0,0xfc070000,0x0,0xfc070000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc070000,0xfc070000,0xfc000000,0xfc000000,0xfc020000,0xfc070000,0x0,0x0,0x0,0x0,0xfc070000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0xd0000ef,0x0,0x0,0x38,0x0,0x84000000,0xad000000,0x84000000,0xad000000,0x21000000,0x0,0x0,0x84000000,0x0,0x0,0x0,0x8c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8c000000,0x0,0x0,0x0,0x0,0x0,0x8c000000,0x8c000000,0x84000000,0x8000000,0x0,0x8c000000,0x8c000000,0x8c000000,0x8c000000,0x0,0x4,0x0,0xd0000ef,0x0,0x0,0x0,0x0,0x0,0x0,0xd0000ef,0xd0000ef,0x0,0x0,0x0,0xd0000ef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa3,0x0,0x0,0x0,0x0,0xa0,0xa3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1007,0x0,0x42000000,0x1007,0x42000000,0x1007,0x1007,0x0,0x0,0x1007,0x1007,0x0,0x0,0x0,0x0,0x0,0x0,0x1007,0x10000000,0x0,0x10000000,0x10000000,0x0,0x1007,0x1007,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x1007,0x0,0x0,0x0,0x0,0x0,0xd0011ef,0x1d0011ef,0x1dffd1ef,0x1fffd1ef,0x0,0x1007,0x1fffd1ef,0x0,0x0,0x2000000,0x1007,0x1007,0x0,0x0,0xffc000,0x1007,0x1007,0x1007,0x0,0x0,0x1007,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1007,0x1007,0x1007,0x1007,0x1007,0x1007,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x1007,0x0,0x0,0x1007,0x1000,0x0,0x1007,0x0,0x0,0x10000000,0x10000000,0x0,0x1000,0x0,0x1000,0x0,0x0,0x1000,0x0,0x0,0x1000,0x1000,0x0,0xd0000ef,0xd0000ef,0xd0010ef,0xd0011ef,0xd0000ef,0xd0000ef,0x5000000,0x8000000,0xe8,0xe8,0xef,0x0,0x7,0xe8,0x68,0x0,0x0,0x0,0x0,0x0,0xd0011ef,0xd0011ef,0xd0011ef,0x0,0x0,0x0,0x1007,0x0,0x0,0x0,0x1007,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0xef,0x0,0x0,0x0,0x1007,0x0,0x0,0x0,0x1007,0x0,0x0,0x1007,0x0,0x0,0x0,0x0,0xd0000ef,0x0,0x0,0xd0000ef,0xd0000ef,0x0,0x1007,0x0,0x0,0x1007,0xd000eef,0x0,0x0,0xd000eef,0xd000eef,0xd0000ef,0xd0000ef,0xd0000ef,0x0,0x0,0x0,0x0,0xe00,0x8000000,0x8000e00,0x8000e00,0xe00,0x0,0x1007,0x0,0x1007,0x0,0x1007,0x0,0x1007,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1007,0x1007,0x1007,0x1007,0x1007,0x1007,0x0,0x0,0x1000,0x0,0x1007,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x2000e3fc,0x200003fc,0x0,0x0,0x0,0x40,0x1fd,0x40,0x1fd,0x0,0x40,0x1fc,0x0,0x40,0x0,0x0,0x1,0x18,0x0,0x0,0x500000c0,0x0,0x0,0xd00000c0,0x38,0x1,0x0,0x0,0x0,0x0,0x1c0,0x1c1,0x1fd,0x0,0x1,0x0,0x1,0x1,0x1,0x1,0xc0,0x0,0x0,0x2000e3fc,0x0,0x500000c0,0xd00000c0,0x0,0x200003fc,0x0,0x200003fc,0x200003fc,0xe000,0x0,0xe000,0x2000e3fc,0x0,0x0,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003fc,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x200003fc,0x0,0x50000000,0x40,0x0,0x0,0x500000c0,0x0,0x0,0x0,0xd00000c0,0xf800000,0x0,0x80000000,0x0,0xd00000c0,0x0,0x200003fc,0xf800000,0x0,0x200003fc,0x0,0x200003fc,0x200003fc,0x2000,0x2000,0x200003fc,0x200003fc,0x2000,0x2000,0xd00000c0,0xf800000,0x700000,0x0,0x200003fc,0x40002,0x30000,0xf0002,0x200f03fe,0xf800000,0x200003fc,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40002,0x200403fe,0x2000,0x0,0x0,0x200003fc,0x0,0xd00400c0,0x0,0x0,0x200003fc,0x200003fc,0x200403fe,0x200403fe,0x20041ffe,0x200003fc,0x200003fc,0x20041ffe,0x0,0x0,0x0,0x200003fc,0x200003fc,0x1c00,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x0,0x200003fc,0x0,0x0,0x0,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x200003fc,0x0,0x200003fc,0x0,0x0,0x40002,0x200403fe,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x0,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x0,0x200003fc,0x0,0x200003fc,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x0,0x0,0x0,0x200003fc,0x0,0x0,0x200003fc,0x0,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x200003fc,0x200003fc,0x0,0x200003fc,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x200003fc,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003fc,0x0,0x200003fc,0x0,0x200003fc,0x0,0x200003fc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x200003fc,0x0,0x0,0x200003fc,0x0,0x200003fc,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x34000,0x34000,0x34000,0x34000,0x34000,0x34000,0x0,0x0,0x0,0x4000,0x16000,0x4000,0x16000,0x0,0x0,0x0,0x0,0x4000,0x0,0x8000,0x16000,0x0,0x0,0x0,0xcb000,0x0,0x0,0x81fcb901,0x0,0x0,0x0,0x8000a100,0x0,0x0,0x0,0x0,0x16000,0x0,0x0,0x16000,0x0,0x0,0x16000,0x16000,0x0,0x0,0x0,0x34000,0x0,0xcb000,0x81fcb901,0x8000a100,0x34000,0x0,0x34000,0x34000,0x0,0x8000,0x0,0x34000,0x0,0x8000,0x34000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x34000,0x34000,0x0,0x0,0x0,0x0,0x0,0x34000,0xc0000,0x0,0x0,0x1000,0x0,0xc1000,0x80000100,0x100,0x100,0x81fc1901,0x0,0x1f00001,0x1f00001,0x1000,0x81fc1901,0x6,0x34400,0x0,0x0,0x34400,0x10,0x34400,0x34400,0x80,0x80,0x34400,0x34400,0x80,0x80,0xfffc1b4f,0x0,0x0,0x0,0x34400,0x0,0x0,0x0,0x34000,0x0,0x34400,0x34400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x34000,0x0,0x0,0x0,0x34400,0x0,0xfffe1b4f,0x0,0x0,0x34000,0x34400,0x34400,0x34400,0x34400,0x34000,0x34400,0x34400,0x0,0x0,0x0,0x34400,0x34400,0x0,0x0,0x0,0x34400,0x34400,0x34400,0x34000,0x0,0x34400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x34400,0x34400,0x34400,0x34400,0x34400,0x34400,0x0,0x0,0x34000,0x0,0x34000,0x0,0x0,0x0,0x34000,0x34400,0x0,0x0,0x34400,0x34400,0x0,0x34400,0x0,0x0,0x0,0x34000,0x34000,0x34000,0x34000,0x34000,0x0,0x400,0x34400,0x34000,0x34000,0x0,0x34000,0x34000,0x34000,0x34000,0x34000,0x34000,0x34000,0x34000,0x0,0x0,0x0,0x0,0x34000,0x34000,0x34000,0x0,0x0,0x0,0x34000,0x34000,0x0,0x0,0x34000,0x34000,0x34000,0x0,0x0,0x0,0x34400,0x0,0x34000,0x0,0x34400,0x34000,0x34000,0x0,0x0,0x0,0x34000,0x34000,0x34000,0x34000,0x34000,0x34000,0x0,0x0,0x34400,0x0,0x0,0x0,0x34400,0x0,0x0,0x34400,0x0,0x0,0x0,0x34000,0x34000,0x34000,0x0,0x34000,0x34000,0x0,0x34400,0x0,0x0,0x34400,0x34000,0x34000,0x0,0x34000,0x34000,0x34000,0x34000,0x34000,0x0,0x34000,0x34000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x34400,0x0,0x34400,0x0,0x34400,0x0,0x34400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x34400,0x34400,0x34400,0x34400,0x34400,0x34400,0x0,0x0,0x34400,0x0,0x34400,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x8,0x0,0xa,0x8,0x0,0xb,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x3,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4,0x2,0x0,0x1,0x1,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x4000640,0x0,0x0,0x4000640,0x0,0x4000640,0x4000640,0x0,0x0,0x4000640,0x4000640,0x0,0x0,0x3,0x0,0x0,0x0,0x4000640,0x0,0x0,0x0,0x0,0x0,0x4000640,0x4000640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x4000640,0x0,0xc3,0x0,0x8,0x0,0x4000640,0x4000640,0x4000640,0x400074c,0x0,0x4000640,0x400074c,0x0,0x0,0x0,0x4000640,0x4000640,0x0,0x0,0x0,0x4000640,0x4000640,0x4000640,0x0,0x0,0x4000640,0x3ff800,0x0,0x400000,0x800000,0x1000000,0x2000000,0x0,0x18000000,0x18000000,0xe0000000,0xe0000000,0xa0000000,0xa0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000640,0x4000640,0x640,0x4000640,0x4000640,0x4000640,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000640,0x0,0x0,0x4000640,0x640,0x0,0x4000640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x640,0x640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x800,0x0,0x4000640,0x0,0x0,0x0,0x4000640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000640,0x0,0x0,0x0,0x4000640,0x0,0x0,0x4000640,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x4000640,0x800,0x0,0x4000640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000640,0xfffff800,0x4000640,0x0,0x4000640,0x0,0x4000640,0x0,0x400000,0x800000,0x1000000,0x2000000,0x0,0x18000000,0x18000000,0xe0000000,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000640,0x4000640,0x640,0x4000640,0x4000640,0x4000640,0x0,0x0,0x640,0x0,0x4000640,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x1000,0x0,0x200000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x1000,0x1000,0x0,0x0,0x0,0x4000,0x0,0x1000,0x1000,0x0,0x0,0x0,0x1000,0x200000,0x0,0xc05000,0x200000,0x10000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81c05c18,0x0,0x0,0x81c05c18,0x0,0x81c05c18,0x81c05c18,0x0,0x0,0x81c05c18,0x81c05c18,0x0,0x0,0x0,0x0,0x0,0x10000,0x89c05c18,0x0,0x0,0x0,0x0,0x0,0x81c05c18,0x81c05c18,0x80000000,0x80000000,0x80000000,0x80000000,0x8000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x8000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x200000,0x81c05c18,0x8000200,0x0,0x200000,0x0,0x0,0x81d05c18,0x81d05c18,0x81d05c18,0x81d45c18,0x0,0x81c05c18,0x81d45c18,0x200000,0x0,0x0,0x81c05c18,0x81c05c18,0x0,0x1000,0x0,0x81c05c18,0x81c05c18,0x81d05c18,0x0,0x200000,0x81c05c18,0x0,0x4000000,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x1,0x1,0x1,0x1,0x6,0x6,0x18,0x18,0x800060,0x800060,0x180,0x180,0x81c05c18,0x81c05c18,0x81005000,0x81c05018,0x81c05018,0x81c05c18,0x1c00018,0x1000,0x5000,0x4000,0x1000,0x0,0x10000,0x10000,0x811000,0x81c45c18,0x1000,0x10000,0x81c05c18,0x81005000,0x8014e00,0x81c05c18,0x8014e00,0x200000,0x0,0x0,0x80000000,0x81000000,0x0,0x0,0x0,0x0,0x81005000,0x0,0x1000000,0x0,0x1000000,0x80000000,0x101000,0x101000,0x1d05000,0x1d05000,0x1000,0x1000,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x0,0x0,0x1000,0x0,0x0,0x200000,0x0,0x1d05000,0x1d45000,0x1d05000,0x200000,0x4000,0x0,0x81c05c18,0x14000,0x1004000,0x10000,0x81c05c18,0x1004000,0xc01000,0x0,0x0,0x0,0x1000000,0x1000000,0x1000000,0x1000000,0x1000,0xc01000,0x14000,0x0,0x81c05c18,0x14000,0x14000,0x0,0x81c05c18,0x14000,0x0,0x81c05c18,0x14000,0x14000,0x14000,0xc15000,0x9000,0xc15000,0x0,0x1000,0x1000,0x200000,0x81c45c18,0x4000,0x200000,0x81c45c18,0x3d05000,0x0,0x2000000,0x3d05000,0x3d05000,0x1000,0x3d05000,0x3d05000,0x200000,0x0,0x1c05000,0x200000,0x0,0x0,0x0,0x0,0x0,0x200000,0x81c05c18,0x1e14f7f,0x81c05c18,0x200000,0x81c05c18,0x200000,0x81c05c18,0x4000000,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x1,0x1,0x6,0x6,0x18,0x18,0x800060,0x800060,0x180,0x180,0x81c05c18,0x81c05c18,0x81005000,0x81c05018,0x81c05018,0x81c05c18,0x1000,0x10000,0x81005000,0x14c00,0x81c05c18,0x14c00,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x8,0xc,0xc,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x8,0x0,0x8,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7e,0x0,0x0,0x7e,0x0,0x7e,0x7e,0x0,0x0,0x7e,0x7e,0x0,0x0,0x0,0x0,0x0,0x0,0x6e,0x0,0x0,0x0,0x8,0x0,0x6e,0x6e,0x10,0x10,0x10,0x10,0x0,0x30,0x10,0x10,0x10,0x10,0x0,0x30,0x0,0x0,0x8,0x0,0x0,0x0,0x6e,0x0,0x0,0x0,0x0,0x8,0x6e,0x6e,0x6e,0x6e,0x8,0x6e,0x6e,0x0,0x0,0x0,0x6e,0x6e,0x0,0x0,0x0,0x6e,0x6e,0x6e,0x8,0x0,0x6e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x0,0x0,0x8,0x0,0x8,0x0,0x0,0x0,0x8,0x6e,0x0,0x0,0x6e,0x6e,0x0,0x6e,0x0,0x0,0x0,0x8,0x6e,0x6e,0x8,0x8,0x0,0x0,0x6e,0x8,0x8,0x0,0x8,0x6e,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x8,0x8,0x8,0x0,0x0,0x0,0x6e,0x0,0x8,0x0,0x6e,0x8,0x8,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x8,0x8,0x0,0x0,0x6e,0x0,0x0,0x0,0x6e,0x0,0x0,0x6e,0x0,0x0,0x0,0x8,0x8,0x8,0x0,0x8,0x8,0x0,0x6e,0x0,0x0,0x6e,0x8,0x8,0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e,0x0,0x6e,0x0,0x6e,0x0,0x6e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x0,0x0,0x6e,0x0,0x6e,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[95];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with user supplied CharStream. */
  public TDLParser(CharStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = new TDLParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 347; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 347; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TDLParser(TDLParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 347; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TDLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 347; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        exists = true;
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[200];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 347; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 200; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 95; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
            case 80: jj_3_81(); break;
            case 81: jj_3_82(); break;
            case 82: jj_3_83(); break;
            case 83: jj_3_84(); break;
            case 84: jj_3_85(); break;
            case 85: jj_3_86(); break;
            case 86: jj_3_87(); break;
            case 87: jj_3_88(); break;
            case 88: jj_3_89(); break;
            case 89: jj_3_90(); break;
            case 90: jj_3_91(); break;
            case 91: jj_3_92(); break;
            case 92: jj_3_93(); break;
            case 93: jj_3_94(); break;
            case 94: jj_3_95(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
